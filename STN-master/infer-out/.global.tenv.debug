NAME: class sun.util.calendar.CalendarSystem
TYPE: class sun.util.calendar.CalendarSystem 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void CalendarSystem.<clinit>() 
      		void CalendarSystem.setEra(CalendarDate,String) 
      		int CalendarSystem.getMonthLength(CalendarDate) 
      		boolean CalendarSystem.validate(CalendarDate) 
      		CalendarDate CalendarSystem.getNthDayOfWeek(int,int,CalendarDate) 
      		CalendarDate CalendarSystem.newCalendarDate() 
      		CalendarDate CalendarSystem.getCalendarDate(long) 
      		CalendarSystem.<init>() 
      		CalendarSystem CalendarSystem.forName(String) 
      		Era CalendarSystem.getEra(String) 
      		String CalendarSystem.getName() 
      		int CalendarSystem.getYearLength(CalendarDate) 
      		CalendarDate CalendarSystem.setTimeOfDay(CalendarDate,int) 
      		CalendarDate CalendarSystem.getCalendarDate() 
      		Gregorian CalendarSystem.getGregorianCalendar() 
      		boolean CalendarSystem.normalize(CalendarDate) 
      		void CalendarSystem.initNames() 
      		CalendarDate CalendarSystem.getCalendarDate(long,CalendarDate) 
      		long CalendarSystem.getTime(CalendarDate) 
      		int CalendarSystem.getWeekLength() 
      		CalendarDate CalendarSystem.newCalendarDate(TimeZone) 
      		Era[] CalendarSystem.getEras() 
      		int CalendarSystem.getYearLengthInMonths(CalendarDate) 
      		CalendarDate CalendarSystem.getCalendarDate(long,TimeZone) 
      		Properties CalendarSystem.getCalendarProperties()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.event.TransportListener
TYPE: class javax.mail.event.TransportListener 
      	fields: {
      	}
      	supers: {
      		class java.util.EventListener
      	}
      	methods: {
      		void TransportListener.messagePartiallyDelivered(TransportEvent) 
      		void TransportListener.messageDelivered(TransportEvent) 
      		void TransportListener.messageNotDelivered(TransportEvent)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.Date
TYPE: class java.sql.Date 
      	fields: {
      		sun.util.calendar.BaseCalendar$Date* cdate <> 
      		long fastTime <>
      	}
      	supers: {
      		class java.util.Date
      	}
      	methods: {
      		int Date.getHours() 
      		Date Date.valueOf(String) 
      		int Date.getSeconds() 
      		void Date.setMinutes(int) 
      		Date.<init>(int,int,int) 
      		void Date.setTime(long) 
      		Instant Date.toInstant() 
      		LocalDate Date.toLocalDate() 
      		int Date.getMinutes() 
      		void Date.setHours(int) 
      		String Date.toString() 
      		Date Date.valueOf(LocalDate) 
      		void Date.setSeconds(int) 
      		Date.<init>(long)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.File
TYPE: class java.io.File 
      	fields: {
      		java.lang.String* path <_final> 
      		java.io.File$PathStatus* status <> 
      		java.nio.file.Path* filePath <_volatile> 
      		int prefixLength <_final>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable 
      		class java.lang.Comparable
      	}
      	methods: {
      		void File.<clinit>() 
      		File[] File.listRoots() 
      		File.<init>(String,int) 
      		int File.hashCode() 
      		boolean File.setReadable(boolean) 
      		URI File.toURI() 
      		boolean File.exists() 
      		URL File.toURL() 
      		String[] File.list() 
      		boolean File.equals(Object) 
      		void File.deleteOnExit() 
      		boolean File.mkdirs() 
      		File File.createTempFile(String,String,File) 
      		String File.getCanonicalPath() 
      		long File.getFreeSpace() 
      		boolean File.isHidden() 
      		int File.compareTo(Object) 
      		boolean File.renameTo(File) 
      		void File.writeObject(ObjectOutputStream) 
      		boolean File.isInvalid() 
      		boolean File.canExecute() 
      		boolean File.canWrite() 
      		File.<init>(String,File) 
      		boolean File.isAbsolute() 
      		String File.getPath() 
      		File[] File.listFiles(FilenameFilter) 
      		int File.compareTo(File) 
      		String File.slashify(String,boolean) 
      		File File.createTempFile(String,String) 
      		String File.getName() 
      		File.<init>(String,String) 
      		boolean File.createNewFile() 
      		File File.getCanonicalFile() 
      		int File.getPrefixLength() 
      		String File.getParent() 
      		boolean File.setReadOnly() 
      		boolean File.setReadable(boolean,boolean) 
      		void File.readObject(ObjectInputStream) 
      		String File.getAbsolutePath() 
      		boolean File.setExecutable(boolean) 
      		boolean File.canRead() 
      		String[] File.list(FilenameFilter) 
      		File[] File.listFiles() 
      		boolean File.isDirectory() 
      		long File.getUsableSpace() 
      		long File.lastModified() 
      		boolean File.mkdir() 
      		String File.toString() 
      		boolean File.setLastModified(long) 
      		boolean File.setWritable(boolean,boolean) 
      		long File.getTotalSpace() 
      		boolean File.isFile() 
      		File[] File.listFiles(FileFilter) 
      		File.<init>(String) 
      		File File.getAbsoluteFile() 
      		Path File.toPath() 
      		File.<init>(File,String) 
      		boolean File.delete() 
      		File File.getParentFile() 
      		File.<init>(URI) 
      		long File.length() 
      		boolean File.setWritable(boolean) 
      		boolean File.setExecutable(boolean,boolean)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.ObjectInputStream$HandleTable
TYPE: class java.io.ObjectInputStream$HandleTable 
      	fields: {
      		java.io.ObjectInputStream$HandleTable$HandleList*[_*_](*) deps <> 
      		int size <> 
      		signed char[_*_](*) status <> 
      		int lowDep <> 
      		java.lang.Object*[_*_](*) entries <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		ObjectInputStream$HandleTable.<init>(int) 
      		Object ObjectInputStream$HandleTable.lookupObject(int) 
      		void ObjectInputStream$HandleTable.markDependency(int,int) 
      		int ObjectInputStream$HandleTable.size() 
      		void ObjectInputStream$HandleTable.setObject(int,Object) 
      		void ObjectInputStream$HandleTable.markException(int,ClassNotFoundException) 
      		int ObjectInputStream$HandleTable.assign(Object) 
      		ClassNotFoundException ObjectInputStream$HandleTable.lookupException(int) 
      		void ObjectInputStream$HandleTable.grow() 
      		void ObjectInputStream$HandleTable.finish(int) 
      		void ObjectInputStream$HandleTable.clear()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.ParameterMetaData
TYPE: class java.sql.ParameterMetaData 
      	fields: {
      	}
      	supers: {
      		class java.sql.Wrapper
      	}
      	methods: {
      		String ParameterMetaData.getParameterClassName(int) 
      		int ParameterMetaData.getPrecision(int) 
      		int ParameterMetaData.getParameterType(int) 
      		int ParameterMetaData.isNullable(int) 
      		int ParameterMetaData.getParameterMode(int) 
      		int ParameterMetaData.getScale(int) 
      		String ParameterMetaData.getParameterTypeName(int) 
      		int ParameterMetaData.getParameterCount() 
      		boolean ParameterMetaData.isSigned(int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.reflect.annotation.AnnotationType
TYPE: class sun.reflect.annotation.AnnotationType 
      	fields: {
      		java.util.Map* members <_final> 
      		java.lang.annotation.RetentionPolicy* retention <_final> 
      		java.util.Map* memberTypes <_final> 
      		_Bool inherited <_final> 
      		java.util.Map* memberDefaults <_final>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void AnnotationType.<clinit>() 
      		AnnotationType.<init>(Class) 
      		Class AnnotationType.invocationHandlerReturnType(Class) 
      		RetentionPolicy AnnotationType.retention() 
      		AnnotationType AnnotationType.getInstance(Class) 
      		Map AnnotationType.members() 
      		Map AnnotationType.memberTypes() 
      		String AnnotationType.toString() 
      		boolean AnnotationType.isInherited() 
      		Map AnnotationType.memberDefaults()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.reflect.generics.repository.AbstractRepository
TYPE: class sun.reflect.generics.repository.AbstractRepository 
      	fields: {
      		sun.reflect.generics.factory.GenericsFactory* factory <_final> 
      		sun.reflect.generics.tree.Tree* tree <_final>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		AbstractRepository.<init>(String,GenericsFactory) 
      		GenericsFactory AbstractRepository.getFactory() 
      		Tree AbstractRepository.parse(String) 
      		Reifier AbstractRepository.getReifier() 
      		Tree AbstractRepository.getTree()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Calendar
TYPE: class java.util.Calendar 
      	fields: {
      		int nextStamp <> 
      		int[_*_](*) stamp <> 
      		_Bool sharedZone <> 
      		_Bool areFieldsSet <> 
      		_Bool isTimeSet <> 
      		int serialVersionOnStream <> 
      		int[_*_](*) fields <> 
      		int firstDayOfWeek <> 
      		java.util.TimeZone* zone <> 
      		_Bool lenient <> 
      		_Bool areAllFieldsSet <> 
      		long time <> 
      		_Bool[_*_](*) isSet <> 
      		int minimalDaysInFirstWeek <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable 
      		class java.lang.Cloneable 
      		class java.lang.Comparable
      	}
      	methods: {
      		void Calendar.<clinit>() 
      		int Calendar.getWeeksInWeekYear() 
      		int Calendar.getGreatestMinimum(int) 
      		int Calendar.hashCode() 
      		boolean Calendar.isStandaloneStyle(int) 
      		boolean Calendar.isExternallySet(int) 
      		int Calendar.getLeastMaximum(int) 
      		void Calendar.updateTime() 
      		boolean Calendar.equals(Object) 
      		boolean Calendar.isFieldSet(int,int) 
      		void Calendar.add(int,int) 
      		boolean Calendar.isNarrowStyle(int) 
      		void Calendar.setTimeZone(TimeZone) 
      		Calendar.<init>(TimeZone,Locale) 
      		Locale[] Calendar.getAvailableLocales() 
      		boolean Calendar.isWeekDateSupported() 
      		int Calendar.getBaseStyle(int) 
      		int Calendar.compareTo(Object) 
      		boolean Calendar.isPartiallyNormalized() 
      		boolean Calendar.isLenient() 
      		Object Calendar.clone() 
      		void Calendar.internalSet(int,int) 
      		Calendar Calendar.getInstance(TimeZone) 
      		int Calendar.getMaximum(int) 
      		int Calendar.compareTo(long) 
      		int Calendar.get(int) 
      		void Calendar.roll(int,int) 
      		void Calendar.set(int,int,int,int,int,int) 
      		void Calendar.writeObject(ObjectOutputStream) 
      		int Calendar.getActualMaximum(int) 
      		void Calendar.appendValue(StringBuilder,String,boolean,long) 
      		void Calendar.setFieldsComputed(int) 
      		TimeZone Calendar.getZone() 
      		void Calendar.complete() 
      		void Calendar.computeFields() 
      		boolean Calendar.before(Object) 
      		Calendar.<init>() 
      		Calendar Calendar.createCalendar(TimeZone,Locale) 
      		int Calendar.getFirstDayOfWeek() 
      		void Calendar.clear(int) 
      		Instant Calendar.toInstant() 
      		void Calendar.setUnnormalized() 
      		boolean Calendar.checkDisplayNameParams(int,int,int,int,Locale,int) 
      		void Calendar.set(int,int,int) 
      		void Calendar.roll(int,boolean) 
      		void Calendar.setFirstDayOfWeek(int) 
      		void Calendar.set(int,int) 
      		void Calendar.readObject(ObjectInputStream) 
      		int Calendar.getActualMinimum(int) 
      		int Calendar.getMinimum(int) 
      		boolean Calendar.isNarrowFormatStyle(int) 
      		int Calendar.getSetStateFields() 
      		TimeZone Calendar.getTimeZone() 
      		int Calendar.aggregateStamp(int,int) 
      		Date Calendar.getTime() 
      		Set Calendar.getAvailableCalendarTypes() 
      		void Calendar.setWeekCountData(Locale) 
      		void Calendar.setLenient(boolean) 
      		void Calendar.computeTime() 
      		int Calendar.getWeekYear() 
      		String[] Calendar.getFieldStrings(int,int,DateFormatSymbols) 
      		Calendar Calendar.getInstance(TimeZone,Locale) 
      		boolean Calendar.isFullyNormalized() 
      		String Calendar.toString() 
      		void Calendar.adjustStamp() 
      		Calendar Calendar.getInstance(Locale) 
      		boolean Calendar.isSet(int) 
      		int Calendar.compareTo(Calendar) 
      		void Calendar.setZoneShared(boolean) 
      		long Calendar.getTimeInMillis() 
      		String Calendar.getFieldName(int) 
      		int Calendar.toStandaloneStyle(int) 
      		void Calendar.setFieldsNormalized(int) 
      		Map Calendar.getDisplayNames(int,int,Locale) 
      		int Calendar.internalGet(int) 
      		Calendar Calendar.getInstance() 
      		long Calendar.getMillisOf(Calendar) 
      		void Calendar.setTime(Date) 
      		boolean Calendar.after(Object) 
      		void Calendar.clear() 
      		int Calendar.getMinimalDaysInFirstWeek() 
      		String Calendar.getDisplayName(int,int,Locale) 
      		Map Calendar.getDisplayNamesImpl(int,int,Locale) 
      		void Calendar.setTimeInMillis(long) 
      		int Calendar.selectFields() 
      		String Calendar.getCalendarType() 
      		void Calendar.set(int,int,int,int,int) 
      		void Calendar.setWeekDate(int,int,int) 
      		void Calendar.invalidateWeekFields() 
      		void Calendar.setMinimalDaysInFirstWeek(int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.RegisterProcess
TYPE: class com.stn.servlets.RegisterProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void RegisterProcess.setTempFields(HttpServletRequest,String,String,String,String) 
      		void RegisterProcess.doPost(HttpServletRequest,HttpServletResponse) 
      		RegisterProcess.<init>() 
      		void RegisterProcess.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/RegisterProcess")>
      	}NAME: class javax.servlet.Registration$Dynamic
TYPE: class javax.servlet.Registration$Dynamic 
      	fields: {
      	}
      	supers: {
      		class javax.servlet.Registration
      	}
      	methods: {
      		void Registration$Dynamic.setAsyncSupported(boolean)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.BodyPart
TYPE: class javax.mail.BodyPart 
      	fields: {
      		javax.mail.Multipart* parent <>
      	}
      	supers: {
      		class java.lang.Object 
      		class javax.mail.Part
      	}
      	methods: {
      		BodyPart.<init>() 
      		void BodyPart.setParent(Multipart) 
      		Multipart BodyPart.getParent()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Locale$Category
TYPE: class java.util.Locale$Category 
      	fields: {
      		java.lang.String* countryKey <_final> 
      		java.lang.String* languageKey <_final> 
      		java.lang.String* variantKey <_final> 
      		java.lang.String* scriptKey <_final> 
      		java.lang.String* name <_final> 
      		int ordinal <_final>
      	}
      	supers: {
      		class java.lang.Enum
      	}
      	methods: {
      		void Locale$Category.<clinit>() 
      		Locale$Category Locale$Category.valueOf(String) 
      		Locale$Category.<init>(String,int,String,String,String,String) 
      		Locale$Category[] Locale$Category.values()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.ServletConfig
TYPE: class javax.servlet.ServletConfig 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		String ServletConfig.getServletName() 
      		Enumeration ServletConfig.getInitParameterNames() 
      		String ServletConfig.getInitParameter(String) 
      		ServletContext ServletConfig.getServletContext()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.text.FieldPosition
TYPE: class java.text.FieldPosition 
      	fields: {
      		int endIndex <> 
      		java.text.Format$Field* attribute <> 
      		int field <> 
      		int beginIndex <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		FieldPosition.<init>(int) 
      		int FieldPosition.hashCode() 
      		FieldPosition.<init>(Format$Field,int) 
      		boolean FieldPosition.equals(Object) 
      		void FieldPosition.setEndIndex(int) 
      		int FieldPosition.getField() 
      		FieldPosition.<init>(Format$Field) 
      		boolean FieldPosition.access$200(FieldPosition,Format$Field,int) 
      		int FieldPosition.getEndIndex() 
      		boolean FieldPosition.matchesField(Format$Field,int) 
      		boolean FieldPosition.access$100(FieldPosition,Format$Field) 
      		int FieldPosition.getBeginIndex() 
      		String FieldPosition.toString() 
      		Format$FieldDelegate FieldPosition.getFieldDelegate() 
      		Format$Field FieldPosition.getFieldAttribute() 
      		void FieldPosition.setBeginIndex(int) 
      		boolean FieldPosition.matchesField(Format$Field)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.Authenticator
TYPE: class javax.mail.Authenticator 
      	fields: {
      		java.lang.String* requestingProtocol <> 
      		java.net.InetAddress* requestingSite <> 
      		java.lang.String* requestingUserName <> 
      		java.lang.String* requestingPrompt <> 
      		int requestingPort <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		String Authenticator.getRequestingPrompt() 
      		int Authenticator.getRequestingPort() 
      		PasswordAuthentication Authenticator.getPasswordAuthentication() 
      		Authenticator.<init>() 
      		InetAddress Authenticator.getRequestingSite() 
      		PasswordAuthentication Authenticator.requestPasswordAuthentication(InetAddress,int,String,String,String) 
      		String Authenticator.getDefaultUserName() 
      		String Authenticator.getRequestingProtocol() 
      		void Authenticator.reset()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.management.ObjectName$Property
TYPE: class javax.management.ObjectName$Property 
      	fields: {
      		int _key_length <> 
      		int _key_index <> 
      		int _value_length <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		String ObjectName$Property.getValueString(String) 
      		String ObjectName$Property.getKeyString(String) 
      		ObjectName$Property.<init>(int,int,int) 
      		void ObjectName$Property.setKeyIndex(int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.Service
TYPE: class javax.mail.Service 
      	fields: {
      		java.util.Vector* connectionListeners <_final> 
      		javax.mail.Session* session <> 
      		javax.mail.EventQueue* q <> 
      		javax.mail.URLName* url <> 
      		java.lang.Object* qLock <> 
      		_Bool debug <> 
      		_Bool connected <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Service.connect(String,int,String,String) 
      		boolean Service.protocolConnect(String,int,String,String) 
      		Service.<init>(Session,URLName) 
      		void Service.addConnectionListener(ConnectionListener) 
      		void Service.setURLName(URLName) 
      		void Service.close() 
      		void Service.finalize() 
      		void Service.queueEvent(MailEvent,Vector) 
      		void Service.setConnected(boolean) 
      		void Service.connect(String,String) 
      		boolean Service.isConnected() 
      		void Service.terminateQueue() 
      		String Service.toString() 
      		void Service.removeConnectionListener(ConnectionListener) 
      		URLName Service.getURLName() 
      		void Service.notifyConnectionListeners(int) 
      		void Service.connect() 
      		void Service.connect(String,String,String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Random
TYPE: class java.util.Random 
      	fields: {
      		_Bool haveNextNextGaussian <> 
      		double nextNextGaussian <> 
      		java.util.concurrent.atomic.AtomicLong* seed <_final>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable
      	}
      	methods: {
      		void Random.<clinit>() 
      		int Random.next(int) 
      		DoubleStream Random.doubles() 
      		IntStream Random.ints() 
      		boolean Random.nextBoolean() 
      		LongStream Random.longs() 
      		int Random.internalNextInt(int,int) 
      		void Random.writeObject(ObjectOutputStream) 
      		DoubleStream Random.doubles(double,double) 
      		IntStream Random.ints(int,int) 
      		long Random.nextLong() 
      		Random.<init>() 
      		double Random.nextGaussian() 
      		LongStream Random.longs(long,long) 
      		long Random.internalNextLong(long,long) 
      		void Random.readObject(ObjectInputStream) 
      		DoubleStream Random.doubles(long,double,double) 
      		IntStream Random.ints(long,int,int) 
      		int Random.nextInt() 
      		float Random.nextFloat() 
      		LongStream Random.longs(long,long,long) 
      		double Random.internalNextDouble(double,double) 
      		long Random.seedUniquifier() 
      		int Random.nextInt(int) 
      		LongStream Random.longs(long) 
      		double Random.nextDouble() 
      		IntStream Random.ints(long) 
      		long Random.initialScramble(long) 
      		void Random.nextBytes(byte[]) 
      		void Random.resetSeed(long) 
      		DoubleStream Random.doubles(long) 
      		Random.<init>(long) 
      		void Random.setSeed(long)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.misc.ObjectStreamClassValidator
TYPE: class sun.misc.ObjectStreamClassValidator 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void ObjectStreamClassValidator.validateDescriptor(ObjectStreamClass)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.ObjDoubleConsumer
TYPE: class java.util.function.ObjDoubleConsumer 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void ObjDoubleConsumer.accept(Object,double)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.sql.DriverPropertyInfo
TYPE: class java.sql.DriverPropertyInfo 
      	fields: {
      		java.lang.String* name <> 
      		_Bool required <> 
      		java.lang.String* value <> 
      		java.lang.String*[_*_](*) choices <> 
      		java.lang.String* description <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		DriverPropertyInfo.<init>(String,String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.util.calendar.BaseCalendar
TYPE: class sun.util.calendar.BaseCalendar 
      	fields: {
      		sun.util.calendar.Era*[_*_](*) eras <>
      	}
      	supers: {
      		class sun.util.calendar.AbstractCalendar
      	}
      	methods: {
      		void BaseCalendar.<clinit>() 
      		int BaseCalendar.getDayOfWeekFromFixedDate(long) 
      		int BaseCalendar.getMonthLength(CalendarDate) 
      		boolean BaseCalendar.validate(CalendarDate) 
      		boolean BaseCalendar.isLeapYear(int) 
      		long BaseCalendar.getFixedDate(int,int,int,BaseCalendar$Date) 
      		int BaseCalendar.getYearFromFixedDate(long) 
      		BaseCalendar.<init>() 
      		int BaseCalendar.getDayOfWeek(CalendarDate) 
      		int BaseCalendar.getYearLength(CalendarDate) 
      		long BaseCalendar.getFixedDate(CalendarDate) 
      		void BaseCalendar.normalizeMonth(CalendarDate) 
      		long BaseCalendar.getDayOfYear(CalendarDate) 
      		int BaseCalendar.getMonthLength(int,int) 
      		boolean BaseCalendar.normalize(CalendarDate) 
      		long BaseCalendar.getDayOfYear(int,int,int) 
      		void BaseCalendar.getCalendarDateFromFixedDate(CalendarDate,long) 
      		boolean BaseCalendar.isLeapYear(CalendarDate) 
      		int BaseCalendar.getYearLengthInMonths(CalendarDate) 
      		int BaseCalendar.getGregorianYearFromFixedDate(long)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.SessionCookieConfig
TYPE: class javax.servlet.SessionCookieConfig 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		boolean SessionCookieConfig.isHttpOnly() 
      		int SessionCookieConfig.getMaxAge() 
      		void SessionCookieConfig.setComment(String) 
      		String SessionCookieConfig.getPath() 
      		String SessionCookieConfig.getName() 
      		void SessionCookieConfig.setDomain(String) 
      		void SessionCookieConfig.setName(String) 
      		void SessionCookieConfig.setMaxAge(int) 
      		void SessionCookieConfig.setPath(String) 
      		String SessionCookieConfig.getComment() 
      		void SessionCookieConfig.setSecure(boolean) 
      		String SessionCookieConfig.getDomain() 
      		void SessionCookieConfig.setHttpOnly(boolean) 
      		boolean SessionCookieConfig.isSecure()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.reflect.generics.repository.GenericDeclRepository
TYPE: class sun.reflect.generics.repository.GenericDeclRepository 
      	fields: {
      		java.lang.reflect.TypeVariable*[_*_](*) typeParams <_volatile> 
      		sun.reflect.generics.factory.GenericsFactory* factory <_final> 
      		sun.reflect.generics.tree.Tree* tree <_final>
      	}
      	supers: {
      		class sun.reflect.generics.repository.AbstractRepository
      	}
      	methods: {
      		GenericDeclRepository.<init>(String,GenericsFactory) 
      		TypeVariable[] GenericDeclRepository.getTypeParameters()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.Flushable
TYPE: class java.io.Flushable 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void Flushable.flush()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.http.HttpServletResponse
TYPE: class javax.servlet.http.HttpServletResponse 
      	fields: {
      	}
      	supers: {
      		class javax.servlet.ServletResponse
      	}
      	methods: {
      		void HttpServletResponse.sendError(int) 
      		Collection HttpServletResponse.getHeaderNames() 
      		String HttpServletResponse.getHeader(String) 
      		void HttpServletResponse.addCookie(Cookie) 
      		void HttpServletResponse.sendError(int,String) 
      		void HttpServletResponse.addIntHeader(String,int) 
      		void HttpServletResponse.setStatus(int) 
      		String HttpServletResponse.encodeURL(String) 
      		void HttpServletResponse.setDateHeader(String,long) 
      		void HttpServletResponse.addHeader(String,String) 
      		Supplier HttpServletResponse.getTrailerFields() 
      		int HttpServletResponse.getStatus() 
      		String HttpServletResponse.encodeUrl(String) 
      		void HttpServletResponse.sendRedirect(String) 
      		void HttpServletResponse.addDateHeader(String,long) 
      		void HttpServletResponse.setTrailerFields(Supplier) 
      		void HttpServletResponse.setStatus(int,String) 
      		String HttpServletResponse.encodeRedirectURL(String) 
      		void HttpServletResponse.setIntHeader(String,int) 
      		void HttpServletResponse.setHeader(String,String) 
      		boolean HttpServletResponse.containsHeader(String) 
      		Collection HttpServletResponse.getHeaders(String) 
      		String HttpServletResponse.encodeRedirectUrl(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.FileOutputStream
TYPE: class java.io.FileOutputStream 
      	fields: {
      		java.lang.String* path <_final> 
      		java.lang.Object* closeLock <_final> 
      		java.nio.channels.FileChannel* channel <> 
      		_Bool append <_final> 
      		_Bool closed <_volatile> 
      		java.io.FileDescriptor* fd <_final>
      	}
      	supers: {
      		class java.io.OutputStream
      	}
      	methods: {
      		void FileOutputStream.<clinit>() 
      		FileOutputStream.<init>(FileDescriptor) 
      		void FileOutputStream.access$000(FileOutputStream) 
      		FileChannel FileOutputStream.getChannel() 
      		void FileOutputStream.write(int,boolean) 
      		void FileOutputStream.write(byte[]) 
      		FileDescriptor FileOutputStream.getFD() 
      		void FileOutputStream.open(String,boolean) 
      		FileOutputStream.<init>(String,boolean) 
      		void FileOutputStream.write(int) 
      		void FileOutputStream.close() 
      		void FileOutputStream.finalize() 
      		void FileOutputStream.close0() 
      		void FileOutputStream.writeBytes(byte[],int,int,boolean) 
      		void FileOutputStream.initIDs() 
      		void FileOutputStream.open0(String,boolean) 
      		FileOutputStream.<init>(File,boolean) 
      		void FileOutputStream.write(byte[],int,int) 
      		FileOutputStream.<init>(String) 
      		FileOutputStream.<init>(File)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.ServletOutputStream
TYPE: class javax.servlet.ServletOutputStream 
      	fields: {
      	}
      	supers: {
      		class java.io.OutputStream
      	}
      	methods: {
      		void ServletOutputStream.<clinit>() 
      		boolean ServletOutputStream.isReady() 
      		void ServletOutputStream.print(boolean) 
      		void ServletOutputStream.println(double) 
      		void ServletOutputStream.print(long) 
      		void ServletOutputStream.println(char) 
      		void ServletOutputStream.print(char) 
      		void ServletOutputStream.println(String) 
      		ServletOutputStream.<init>() 
      		void ServletOutputStream.print(double) 
      		void ServletOutputStream.println(long) 
      		void ServletOutputStream.println() 
      		void ServletOutputStream.print(float) 
      		void ServletOutputStream.setWriteListener(WriteListener) 
      		void ServletOutputStream.println(int) 
      		void ServletOutputStream.print(int) 
      		void ServletOutputStream.println(boolean) 
      		void ServletOutputStream.println(float) 
      		void ServletOutputStream.print(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.IntBinaryOperator
TYPE: class java.util.function.IntBinaryOperator 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		int IntBinaryOperator.applyAsInt(int,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.util.function.ObjIntConsumer
TYPE: class java.util.function.ObjIntConsumer 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void ObjIntConsumer.accept(Object,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.text.Format
TYPE: class java.text.Format 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable 
      		class java.lang.Cloneable
      	}
      	methods: {
      		AttributedCharacterIterator Format.formatToCharacterIterator(Object) 
      		AttributedCharacterIterator Format.createAttributedCharacterIterator(AttributedCharacterIterator,AttributedCharacterIterator$Attribute,Object) 
      		Object Format.clone() 
      		AttributedCharacterIterator Format.createAttributedCharacterIterator(String) 
      		AttributedCharacterIterator Format.createAttributedCharacterIterator(AttributedCharacterIterator[]) 
      		Format.<init>() 
      		Object Format.parseObject(String) 
      		Object Format.parseObject(String,ParsePosition) 
      		AttributedCharacterIterator Format.createAttributedCharacterIterator(String,AttributedCharacterIterator$Attribute,Object) 
      		String Format.format(Object) 
      		StringBuffer Format.format(Object,StringBuffer,FieldPosition)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Set
TYPE: class java.util.Set 
      	fields: {
      	}
      	supers: {
      		class java.util.Collection
      	}
      	methods: {
      		int Set.hashCode() 
      		boolean Set.removeAll(Collection) 
      		boolean Set.equals(Object) 
      		int Set.size() 
      		Iterator Set.iterator() 
      		boolean Set.contains(Object) 
      		Object[] Set.toArray() 
      		boolean Set.containsAll(Collection) 
      		Object[] Set.toArray(Object[]) 
      		boolean Set.remove(Object) 
      		boolean Set.retainAll(Collection) 
      		Spliterator Set.spliterator() 
      		boolean Set.addAll(Collection) 
      		boolean Set.add(Object) 
      		boolean Set.isEmpty() 
      		void Set.clear()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.Servlet
TYPE: class javax.servlet.Servlet 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		ServletConfig Servlet.getServletConfig() 
      		void Servlet.init(ServletConfig) 
      		void Servlet.destroy() 
      		String Servlet.getServletInfo() 
      		void Servlet.service(ServletRequest,ServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.IntFunction
TYPE: class java.util.function.IntFunction 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Object IntFunction.apply(int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.sql.Struct
TYPE: class java.sql.Struct 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		String Struct.getSQLTypeName() 
      		Object[] Struct.getAttributes(Map) 
      		Object[] Struct.getAttributes()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.Ref
TYPE: class java.sql.Ref 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void Ref.setObject(Object) 
      		Object Ref.getObject(Map) 
      		String Ref.getBaseTypeName() 
      		Object Ref.getObject()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.ObjectInputStream
TYPE: class java.io.ObjectInputStream 
      	fields: {
      		java.io.InputStream* in <> 
      		java.io.SerialCallbackContext* curContext <> 
      		java.io.ObjectInputStream$ValidationList* vlist <_final> 
      		_Bool enableResolve <> 
      		_Bool defaultDataEnd <> 
      		long depth <> 
      		java.io.ObjectInputStream$HandleTable* handles <_final> 
      		sun.misc.ObjectInputFilter* serialFilter <> 
      		sun.misc.ObjectStreamClassValidator* validator <_volatile> 
      		_Bool closed <> 
      		long totalObjectRefs <> 
      		java.io.ObjectInputStream$BlockDataInputStream* bin <_final> 
      		_Bool enableOverride <_final> 
      		signed char[_*_](*) primVals <> 
      		int passHandle <>
      	}
      	supers: {
      		class java.io.InputStream 
      		class java.io.ObjectInput 
      		class java.io.ObjectStreamConstants
      	}
      	methods: {
      		void ObjectInputStream.<clinit>() 
      		Object ObjectInputStream.readObject0(boolean) 
      		boolean ObjectInputStream.readBoolean() 
      		ObjectInputFilter ObjectInputStream.access$100(ObjectInputStream) 
      		ClassLoader ObjectInputStream.latestUserDefinedLoader() 
      		Object ObjectInputStream.readUnshared() 
      		void ObjectInputStream.readExternalData(Externalizable,ObjectStreamClass) 
      		float ObjectInputStream.readFloat() 
      		Object ObjectInputStream.readArray(boolean) 
      		void ObjectInputStream.access$1100(ObjectInputStream) 
      		void ObjectInputStream.skipCustomData() 
      		int ObjectInputStream.readUnsignedShort() 
      		Class ObjectInputStream.readClass(boolean) 
      		ObjectInputStream$BlockDataInputStream ObjectInputStream.access$700(ObjectInputStream) 
      		void ObjectInputStream.verifySubclass() 
      		int ObjectInputStream.available() 
      		ObjectStreamClass ObjectInputStream.readProxyDesc(boolean) 
      		Object ObjectInputStream.cloneArray(Object) 
      		ObjectInputStream.<init>(InputStream) 
      		void ObjectInputStream.access_java.io.ObjectInputStream$Lambda$_1_152(ObjectInputStream,ObjectStreamClassValidator) 
      		void ObjectInputStream.readFully(byte[]) 
      		void ObjectInputStream.registerValidation(ObjectInputValidation,int) 
      		ObjectInputFilter ObjectInputStream.getInternalObjectInputFilter() 
      		int ObjectInputStream.readUnsignedByte() 
      		Object ObjectInputStream.readNull() 
      		int ObjectInputStream.access$500(ObjectInputStream) 
      		String ObjectInputStream.readLine() 
      		Object ObjectInputStream.readOrdinaryObject(boolean) 
      		void ObjectInputStream.access$1300(byte[],int,double[],int,int) 
      		void ObjectInputStream.close() 
      		int ObjectInputStream.read(byte[],int,int) 
      		ObjectStreamClass ObjectInputStream.readClassDescriptor() 
      		ObjectInputStream.<init>() 
      		void ObjectInputStream.readStreamHeader() 
      		int ObjectInputStream.readInt() 
      		String ObjectInputStream.readString(boolean) 
      		boolean ObjectInputStream.auditSubclass(Class) 
      		int ObjectInputStream.access$502(ObjectInputStream,int) 
      		void ObjectInputStream.validateDescriptor(ObjectStreamClass) 
      		Object ObjectInputStream.resolveObject(Object) 
      		ObjectInputStream$GetField ObjectInputStream.readFields() 
      		void ObjectInputStream.filterCheck(Class,int) 
      		String ObjectInputStream.readTypeString() 
      		void ObjectInputStream.bytesToFloats(byte[],int,float[],int,int) 
      		void ObjectInputStream.checkArray(Class,int) 
      		byte ObjectInputStream.readByte() 
      		void ObjectInputStream.access$200(ObjectInputStream,Class,int) 
      		void ObjectInputStream.readSerialData(Object,ObjectStreamClass) 
      		double ObjectInputStream.readDouble() 
      		Enum ObjectInputStream.readEnum(boolean) 
      		void ObjectInputStream.access$1200(byte[],int,float[],int,int) 
      		int ObjectInputStream.read() 
      		int ObjectInputStream.skipBytes(int) 
      		char ObjectInputStream.readChar() 
      		ObjectStreamClass ObjectInputStream.readClassDesc(boolean) 
      		Object ObjectInputStream.access$800(ObjectInputStream,boolean) 
      		ObjectStreamClass ObjectInputStream.readNonProxyDesc(boolean) 
      		void ObjectInputStream.defaultReadObject() 
      		void ObjectInputStream.readFully(byte[],int,int) 
      		boolean ObjectInputStream.enableResolveObject(boolean) 
      		void ObjectInputStream.bytesToDoubles(byte[],int,double[],int,int) 
      		void ObjectInputStream.setInternalObjectInputFilter(ObjectInputFilter) 
      		short ObjectInputStream.readShort() 
      		Object ObjectInputStream.readHandle(boolean) 
      		ObjectInputStream$HandleTable ObjectInputStream.access$600(ObjectInputStream) 
      		void ObjectInputStream.defaultReadFields(Object,ObjectStreamClass) 
      		String ObjectInputStream.readUTF() 
      		IOException ObjectInputStream.readFatalException() 
      		JavaObjectInputStreamAccess ObjectInputStream.callsite_java.io.ObjectInputStream$Lambda$_1_152() 
      		void ObjectInputStream.setValidator(ObjectInputStream,ObjectStreamClassValidator) 
      		Class ObjectInputStream.resolveClass(ObjectStreamClass) 
      		Object ObjectInputStream.readObjectOverride() 
      		void ObjectInputStream.clear() 
      		long ObjectInputStream.readLong() 
      		Object ObjectInputStream.checkResolve(Object) 
      		boolean ObjectInputStream.access$1000(ObjectInputStream) 
      		Class ObjectInputStream.resolveProxyClass(String[]) 
      		boolean ObjectInputStream.isCustomSubclass() 
      		Object ObjectInputStream.readObject() 
      		void ObjectInputStream.access$000(ObjectInputStream,ObjectInputFilter) 
      		void ObjectInputStream.handleReset()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.management.AttributeList
TYPE: class javax.management.AttributeList 
      	fields: {
      		_Bool typeSafe <_volatile> 
      		_Bool tainted <_volatile> 
      		int size <> 
      		java.lang.Object*[_*_](*) elementData <> 
      		int mIsEmpty <> 
      		int modCount <>
      	}
      	supers: {
      		class java.util.ArrayList
      	}
      	methods: {
      		AttributeList.<init>(int) 
      		void AttributeList.set(int,Attribute) 
      		void AttributeList.adding(Collection) 
      		void AttributeList.add(int,Object) 
      		Object AttributeList.set(int,Object) 
      		AttributeList.<init>(List) 
      		boolean AttributeList.addAll(int,AttributeList) 
      		void AttributeList.adding(Object) 
      		AttributeList.<init>() 
      		boolean AttributeList.addAll(int,Collection) 
      		void AttributeList.add(Attribute) 
      		boolean AttributeList.addAll(AttributeList) 
      		boolean AttributeList.addAll(Collection) 
      		boolean AttributeList.add(Object) 
      		List AttributeList.asList() 
      		AttributeList.<init>(AttributeList) 
      		void AttributeList.add(int,Attribute)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.text.NumberFormat
TYPE: class java.text.NumberFormat 
      	fields: {
      		int maximumIntegerDigits <> 
      		signed char minIntegerDigits <> 
      		int maximumFractionDigits <> 
      		_Bool groupingUsed <> 
      		int serialVersionOnStream <> 
      		signed char minFractionDigits <> 
      		int minimumIntegerDigits <> 
      		signed char maxFractionDigits <> 
      		int minimumFractionDigits <> 
      		signed char maxIntegerDigits <> 
      		_Bool parseIntegerOnly <>
      	}
      	supers: {
      		class java.text.Format
      	}
      	methods: {
      		NumberFormat NumberFormat.getPercentInstance() 
      		int NumberFormat.hashCode() 
      		NumberFormat NumberFormat.getIntegerInstance(Locale) 
      		int NumberFormat.getMinimumFractionDigits() 
      		boolean NumberFormat.equals(Object) 
      		String NumberFormat.format(long) 
      		int NumberFormat.getMaximumIntegerDigits() 
      		Locale[] NumberFormat.getAvailableLocales() 
      		NumberFormat NumberFormat.getInstance(Locale) 
      		NumberFormat NumberFormat.getInstance(LocaleProviderAdapter,Locale,int) 
      		Object NumberFormat.clone() 
      		RoundingMode NumberFormat.getRoundingMode() 
      		NumberFormat NumberFormat.getInstance() 
      		StringBuffer NumberFormat.format(long,StringBuffer,FieldPosition) 
      		NumberFormat NumberFormat.getScientificInstance(Locale) 
      		void NumberFormat.writeObject(ObjectOutputStream) 
      		String NumberFormat.fastFormat(double) 
      		Currency NumberFormat.getCurrency() 
      		boolean NumberFormat.isParseIntegerOnly() 
      		void NumberFormat.setMinimumIntegerDigits(int) 
      		NumberFormat.<init>() 
      		int NumberFormat.getMaximumFractionDigits() 
      		NumberFormat NumberFormat.getPercentInstance(Locale) 
      		NumberFormat NumberFormat.getNumberInstance(Locale) 
      		NumberFormat NumberFormat.getIntegerInstance() 
      		NumberFormat NumberFormat.getScientificInstance() 
      		void NumberFormat.readObject(ObjectInputStream) 
      		void NumberFormat.setGroupingUsed(boolean) 
      		Object NumberFormat.parseObject(String,ParsePosition) 
      		StringBuffer NumberFormat.format(double,StringBuffer,FieldPosition) 
      		void NumberFormat.setMinimumFractionDigits(int) 
      		Number NumberFormat.parse(String) 
      		int NumberFormat.getMinimumIntegerDigits() 
      		NumberFormat NumberFormat.getCurrencyInstance(Locale) 
      		void NumberFormat.setRoundingMode(RoundingMode) 
      		NumberFormat NumberFormat.getNumberInstance() 
      		boolean NumberFormat.isGroupingUsed() 
      		NumberFormat NumberFormat.getInstance(Locale,int) 
      		void NumberFormat.setCurrency(Currency) 
      		void NumberFormat.setParseIntegerOnly(boolean) 
      		void NumberFormat.setMaximumIntegerDigits(int) 
      		Number NumberFormat.parse(String,ParsePosition) 
      		void NumberFormat.setMaximumFractionDigits(int) 
      		String NumberFormat.format(double) 
      		StringBuffer NumberFormat.format(Object,StringBuffer,FieldPosition) 
      		NumberFormat NumberFormat.getCurrencyInstance()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.ref.Reference
TYPE: class java.lang.ref.Reference 
      	fields: {
      		java.lang.ref.Reference* next <_volatile> 
      		java.lang.ref.ReferenceQueue* queue <_volatile> 
      		java.lang.Object* referent <> 
      		java.lang.ref.Reference* discovered <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Reference.<clinit>() 
      		boolean Reference.enqueue() 
      		Reference.<init>(Object) 
      		boolean Reference.tryHandlePending(boolean) 
      		Object Reference.get() 
      		Reference.<init>(Object,ReferenceQueue) 
      		void Reference.clear() 
      		boolean Reference.isEnqueued()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.stream.Stream
TYPE: class java.util.stream.Stream 
      	fields: {
      	}
      	supers: {
      		class java.util.stream.BaseStream
      	}
      	methods: {
      		Stream Stream.generate(Supplier) 
      		Stream Stream.map(Function) 
      		Object Stream.reduce(Object,BinaryOperator) 
      		void Stream.forEach(Consumer) 
      		Stream Stream.distinct() 
      		boolean Stream.noneMatch(Predicate) 
      		Stream Stream.flatMap(Function) 
      		Optional Stream.min(Comparator) 
      		Stream Stream.limit(long) 
      		Stream Stream.empty() 
      		LongStream Stream.mapToLong(ToLongFunction) 
      		Object Stream.reduce(Object,BiFunction,BinaryOperator) 
      		Object[] Stream.toArray() 
      		Stream Stream.sorted(Comparator) 
      		Optional Stream.findAny() 
      		LongStream Stream.flatMapToLong(Function) 
      		boolean Stream.anyMatch(Predicate) 
      		void Stream.forEachOrdered(Consumer) 
      		Stream Stream.of(Object[]) 
      		Stream Stream.concat(Stream,Stream) 
      		IntStream Stream.mapToInt(ToIntFunction) 
      		Optional Stream.reduce(BinaryOperator) 
      		Stream Stream.sorted() 
      		Optional Stream.findFirst() 
      		IntStream Stream.flatMapToInt(Function) 
      		Optional Stream.max(Comparator) 
      		Stream Stream.skip(long) 
      		Stream Stream.of(Object) 
      		DoubleStream Stream.mapToDouble(ToDoubleFunction) 
      		Object Stream.collect(Supplier,BiConsumer,BiConsumer) 
      		long Stream.count() 
      		Stream Stream.peek(Consumer) 
      		Stream$Builder Stream.builder() 
      		DoubleStream Stream.flatMapToDouble(Function) 
      		boolean Stream.allMatch(Predicate) 
      		Object Stream.collect(Collector) 
      		Object[] Stream.toArray(IntFunction) 
      		Stream Stream.filter(Predicate) 
      		Stream Stream.iterate(Object,UnaryOperator)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.BufferedReader
TYPE: class java.io.BufferedReader 
      	fields: {
      		java.io.Reader* mReader <> 
      		unsigned short[_*_](*) cb <> 
      		int readAheadLimit <> 
      		int nextChar <> 
      		_Bool markedSkipLF <> 
      		int nChars <> 
      		_Bool skipLF <> 
      		int markedChar <> 
      		java.io.Reader* in <> 
      		java.lang.Object* lock <> 
      		unsigned short[_*_](*) skipBuffer <>
      	}
      	supers: {
      		class java.io.Reader
      	}
      	methods: {
      		void BufferedReader.<clinit>() 
      		int BufferedReader.read(char[],int,int) 
      		void BufferedReader.mark(int) 
      		long BufferedReader.skip(long) 
      		String BufferedReader.readLine() 
      		void BufferedReader.close() 
      		BufferedReader.<init>(Reader) 
      		int BufferedReader.read1(char[],int,int) 
      		boolean BufferedReader.ready() 
      		int BufferedReader.read() 
      		void BufferedReader.fill() 
      		Stream BufferedReader.lines() 
      		BufferedReader.<init>(Reader,int) 
      		String BufferedReader.readLine(boolean) 
      		void BufferedReader.reset() 
      		void BufferedReader.ensureOpen() 
      		boolean BufferedReader.markSupported()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.internet.InternetHeaders
TYPE: class javax.mail.internet.InternetHeaders 
      	fields: {
      		java.util.List* headers <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void InternetHeaders.<clinit>() 
      		Enumeration InternetHeaders.getNonMatchingHeaders(String[]) 
      		String[] InternetHeaders.getHeader(String) 
      		InternetHeaders.<init>(InputStream) 
      		Enumeration InternetHeaders.getNonMatchingHeaderLines(String[]) 
      		void InternetHeaders.addHeader(String,String) 
      		boolean InternetHeaders.isEmpty(String) 
      		String InternetHeaders.getHeader(String,String) 
      		InternetHeaders.<init>() 
      		Enumeration InternetHeaders.getAllHeaderLines() 
      		Enumeration InternetHeaders.getAllHeaders() 
      		void InternetHeaders.load(InputStream) 
      		void InternetHeaders.addHeaderLine(String) 
      		void InternetHeaders.removeHeader(String) 
      		void InternetHeaders.setHeader(String,String) 
      		Enumeration InternetHeaders.getMatchingHeaderLines(String[]) 
      		Enumeration InternetHeaders.getMatchingHeaders(String[])
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.ApplicationProcess
TYPE: class com.stn.servlets.ApplicationProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void ApplicationProcess.doPost(HttpServletRequest,HttpServletResponse) 
      		ApplicationProcess.<init>() 
      		void ApplicationProcess.setTempFields(HttpServletRequest,String,String,String,String,String,String,String) 
      		void ApplicationProcess.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/ApplicationProcess")>
      	}NAME: class java.util.function.DoubleToLongFunction
TYPE: class java.util.function.DoubleToLongFunction 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		long DoubleToLongFunction.applyAsLong(double)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.util.OptionalDouble
TYPE: class java.util.OptionalDouble 
      	fields: {
      		double value <_final> 
      		_Bool isPresent <_final>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void OptionalDouble.<clinit>() 
      		int OptionalDouble.hashCode() 
      		double OptionalDouble.orElseThrow(Supplier) 
      		boolean OptionalDouble.equals(Object) 
      		double OptionalDouble.getAsDouble() 
      		boolean OptionalDouble.isPresent() 
      		OptionalDouble OptionalDouble.empty() 
      		OptionalDouble.<init>() 
      		double OptionalDouble.orElse(double) 
      		String OptionalDouble.toString() 
      		void OptionalDouble.ifPresent(DoubleConsumer) 
      		OptionalDouble.<init>(double) 
      		OptionalDouble OptionalDouble.of(double) 
      		double OptionalDouble.orElseGet(DoubleSupplier)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.reflect.Executable
TYPE: class java.lang.reflect.Executable 
      	fields: {
      		_Bool hasRealParameterData <_volatile> 
      		java.util.Map* declaredAnnotations <> 
      		java.lang.reflect.Parameter*[_*_](*) parameters <_volatile> 
      		java.lang.Object* securityCheckCache <_volatile> 
      		_Bool override <>
      	}
      	supers: {
      		class java.lang.reflect.AccessibleObject 
      		class java.lang.reflect.Member 
      		class java.lang.reflect.GenericDeclaration
      	}
      	methods: {
      		Annotation[][] Executable.getParameterAnnotations() 
      		Annotation[][] Executable.sharedGetParameterAnnotations(Class[],byte[]) 
      		String Executable.sharedToGenericString(int,boolean) 
      		Annotation Executable.getAnnotation(Class) 
      		Type[] Executable.getGenericExceptionTypes() 
      		void Executable.printModifiersIfNonzero(StringBuilder,int,boolean) 
      		boolean Executable.isVarArgs() 
      		Parameter[] Executable.getParameters0() 
      		Class[] Executable.getExceptionTypes() 
      		Class Executable.getDeclaringClass() 
      		ConstructorRepository Executable.getGenericInfo() 
      		AnnotatedType Executable.getAnnotatedReturnType() 
      		AnnotatedType Executable.getAnnotatedReceiverType() 
      		Class[] Executable.getParameterTypes() 
      		Map Executable.declaredAnnotations() 
      		int Executable.getModifiers() 
      		byte[] Executable.getAnnotationBytes() 
      		Executable.<init>() 
      		boolean Executable.hasRealParameterData() 
      		String Executable.getName() 
      		AnnotatedType[] Executable.getAnnotatedParameterTypes() 
      		void Executable.verifyParameters(Parameter[]) 
      		TypeVariable[] Executable.getTypeParameters() 
      		boolean Executable.isSynthetic() 
      		void Executable.handleParameterNumberMismatch(int,int) 
      		AnnotatedType Executable.getAnnotatedReturnType0(Type) 
      		Annotation[][] Executable.parseParameterAnnotations(byte[]) 
      		void Executable.specificToStringHeader(StringBuilder) 
      		Parameter[] Executable.privateGetParameters() 
      		Annotation[] Executable.getAnnotationsByType(Class) 
      		boolean Executable.hasGenericInformation() 
      		boolean Executable.equalParamTypes(Class[],Class[]) 
      		void Executable.separateWithCommas(Class[],StringBuilder) 
      		byte[] Executable.getTypeAnnotationBytes() 
      		Parameter[] Executable.synthesizeAllParams() 
      		Annotation[] Executable.getDeclaredAnnotations() 
      		void Executable.specificToGenericStringHeader(StringBuilder) 
      		Type[] Executable.getGenericParameterTypes() 
      		byte[] Executable.getTypeAnnotationBytes0() 
      		Type[] Executable.getAllGenericParameterTypes() 
      		int Executable.getParameterCount() 
      		String Executable.toGenericString() 
      		String Executable.sharedToString(int,boolean,Class[],Class[]) 
      		Parameter[] Executable.getParameters() 
      		Executable Executable.getRoot() 
      		AnnotatedType[] Executable.getAnnotatedExceptionTypes()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Iterator
TYPE: class java.util.Iterator 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void Iterator.forEachRemaining(Consumer) 
      		boolean Iterator.hasNext() 
      		Object Iterator.next() 
      		void Iterator.remove()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.reflect.FieldAccessor
TYPE: class sun.reflect.FieldAccessor 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		long FieldAccessor.getLong(Object) 
      		void FieldAccessor.setInt(Object,int) 
      		void FieldAccessor.setBoolean(Object,boolean) 
      		Object FieldAccessor.get(Object) 
      		byte FieldAccessor.getByte(Object) 
      		double FieldAccessor.getDouble(Object) 
      		void FieldAccessor.setFloat(Object,float) 
      		void FieldAccessor.setChar(Object,char) 
      		short FieldAccessor.getShort(Object) 
      		float FieldAccessor.getFloat(Object) 
      		void FieldAccessor.setLong(Object,long) 
      		void FieldAccessor.setByte(Object,byte) 
      		char FieldAccessor.getChar(Object) 
      		void FieldAccessor.set(Object,Object) 
      		void FieldAccessor.setDouble(Object,double) 
      		boolean FieldAccessor.getBoolean(Object) 
      		void FieldAccessor.setShort(Object,short) 
      		int FieldAccessor.getInt(Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.PasswordAuthentication
TYPE: class javax.mail.PasswordAuthentication 
      	fields: {
      		java.lang.String* password <_final> 
      		java.lang.String* userName <_final>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		PasswordAuthentication.<init>(String,String) 
      		String PasswordAuthentication.getUserName() 
      		String PasswordAuthentication.getPassword()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.Provider
TYPE: class javax.mail.Provider 
      	fields: {
      		javax.mail.Provider$Type* type <> 
      		java.lang.String* vendor <> 
      		java.lang.String* protocol <> 
      		java.lang.String* className <> 
      		java.lang.String* version <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		String Provider.getProtocol() 
      		Provider.<init>(Provider$Type,String,String,String,String) 
      		String Provider.toString() 
      		Provider$Type Provider.getType() 
      		String Provider.getVersion() 
      		String Provider.getClassName() 
      		String Provider.getVendor()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.ProfileProcess
TYPE: class com.stn.servlets.ProfileProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void ProfileProcess.doPost(HttpServletRequest,HttpServletResponse) 
      		ProfileProcess.<init>() 
      		void ProfileProcess.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/ProfileProcess")>
      	}NAME: class com.stn.helpers.CommentsHelper
TYPE: class com.stn.helpers.CommentsHelper 
      	fields: {
      		java.lang.String* dbUser <> 
      		java.sql.PreparedStatement* preparedStatement <> 
      		java.lang.String* query <> 
      		java.lang.String* dbPort <> 
      		java.lang.String* dbHost <> 
      		java.lang.String* dbPassword <> 
      		java.sql.ResultSet* resultSet <> 
      		java.sql.Connection* connection <> 
      		java.lang.String* dbName <>
      	}
      	supers: {
      		class com.stn.utils.DBConnection
      	}
      	methods: {
      		void CommentsHelper.editComment(Integer,String) 
      		CommentsHelper.<init>() 
      		void CommentsHelper.addComment(Integer,Integer,String) 
      		Comments CommentsHelper.getComment(Integer) 
      		void CommentsHelper.addReply(Integer,Integer,String,String) 
      		List CommentsHelper.getComments(int) 
      		void CommentsHelper.deleteComment(Integer)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.helpers.ApplicationHelper
TYPE: class com.stn.helpers.ApplicationHelper 
      	fields: {
      		java.lang.String* dbUser <> 
      		java.sql.PreparedStatement* preparedStatement <> 
      		java.lang.String* query <> 
      		java.lang.String* dbPort <> 
      		java.lang.String* dbHost <> 
      		java.lang.String* dbPassword <> 
      		java.sql.ResultSet* resultSet <> 
      		java.sql.Connection* connection <> 
      		java.lang.String* dbName <>
      	}
      	supers: {
      		class com.stn.utils.DBConnection
      	}
      	methods: {
      		void ApplicationHelper.createInvite(String,int,int,int,String,int) 
      		void ApplicationHelper.addApplication(String,String,String,String,String,String,String) 
      		ApplicationHelper.<init>() 
      		List ApplicationHelper.getAplicatii() 
      		Invitatie ApplicationHelper.getInvitatie(String) 
      		void ApplicationHelper.deleteInvitatie(int) 
      		void ApplicationHelper.uptateApplicationStatus(int,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.List
TYPE: class java.util.List 
      	fields: {
      	}
      	supers: {
      		class java.util.Collection
      	}
      	methods: {
      		int List.hashCode() 
      		int List.indexOf(Object) 
      		boolean List.removeAll(Collection) 
      		boolean List.equals(Object) 
      		void List.add(int,Object) 
      		Object List.set(int,Object) 
      		List List.subList(int,int) 
      		int List.size() 
      		Iterator List.iterator() 
      		boolean List.contains(Object) 
      		ListIterator List.listIterator(int) 
      		Object[] List.toArray() 
      		boolean List.containsAll(Collection) 
      		Object[] List.toArray(Object[]) 
      		boolean List.remove(Object) 
      		boolean List.addAll(int,Collection) 
      		void List.sort(Comparator) 
      		boolean List.retainAll(Collection) 
      		Spliterator List.spliterator() 
      		Object List.remove(int) 
      		boolean List.addAll(Collection) 
      		void List.replaceAll(UnaryOperator) 
      		boolean List.add(Object) 
      		boolean List.isEmpty() 
      		int List.lastIndexOf(Object) 
      		Object List.get(int) 
      		ListIterator List.listIterator() 
      		void List.clear()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.nio.ByteBuffer
TYPE: class java.nio.ByteBuffer 
      	fields: {
      		_Bool nativeByteOrder <> 
      		_Bool isReadOnly <> 
      		_Bool bigEndian <> 
      		signed char[_*_](*) hb <_final> 
      		int offset <_final> 
      		int mark <> 
      		int capacity <> 
      		long address <> 
      		int position <> 
      		int limit <>
      	}
      	supers: {
      		class java.nio.Buffer 
      		class java.lang.Comparable
      	}
      	methods: {
      		byte ByteBuffer.get() 
      		int ByteBuffer.arrayOffset() 
      		IntBuffer ByteBuffer.asIntBuffer() 
      		int ByteBuffer.hashCode() 
      		ByteOrder ByteBuffer.order() 
      		ByteBuffer ByteBuffer.allocate(int) 
      		boolean ByteBuffer.equals(Object) 
      		FloatBuffer ByteBuffer.asFloatBuffer() 
      		float ByteBuffer.getFloat(int) 
      		CharBuffer ByteBuffer.asCharBuffer() 
      		boolean ByteBuffer.isDirect() 
      		boolean ByteBuffer.equals(byte,byte) 
      		LongBuffer ByteBuffer.asLongBuffer() 
      		char ByteBuffer.getChar() 
      		int ByteBuffer.compareTo(Object) 
      		ByteBuffer ByteBuffer.put(int,byte) 
      		DoubleBuffer ByteBuffer.asDoubleBuffer() 
      		ShortBuffer ByteBuffer.asShortBuffer() 
      		ByteBuffer ByteBuffer.put(byte[],int,int) 
      		ByteBuffer ByteBuffer.putLong(long) 
      		byte ByteBuffer._get(int) 
      		ByteBuffer ByteBuffer.duplicate() 
      		ByteBuffer ByteBuffer.putDouble(double) 
      		ByteBuffer ByteBuffer.putShort(short) 
      		int ByteBuffer.compareTo(ByteBuffer) 
      		ByteBuffer ByteBuffer.get(byte[],int,int) 
      		ByteBuffer ByteBuffer.putFloat(float) 
      		short ByteBuffer.getShort(int) 
      		char ByteBuffer.getChar(int) 
      		ByteBuffer ByteBuffer.put(byte[]) 
      		ByteBuffer ByteBuffer.putInt(int) 
      		boolean ByteBuffer.hasArray() 
      		ByteBuffer ByteBuffer.wrap(byte[],int,int) 
      		ByteBuffer ByteBuffer.put(byte) 
      		long ByteBuffer.getLong() 
      		int ByteBuffer.getInt(int) 
      		ByteBuffer ByteBuffer.order(ByteOrder) 
      		ByteBuffer ByteBuffer.slice() 
      		double ByteBuffer.getDouble() 
      		double ByteBuffer.getDouble(int) 
      		short ByteBuffer.getShort() 
      		ByteBuffer ByteBuffer.get(byte[]) 
      		int ByteBuffer.compare(byte,byte) 
      		float ByteBuffer.getFloat() 
      		ByteBuffer ByteBuffer.putChar(char) 
      		ByteBuffer ByteBuffer.put(ByteBuffer) 
      		String ByteBuffer.toString() 
      		Object ByteBuffer.array() 
      		int ByteBuffer.getInt() 
      		ByteBuffer.<init>(int,int,int,int,byte[],int) 
      		byte ByteBuffer.get(int) 
      		ByteBuffer ByteBuffer.putLong(int,long) 
      		void ByteBuffer._put(int,byte) 
      		ByteBuffer ByteBuffer.asReadOnlyBuffer() 
      		ByteBuffer ByteBuffer.putDouble(int,double) 
      		ByteBuffer ByteBuffer.putShort(int,short) 
      		ByteBuffer.<init>(int,int,int,int) 
      		ByteBuffer ByteBuffer.allocateDirect(int) 
      		ByteBuffer ByteBuffer.putFloat(int,float) 
      		long ByteBuffer.getLong(int) 
      		ByteBuffer ByteBuffer.putChar(int,char) 
      		ByteBuffer ByteBuffer.wrap(byte[]) 
      		ByteBuffer ByteBuffer.compact() 
      		ByteBuffer ByteBuffer.putInt(int,int) 
      		byte[] ByteBuffer.array()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.stream.DoubleStream$Builder
TYPE: class java.util.stream.DoubleStream$Builder 
      	fields: {
      	}
      	supers: {
      		class java.util.function.DoubleConsumer
      	}
      	methods: {
      		void DoubleStream$Builder.accept(double) 
      		DoubleStream DoubleStream$Builder.build() 
      		DoubleStream$Builder DoubleStream$Builder.add(double)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.http.Cookie
TYPE: class javax.servlet.http.Cookie 
      	fields: {
      		java.lang.String* name <> 
      		java.lang.String* path <> 
      		java.lang.String* value <> 
      		int version <> 
      		int maxAge <> 
      		_Bool secure <> 
      		java.lang.String* comment <> 
      		_Bool isHttpOnly <> 
      		java.lang.String* domain <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.lang.Cloneable 
      		class java.io.Serializable
      	}
      	methods: {
      		void Cookie.<clinit>() 
      		boolean Cookie.isHttpOnly() 
      		int Cookie.getMaxAge() 
      		void Cookie.setComment(String) 
      		Object Cookie.clone() 
      		boolean Cookie.getSecure() 
      		void Cookie.setValue(String) 
      		String Cookie.getPath() 
      		String Cookie.getName() 
      		Cookie.<init>(String,String) 
      		void Cookie.setDomain(String) 
      		String Cookie.getValue() 
      		void Cookie.setMaxAge(int) 
      		void Cookie.setVersion(int) 
      		boolean Cookie.isToken(String) 
      		void Cookie.setPath(String) 
      		String Cookie.getComment() 
      		int Cookie.getVersion() 
      		void Cookie.setSecure(boolean) 
      		String Cookie.getDomain() 
      		void Cookie.setHttpOnly(boolean)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Date
TYPE: class java.util.Date 
      	fields: {
      		sun.util.calendar.BaseCalendar$Date* cdate <> 
      		long fastTime <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable 
      		class java.lang.Cloneable 
      		class java.lang.Comparable
      	}
      	methods: {
      		void Date.<clinit>() 
      		int Date.getHours() 
      		int Date.hashCode() 
      		BaseCalendar$Date Date.normalize(BaseCalendar$Date) 
      		int Date.getDay() 
      		int Date.compareTo(Date) 
      		StringBuilder Date.convertToAbbr(StringBuilder,String) 
      		boolean Date.equals(Object) 
      		int Date.getTimezoneOffset() 
      		BaseCalendar Date.getJulianCalendar() 
      		BaseCalendar$Date Date.normalize() 
      		boolean Date.before(Date) 
      		int Date.compareTo(Object) 
      		long Date.UTC(int,int,int,int,int,int) 
      		Object Date.clone() 
      		BaseCalendar Date.getCalendarSystem(BaseCalendar$Date) 
      		void Date.writeObject(ObjectOutputStream) 
      		int Date.getSeconds() 
      		void Date.setMinutes(int) 
      		Date.<init>(int,int,int) 
      		void Date.setTime(long) 
      		Date.<init>() 
      		String Date.toLocaleString() 
      		Instant Date.toInstant() 
      		BaseCalendar Date.getCalendarSystem(long) 
      		void Date.setMonth(int) 
      		long Date.getTime() 
      		long Date.getTimeImpl() 
      		int Date.getMonth() 
      		void Date.readObject(ObjectInputStream) 
      		int Date.getMinutes() 
      		void Date.setHours(int) 
      		Date Date.from(Instant) 
      		BaseCalendar Date.getCalendarSystem(int) 
      		Date.<init>(int,int,int,int,int,int) 
      		BaseCalendar$Date Date.getCalendarDate() 
      		boolean Date.after(Date) 
      		void Date.setYear(int) 
      		String Date.toString() 
      		int Date.getYear() 
      		void Date.setSeconds(int) 
      		Date.<init>(int,int,int,int,int) 
      		Date.<init>(String) 
      		String Date.toGMTString() 
      		void Date.setDate(int) 
      		Date.<init>(long) 
      		long Date.getMillisOf(Date) 
      		long Date.parse(String) 
      		int Date.getDate()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.StreamLoader
TYPE: class javax.mail.StreamLoader 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void StreamLoader.load(InputStream)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.descriptor.JspConfigDescriptor
TYPE: class javax.servlet.descriptor.JspConfigDescriptor 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Collection JspConfigDescriptor.getJspPropertyGroups() 
      		Collection JspConfigDescriptor.getTaglibs()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Map$Entry
TYPE: class java.util.Map$Entry 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		int Map$Entry.hashCode() 
      		Comparator Map$Entry.comparingByValue(Comparator) 
      		boolean Map$Entry.equals(Object) 
      		int Map$Entry.lambda$comparingByValue$827a17d5$1(Comparator,Map$Entry,Map$Entry) 
      		Object Map$Entry.getKey() 
      		int Map$Entry.lambda$comparingByValue$1065357e$1(Map$Entry,Map$Entry) 
      		Object Map$Entry.setValue(Object) 
      		Comparator Map$Entry.comparingByValue() 
      		Object Map$Entry.$deserializeLambda$(SerializedLambda) 
      		int Map$Entry.lambda$comparingByKey$bbdbfea9$1(Map$Entry,Map$Entry) 
      		Comparator Map$Entry.comparingByKey() 
      		Object Map$Entry.getValue() 
      		int Map$Entry.lambda$comparingByKey$6d558cbf$1(Comparator,Map$Entry,Map$Entry) 
      		Comparator Map$Entry.comparingByKey(Comparator)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Iterable
TYPE: class java.lang.Iterable 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void Iterable.forEach(Consumer) 
      		Iterator Iterable.iterator() 
      		Spliterator Iterable.spliterator()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.text.CharacterIterator
TYPE: class java.text.CharacterIterator 
      	fields: {
      	}
      	supers: {
      		class java.lang.Cloneable
      	}
      	methods: {
      		int CharacterIterator.getIndex() 
      		char CharacterIterator.setIndex(int) 
      		Object CharacterIterator.clone() 
      		char CharacterIterator.next() 
      		char CharacterIterator.current() 
      		int CharacterIterator.getEndIndex() 
      		char CharacterIterator.last() 
      		int CharacterIterator.getBeginIndex() 
      		char CharacterIterator.previous() 
      		char CharacterIterator.first()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.misc.ObjectInputFilter
TYPE: class sun.misc.ObjectInputFilter 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		ObjectInputFilter$Status ObjectInputFilter.checkInput(ObjectInputFilter$FilterInfo)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class javax.servlet.FilterRegistration
TYPE: class javax.servlet.FilterRegistration 
      	fields: {
      	}
      	supers: {
      		class javax.servlet.Registration
      	}
      	methods: {
      		Collection FilterRegistration.getServletNameMappings() 
      		Collection FilterRegistration.getUrlPatternMappings() 
      		void FilterRegistration.addMappingForUrlPatterns(EnumSet,boolean,String[]) 
      		void FilterRegistration.addMappingForServletNames(EnumSet,boolean,String[])
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.CallableStatement
TYPE: class java.sql.CallableStatement 
      	fields: {
      	}
      	supers: {
      		class java.sql.PreparedStatement
      	}
      	methods: {
      		Reader CallableStatement.getCharacterStream(int) 
      		void CallableStatement.setNull(String,int) 
      		void CallableStatement.setBlob(String,Blob) 
      		Timestamp CallableStatement.getTimestamp(int,Calendar) 
      		void CallableStatement.setObject(String,Object,int,int) 
      		void CallableStatement.registerOutParameter(int,SQLType,String) 
      		boolean CallableStatement.getBoolean(String) 
      		Ref CallableStatement.getRef(String) 
      		void CallableStatement.setBigDecimal(String,BigDecimal) 
      		void CallableStatement.setNCharacterStream(String,Reader) 
      		float CallableStatement.getFloat(int) 
      		void CallableStatement.setRowId(String,RowId) 
      		Time CallableStatement.getTime(String) 
      		Blob CallableStatement.getBlob(int) 
      		void CallableStatement.setInt(String,int) 
      		NClob CallableStatement.getNClob(int) 
      		void CallableStatement.setCharacterStream(String,Reader,long) 
      		boolean CallableStatement.getBoolean(int) 
      		void CallableStatement.setDate(String,Date,Calendar) 
      		float CallableStatement.getFloat(String) 
      		Date CallableStatement.getDate(int,Calendar) 
      		void CallableStatement.setTime(String,Time) 
      		Reader CallableStatement.getNCharacterStream(int) 
      		void CallableStatement.setObject(String,Object,SQLType,int) 
      		Time CallableStatement.getTime(int) 
      		RowId CallableStatement.getRowId(int) 
      		void CallableStatement.setClob(String,Reader,long) 
      		void CallableStatement.registerOutParameter(String,int) 
      		BigDecimal CallableStatement.getBigDecimal(int) 
      		Object CallableStatement.getObject(int,Map) 
      		void CallableStatement.setByte(String,byte) 
      		byte[] CallableStatement.getBytes(int) 
      		void CallableStatement.setAsciiStream(String,InputStream,long) 
      		URL CallableStatement.getURL(int) 
      		void CallableStatement.setObject(String,Object) 
      		void CallableStatement.registerOutParameter(String,SQLType,int) 
      		short CallableStatement.getShort(String) 
      		Object CallableStatement.getObject(int,Class) 
      		Clob CallableStatement.getClob(String) 
      		void CallableStatement.setBytes(String,byte[]) 
      		String CallableStatement.getNString(int) 
      		void CallableStatement.setBlob(String,InputStream) 
      		BigDecimal CallableStatement.getBigDecimal(int,int) 
      		void CallableStatement.setNCharacterStream(String,Reader,long) 
      		void CallableStatement.registerOutParameter(int,int,int) 
      		Array CallableStatement.getArray(int) 
      		void CallableStatement.setFloat(String,float) 
      		Timestamp CallableStatement.getTimestamp(int) 
      		SQLXML CallableStatement.getSQLXML(int) 
      		void CallableStatement.setBinaryStream(String,InputStream) 
      		short CallableStatement.getShort(int) 
      		void CallableStatement.setTimestamp(String,Timestamp,Calendar) 
      		Time CallableStatement.getTime(int,Calendar) 
      		void CallableStatement.setAsciiStream(String,InputStream,int) 
      		void CallableStatement.registerOutParameter(int,SQLType) 
      		void CallableStatement.setNClob(String,Reader,long) 
      		void CallableStatement.registerOutParameter(String,int,String) 
      		Object CallableStatement.getObject(String) 
      		String CallableStatement.getString(String) 
      		Reader CallableStatement.getCharacterStream(String) 
      		void CallableStatement.setBoolean(String,boolean) 
      		int CallableStatement.getInt(int) 
      		void CallableStatement.setClob(String,Clob) 
      		Timestamp CallableStatement.getTimestamp(String,Calendar) 
      		void CallableStatement.setObject(String,Object,int) 
      		void CallableStatement.registerOutParameter(String,SQLType) 
      		byte CallableStatement.getByte(String) 
      		Blob CallableStatement.getBlob(String) 
      		void CallableStatement.setString(String,String) 
      		void CallableStatement.setClob(String,Reader) 
      		double CallableStatement.getDouble(int) 
      		byte[] CallableStatement.getBytes(String) 
      		void CallableStatement.setNString(String,String) 
      		void CallableStatement.registerOutParameter(int,int) 
      		Clob CallableStatement.getClob(int) 
      		void CallableStatement.setLong(String,long) 
      		NClob CallableStatement.getNClob(String) 
      		void CallableStatement.setAsciiStream(String,InputStream) 
      		byte CallableStatement.getByte(int) 
      		void CallableStatement.setTime(String,Time,Calendar) 
      		double CallableStatement.getDouble(String) 
      		Date CallableStatement.getDate(String,Calendar) 
      		void CallableStatement.setTimestamp(String,Timestamp) 
      		Reader CallableStatement.getNCharacterStream(String) 
      		void CallableStatement.setObject(String,Object,SQLType) 
      		RowId CallableStatement.getRowId(String) 
      		void CallableStatement.setBlob(String,InputStream,long) 
      		int CallableStatement.getInt(String) 
      		void CallableStatement.registerOutParameter(String,int,int) 
      		Object CallableStatement.getObject(int) 
      		BigDecimal CallableStatement.getBigDecimal(String) 
      		Ref CallableStatement.getRef(int) 
      		void CallableStatement.setShort(String,short) 
      		String CallableStatement.getString(int) 
      		void CallableStatement.setBinaryStream(String,InputStream,long) 
      		boolean CallableStatement.wasNull() 
      		URL CallableStatement.getURL(String) 
      		void CallableStatement.setCharacterStream(String,Reader,int) 
      		void CallableStatement.registerOutParameter(String,SQLType,String) 
      		long CallableStatement.getLong(String) 
      		Object CallableStatement.getObject(String,Class) 
      		Array CallableStatement.getArray(String) 
      		void CallableStatement.setDate(String,Date) 
      		String CallableStatement.getNString(String) 
      		void CallableStatement.setNClob(String,Reader) 
      		Date CallableStatement.getDate(int) 
      		void CallableStatement.setNClob(String,NClob) 
      		Timestamp CallableStatement.getTimestamp(String) 
      		void CallableStatement.registerOutParameter(int,int,String) 
      		Object CallableStatement.getObject(String,Map) 
      		void CallableStatement.setDouble(String,double) 
      		SQLXML CallableStatement.getSQLXML(String) 
      		void CallableStatement.setCharacterStream(String,Reader) 
      		long CallableStatement.getLong(int) 
      		void CallableStatement.setNull(String,int,String) 
      		Date CallableStatement.getDate(String) 
      		Time CallableStatement.getTime(String,Calendar) 
      		void CallableStatement.setBinaryStream(String,InputStream,int) 
      		void CallableStatement.registerOutParameter(int,SQLType,int) 
      		void CallableStatement.setSQLXML(String,SQLXML) 
      		void CallableStatement.setURL(String,URL)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.AddOra
TYPE: class com.stn.servlets.AddOra 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void AddOra.doPost(HttpServletRequest,HttpServletResponse) 
      		AddOra.<init>() 
      		void AddOra.setTempFields(HttpServletRequest,Integer,String,String,String,Integer,String,String,String,Integer,String) 
      		void AddOra.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/AddOra")>
      	}NAME: class java.sql.Savepoint
TYPE: class java.sql.Savepoint 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		int Savepoint.getSavepointId() 
      		String Savepoint.getSavepointName()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.FilterOutputStream
TYPE: class java.io.FilterOutputStream 
      	fields: {
      		java.io.OutputStream* out <>
      	}
      	supers: {
      		class java.io.OutputStream
      	}
      	methods: {
      		void FilterOutputStream.write(byte[]) 
      		void FilterOutputStream.write(int) 
      		void FilterOutputStream.close() 
      		void FilterOutputStream.flush() 
      		void FilterOutputStream.write(byte[],int,int) 
      		FilterOutputStream.<init>(OutputStream)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.time.chrono.ChronoLocalDate
TYPE: class java.time.chrono.ChronoLocalDate 
      	fields: {
      	}
      	supers: {
      		class java.time.temporal.Temporal 
      		class java.time.temporal.TemporalAdjuster 
      		class java.lang.Comparable
      	}
      	methods: {
      		int ChronoLocalDate.hashCode() 
      		ChronoLocalDate ChronoLocalDate.with(TemporalField,long) 
      		boolean ChronoLocalDate.equals(Object) 
      		ChronoLocalDate ChronoLocalDate.from(TemporalAccessor) 
      		Temporal ChronoLocalDate.plus(TemporalAmount) 
      		int ChronoLocalDate.compareTo(Object) 
      		Comparator ChronoLocalDate.timeLineOrder() 
      		Era ChronoLocalDate.getEra() 
      		ChronoLocalDate ChronoLocalDate.minus(long,TemporalUnit) 
      		Object ChronoLocalDate.query(TemporalQuery) 
      		Temporal ChronoLocalDate.minus(TemporalAmount) 
      		int ChronoLocalDate.compareTo(ChronoLocalDate) 
      		ChronoLocalDateTime ChronoLocalDate.atTime(LocalTime) 
      		boolean ChronoLocalDate.isEqual(ChronoLocalDate) 
      		boolean ChronoLocalDate.isLeapYear() 
      		boolean ChronoLocalDate.isAfter(ChronoLocalDate) 
      		Temporal ChronoLocalDate.with(TemporalAdjuster) 
      		ChronoLocalDate ChronoLocalDate.plus(long,TemporalUnit) 
      		Temporal ChronoLocalDate.minus(long,TemporalUnit) 
      		ChronoLocalDate ChronoLocalDate.with(TemporalAdjuster) 
      		int ChronoLocalDate.lengthOfYear() 
      		Chronology ChronoLocalDate.getChronology() 
      		boolean ChronoLocalDate.isBefore(ChronoLocalDate) 
      		boolean ChronoLocalDate.isSupported(TemporalUnit) 
      		long ChronoLocalDate.until(Temporal,TemporalUnit) 
      		Temporal ChronoLocalDate.with(TemporalField,long) 
      		String ChronoLocalDate.toString() 
      		String ChronoLocalDate.format(DateTimeFormatter) 
      		ChronoLocalDate ChronoLocalDate.minus(TemporalAmount) 
      		Temporal ChronoLocalDate.plus(long,TemporalUnit) 
      		ChronoPeriod ChronoLocalDate.until(ChronoLocalDate) 
      		boolean ChronoLocalDate.isSupported(TemporalField) 
      		int ChronoLocalDate.lengthOfMonth() 
      		ChronoLocalDate ChronoLocalDate.plus(TemporalAmount) 
      		Temporal ChronoLocalDate.adjustInto(Temporal) 
      		long ChronoLocalDate.toEpochDay()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Readable
TYPE: class java.lang.Readable 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		int Readable.read(CharBuffer)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.GenericServlet
TYPE: class javax.servlet.GenericServlet 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class java.lang.Object 
      		class javax.servlet.Servlet 
      		class javax.servlet.ServletConfig 
      		class java.io.Serializable
      	}
      	methods: {
      		void GenericServlet.<clinit>() 
      		ServletConfig GenericServlet.getServletConfig() 
      		void GenericServlet.init(ServletConfig) 
      		String GenericServlet.getServletName() 
      		void GenericServlet.destroy() 
      		Enumeration GenericServlet.getInitParameterNames() 
      		GenericServlet.<init>() 
      		void GenericServlet.log(String,Throwable) 
      		String GenericServlet.getInitParameter(String) 
      		void GenericServlet.log(String) 
      		ServletContext GenericServlet.getServletContext() 
      		String GenericServlet.getServletInfo() 
      		void GenericServlet.init() 
      		void GenericServlet.service(ServletRequest,ServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.net.URI
TYPE: class java.net.URI 
      	fields: {
      		java.lang.String* path <> 
      		java.lang.String* decodedQuery <_volatile> 
      		int port <> 
      		java.lang.String* authority <> 
      		java.lang.String* string <_volatile> 
      		java.lang.String* query <> 
      		java.lang.String* host <> 
      		java.lang.String* fragment <> 
      		java.lang.String* decodedSchemeSpecificPart <_volatile> 
      		java.lang.String* userInfo <> 
      		java.lang.String* decodedAuthority <_volatile> 
      		java.lang.String* scheme <> 
      		java.lang.String* decodedFragment <_volatile> 
      		java.lang.String* decodedUserInfo <_volatile> 
      		java.lang.String* schemeSpecificPart <_volatile> 
      		int hash <_volatile> 
      		java.lang.String* decodedPath <_volatile>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.lang.Comparable 
      		class java.io.Serializable
      	}
      	methods: {
      		void URI.<clinit>() 
      		long URI.access$800() 
      		String URI.decode(String) 
      		void URI.checkPath(String,String,String) 
      		int URI.hashCode() 
      		int URI.decode(char) 
      		String URI.access$2402(URI,String) 
      		URL URI.toURL() 
      		int URI.toLower(char) 
      		URI URI.relativize(URI) 
      		long URI.access$1600() 
      		void URI.defineSchemeSpecificPart() 
      		boolean URI.equals(Object) 
      		URI.<init>(String,String,String,String) 
      		long URI.lowMask(char,char) 
      		String URI.getQuery() 
      		long URI.access$3200() 
      		String URI.normalize(String) 
      		int URI.needsNormalization(String) 
      		String URI.access$002(URI,String) 
      		long URI.access$1200() 
      		URI URI.resolve(URI,URI) 
      		long URI.access$2800() 
      		void URI.appendAuthority(StringBuffer,String,String,String,int) 
      		int URI.compareTo(Object) 
      		String URI.getRawPath() 
      		long URI.access$2000() 
      		int URI.hashIgnoringCase(int,String) 
      		URI.<init>(String,String,String,String,String) 
      		String URI.getFragment() 
      		int URI.join(char[],int[]) 
      		boolean URI.match(char,long,long) 
      		long URI.access$400() 
      		String URI.access$1002(URI,String) 
      		void URI.writeObject(ObjectOutputStream) 
      		void URI.defineString() 
      		byte URI.decode(char,char) 
      		long URI.access$2600() 
      		int URI.toUpper(char) 
      		String URI.getRawAuthority() 
      		long URI.access$1800() 
      		boolean URI.equalIgnoringCase(String,String) 
      		boolean URI.isAbsolute() 
      		long URI.lowMask(String) 
      		long URI.access$3400() 
      		String URI.getPath() 
      		void URI.removeDots(char[],int[]) 
      		long URI.access$200() 
      		URI.<init>() 
      		String URI.access$1402(URI,String) 
      		URI URI.resolve(URI) 
      		long URI.access$3000() 
      		void URI.appendFragment(StringBuffer,String) 
      		String URI.getRawFragment() 
      		String URI.getUserInfo() 
      		String URI.access$2202(URI,String) 
      		int URI.compareIgnoringCase(String,String) 
      		URI URI.normalize() 
      		void URI.appendEncoded(StringBuffer,char) 
      		String URI.encode(String) 
      		long URI.access$600() 
      		long URI.access$900() 
      		void URI.readObject(ObjectInputStream) 
      		URI.<init>(String,String,String,int,String,String,String) 
      		String URI.getScheme() 
      		int URI.access$2502(URI,int) 
      		int URI.normalizedHash(int,String) 
      		String URI.getSchemeSpecificPart() 
      		long URI.access$1700() 
      		String URI.getRawSchemeSpecificPart() 
      		long URI.highMask(char,char) 
      		long URI.access$3300() 
      		void URI.split(char[],int[]) 
      		long URI.access$100() 
      		long URI.access$1300() 
      		URI URI.create(String) 
      		long URI.access$2900() 
      		void URI.appendSchemeSpecificPart(StringBuffer,String,String,String,String,int,String,String) 
      		String URI.getRawQuery() 
      		long URI.access$2100() 
      		String URI.toString() 
      		int URI.hash(int,String) 
      		int URI.getPort() 
      		URI URI.parseServerAuthority() 
      		void URI.appendEscape(StringBuffer,byte) 
      		long URI.access$500() 
      		String URI.access$1102(URI,String) 
      		URI URI.normalize(URI) 
      		long URI.access$2700() 
      		String URI.quote(String,long,long) 
      		String URI.getRawUserInfo() 
      		long URI.access$1900() 
      		boolean URI.equal(String,String) 
      		long URI.highMask(String) 
      		boolean URI.isOpaque() 
      		void URI.maybeAddLeadingDot(char[],int[]) 
      		boolean URI.access$300(char,long,long) 
      		URI.<init>(String) 
      		String URI.getAuthority() 
      		String URI.access$1502(URI,String) 
      		URI URI.relativize(URI,URI) 
      		int URI.compareTo(URI) 
      		long URI.access$3100() 
      		String URI.getHost() 
      		String URI.resolvePath(String,String,boolean) 
      		String URI.toASCIIString() 
      		String URI.access$2302(URI,String) 
      		URI.<init>(String,String,String) 
      		int URI.compare(String,String) 
      		URI URI.resolve(String) 
      		String URI.toString(String,String,String,String,String,int,String,String,String) 
      		String URI.access$702(URI,String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.http.PushBuilder
TYPE: class javax.servlet.http.PushBuilder 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		String PushBuilder.getMethod() 
      		void PushBuilder.push() 
      		String PushBuilder.getHeader(String) 
      		PushBuilder PushBuilder.setHeader(String,String) 
      		PushBuilder PushBuilder.queryString(String) 
      		Set PushBuilder.getHeaderNames() 
      		String PushBuilder.getQueryString() 
      		String PushBuilder.getPath() 
      		PushBuilder PushBuilder.removeHeader(String) 
      		PushBuilder PushBuilder.method(String) 
      		String PushBuilder.getSessionId() 
      		PushBuilder PushBuilder.addHeader(String,String) 
      		PushBuilder PushBuilder.sessionId(String) 
      		PushBuilder PushBuilder.path(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.text.CalendarBuilder
TYPE: class java.text.CalendarBuilder 
      	fields: {
      		int nextStamp <> 
      		int maxFieldIndex <> 
      		int[_*_](*) field <_final>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		CalendarBuilder CalendarBuilder.addYear(int) 
      		int CalendarBuilder.toCalendarDayOfWeek(int) 
      		CalendarBuilder.<init>() 
      		CalendarBuilder CalendarBuilder.clear(int) 
      		int CalendarBuilder.toISODayOfWeek(int) 
      		boolean CalendarBuilder.isValidDayOfWeek(int) 
      		CalendarBuilder CalendarBuilder.set(int,int) 
      		String CalendarBuilder.toString() 
      		boolean CalendarBuilder.isSet(int) 
      		Calendar CalendarBuilder.establish(Calendar)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.SQLException
TYPE: class java.sql.SQLException 
      	fields: {
      		java.lang.String* SQLState <> 
      		java.sql.SQLException* next <_volatile> 
      		int vendorCode <> 
      		java.lang.String* detailMessage <> 
      		java.lang.Object* backtrace <> 
      		java.lang.StackTraceElement*[_*_](*) stackTrace <> 
      		java.lang.Throwable* cause <> 
      		java.util.List* suppressedExceptions <>
      	}
      	supers: {
      		class java.lang.Exception 
      		class java.lang.Iterable
      	}
      	methods: {
      		void SQLException.<clinit>() 
      		SQLException.<init>(String,String,Throwable) 
      		SQLException SQLException.getNextException() 
      		Iterator SQLException.iterator() 
      		String SQLException.getSQLState() 
      		SQLException.<init>(String,Throwable) 
      		SQLException.<init>() 
      		SQLException.<init>(String,String) 
      		SQLException.<init>(String,String,int,Throwable) 
      		void SQLException.setNextException(SQLException) 
      		int SQLException.getErrorCode() 
      		SQLException.<init>(Throwable) 
      		SQLException.<init>(String) 
      		SQLException.<init>(String,String,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.logging.Logger
TYPE: class java.util.logging.Logger 
      	fields: {
      		java.lang.String* name <> 
      		java.lang.ref.WeakReference* callersClassLoaderRef <> 
      		java.util.Locale* catalogLocale <> 
      		java.util.logging.LogManager* manager <_volatile> 
      		java.util.logging.Level* levelObject <_volatile> 
      		java.util.logging.Filter* filter <_volatile> 
      		java.util.logging.Logger$LoggerBundle* loggerBundle <_volatile> 
      		java.util.ArrayList* kids <> 
      		java.util.concurrent.CopyOnWriteArrayList* handlers <_final> 
      		_Bool anonymous <> 
      		java.lang.String* catalogName <> 
      		_Bool isSystemLogger <_final> 
      		java.util.logging.Logger* parent <_volatile> 
      		_Bool useParentHandlers <_volatile> 
      		int levelValue <_volatile> 
      		java.util.ResourceBundle* catalog <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Logger.<clinit>() 
      		void Logger.info(Supplier) 
      		void Logger.logrb(Level,String,String,ResourceBundle,String,Object[]) 
      		void Logger.doLog(LogRecord,ResourceBundle) 
      		void Logger.log(Level,String,Object[]) 
      		void Logger.removeHandler(Handler) 
      		void Logger.throwing(String,String,Throwable) 
      		Logger Logger.getLogger(String) 
      		Logger Logger.getPlatformLogger(String) 
      		void Logger.finest(Supplier) 
      		Logger$LoggerBundle Logger.getEffectiveLoggerBundle() 
      		void Logger.entering(String,String,Object) 
      		void Logger.log(Level,String,Throwable) 
      		void Logger.log(Level,String) 
      		void Logger.logp(Level,String,String,Throwable,Supplier) 
      		Logger$LoggerBundle Logger.access$000() 
      		void Logger.finer(String) 
      		Level Logger.getLevel() 
      		void Logger.setLogManager(LogManager) 
      		void Logger.fine(Supplier) 
      		Logger Logger.getParent() 
      		void Logger.logrb(Level,String,String,ResourceBundle,String,Throwable) 
      		void Logger.setupResourceInfo(String,Class) 
      		void Logger.logp(Level,String,String,String,Object) 
      		void Logger.logp(Level,String,String,Supplier) 
      		void Logger.setParent(Logger) 
      		void Logger.warning(String) 
      		String Logger.getResourceBundleName() 
      		void Logger.setCallersClassLoaderRef(Class) 
      		void Logger.setFilter(Filter) 
      		void Logger.fine(String) 
      		boolean Logger.isLevelInitialized() 
      		void Logger.setResourceBundle(ResourceBundle) 
      		String Logger.getName() 
      		Logger.<init>(String,String) 
      		void Logger.exiting(String,String) 
      		Logger Logger.getAnonymousLogger(String) 
      		void Logger.updateEffectiveLevel() 
      		void Logger.logrb(Level,String,String,String,String,Object) 
      		void Logger.severe(Supplier) 
      		Handler[] Logger.accessCheckedHandlers() 
      		Logger Logger.getGlobal() 
      		void Logger.config(Supplier) 
      		boolean Logger.getUseParentHandlers() 
      		void Logger.logrb(Level,String,String,String,String,Throwable) 
      		Logger.<init>(String,String,Class,LogManager,boolean) 
      		void Logger.logp(Level,String,String,String) 
      		void Logger.log(Level,Throwable,Supplier) 
      		void Logger.setUseParentHandlers(boolean) 
      		void Logger.doLog(LogRecord) 
      		void Logger.severe(String) 
      		void Logger.config(String) 
      		void Logger.doSetParent(Logger) 
      		ClassLoader Logger.getCallersClassLoader() 
      		Logger Logger.getAnonymousLogger() 
      		boolean Logger.isLoggable(Level) 
      		void Logger.setLevel(Level) 
      		void Logger.entering(String,String,Object[]) 
      		Logger Logger.demandLogger(String,String,Class) 
      		void Logger.log(Level,Supplier) 
      		void Logger.logrb(Level,String,String,String,String) 
      		Logger$LoggerBundle Logger.access$100() 
      		void Logger.finest(String) 
      		void Logger.log(Level,String,Object) 
      		Logger Logger.getLogger(String,String) 
      		void Logger.finer(Supplier) 
      		void Logger.entering(String,String) 
      		void Logger.checkPermission() 
      		void Logger.logp(Level,String,String,String,Object[]) 
      		void Logger.logp(Level,String,String,String,Throwable) 
      		void Logger.removeChildLogger(LogManager$LoggerWeakRef) 
      		void Logger.info(String) 
      		ResourceBundle Logger.findResourceBundle(String,boolean) 
      		Logger.<init>(String) 
      		Filter Logger.getFilter() 
      		void Logger.addHandler(Handler) 
      		void Logger.log(LogRecord) 
      		void Logger.exiting(String,String,Object) 
      		ResourceBundle Logger.findSystemResourceBundle(Locale) 
      		void Logger.logrb(Level,String,String,String,String,Object[]) 
      		void Logger.doLog(LogRecord,String) 
      		void Logger.warning(Supplier) 
      		Handler[] Logger.getHandlers() 
      		ResourceBundle Logger.getResourceBundle()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.URLName
TYPE: class javax.mail.URLName 
      	fields: {
      		java.lang.String* password <> 
      		java.lang.String* fullURL <> 
      		int port <> 
      		_Bool hostAddressKnown <> 
      		java.lang.String* host <> 
      		java.lang.String* username <> 
      		java.lang.String* ref <> 
      		java.lang.String* protocol <> 
      		java.net.InetAddress* hostAddress <> 
      		int hashCode <> 
      		java.lang.String* file <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void URLName.<clinit>() 
      		String URLName.decode(String) 
      		int URLName.hashCode() 
      		boolean URLName.equals(Object) 
      		String URLName.getRef() 
      		String URLName.getProtocol() 
      		String URLName.getFile() 
      		String URLName.encode(String) 
      		InetAddress URLName.getHostAddress() 
      		URLName.<init>(URL) 
      		URLName.<init>(String,String,int,String,String,String) 
      		String URLName.getPassword() 
      		int URLName.indexOfAny(String,String,int) 
      		String URLName.toString() 
      		int URLName.getPort() 
      		String URLName._encode(String) 
      		URL URLName.getURL() 
      		String URLName.getUsername() 
      		URLName.<init>(String) 
      		String URLName.getHost() 
      		int URLName.indexOfAny(String,String) 
      		void URLName.parseString(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.MultipartDataSource
TYPE: class javax.mail.MultipartDataSource 
      	fields: {
      	}
      	supers: {
      		class javax.activation.DataSource
      	}
      	methods: {
      		BodyPart MultipartDataSource.getBodyPart(int) 
      		int MultipartDataSource.getCount()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.http.HttpServletRequest
TYPE: class javax.servlet.http.HttpServletRequest 
      	fields: {
      	}
      	supers: {
      		class javax.servlet.ServletRequest
      	}
      	methods: {
      		String HttpServletRequest.getServletPath() 
      		String HttpServletRequest.getMethod() 
      		void HttpServletRequest.login(String,String) 
      		String HttpServletRequest.getPathTranslated() 
      		String HttpServletRequest.getHeader(String) 
      		boolean HttpServletRequest.isRequestedSessionIdFromCookie() 
      		Enumeration HttpServletRequest.getHeaders(String) 
      		String HttpServletRequest.getRequestURI() 
      		HttpUpgradeHandler HttpServletRequest.upgrade(Class) 
      		Enumeration HttpServletRequest.getHeaderNames() 
      		boolean HttpServletRequest.isUserInRole(String) 
      		String HttpServletRequest.changeSessionId() 
      		long HttpServletRequest.getDateHeader(String) 
      		Collection HttpServletRequest.getParts() 
      		String HttpServletRequest.getQueryString() 
      		boolean HttpServletRequest.isRequestedSessionIdFromUrl() 
      		HttpServletMapping HttpServletRequest.getHttpServletMapping() 
      		boolean HttpServletRequest.isTrailerFieldsReady() 
      		String HttpServletRequest.getRequestedSessionId() 
      		HttpSession HttpServletRequest.getSession(boolean) 
      		void HttpServletRequest.logout() 
      		PushBuilder HttpServletRequest.newPushBuilder() 
      		boolean HttpServletRequest.isRequestedSessionIdFromURL() 
      		int HttpServletRequest.getIntHeader(String) 
      		Map HttpServletRequest.getTrailerFields() 
      		Principal HttpServletRequest.getUserPrincipal() 
      		String HttpServletRequest.getContextPath() 
      		boolean HttpServletRequest.isRequestedSessionIdValid() 
      		String HttpServletRequest.getAuthType() 
      		HttpSession HttpServletRequest.getSession() 
      		Part HttpServletRequest.getPart(String) 
      		String HttpServletRequest.getRemoteUser() 
      		Cookie[] HttpServletRequest.getCookies() 
      		boolean HttpServletRequest.authenticate(HttpServletResponse) 
      		String HttpServletRequest.getPathInfo() 
      		StringBuffer HttpServletRequest.getRequestURL()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.time.temporal.Temporal
TYPE: class java.time.temporal.Temporal 
      	fields: {
      	}
      	supers: {
      		class java.time.temporal.TemporalAccessor
      	}
      	methods: {
      		Temporal Temporal.plus(TemporalAmount) 
      		Temporal Temporal.minus(TemporalAmount) 
      		Temporal Temporal.with(TemporalAdjuster) 
      		Temporal Temporal.minus(long,TemporalUnit) 
      		boolean Temporal.isSupported(TemporalUnit) 
      		long Temporal.until(Temporal,TemporalUnit) 
      		Temporal Temporal.with(TemporalField,long) 
      		Temporal Temporal.plus(long,TemporalUnit)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Locale
TYPE: class java.util.Locale 
      	fields: {
      		int hashCodeValue <_volatile> 
      		sun.util.locale.LocaleExtensions* localeExtensions <> 
      		java.lang.String* languageTag <_volatile> 
      		sun.util.locale.BaseLocale* baseLocale <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.lang.Cloneable 
      		class java.io.Serializable
      	}
      	methods: {
      		void Locale.<clinit>() 
      		BaseLocale Locale.access$600(Locale) 
      		int Locale.hashCode() 
      		String[] Locale.getISOCountries() 
      		Locale Locale.getInstance(BaseLocale,LocaleExtensions) 
      		LocaleExtensions Locale.getLocaleExtensions() 
      		List Locale.filterTags(List,Collection,Locale$FilteringMode) 
      		boolean Locale.equals(Object) 
      		String Locale.getISO3Country() 
      		void Locale.setDefault(Locale$Category,Locale) 
      		String Locale.getDisplayVariant(Locale) 
      		Locale[] Locale.getAvailableLocales() 
      		Set Locale.getUnicodeLocaleKeys() 
      		Set Locale.getExtensionKeys() 
      		Locale Locale.initDefault(Locale$Category) 
      		String Locale.getDisplayScript(Locale) 
      		Object Locale.clone() 
      		Locale Locale.createConstant(String,String) 
      		Locale.<init>(BaseLocale,LocaleExtensions) 
      		String Locale.getDisplayVariant() 
      		boolean Locale.hasExtensions() 
      		String Locale.getDisplayName(Locale) 
      		String Locale.getLanguage() 
      		void Locale.writeObject(ObjectOutputStream) 
      		LocaleExtensions Locale.access$800(String,String,String,String) 
      		boolean Locale.isUnicodeExtensionKey(String) 
      		Locale Locale.stripExtensions() 
      		Locale.<init>(BaseLocale,LocaleExtensions,Locale$1) 
      		String Locale.getDisplayLanguage(Locale) 
      		String Locale.lookupTag(List,Collection) 
      		String Locale.getDisplayScript() 
      		String[] Locale.getISO2Table(String) 
      		Locale Locale.getDefault(Locale$Category) 
      		Locale.<init>(String,String) 
      		Locale Locale.forLanguageTag(String) 
      		String Locale.getCountry() 
      		Locale Locale.getInstance(String,String,String) 
      		List Locale.filter(List,Collection) 
      		void Locale.readObject(ObjectInputStream) 
      		LocaleExtensions Locale.access$700(Locale) 
      		Set Locale.getUnicodeLocaleAttributes() 
      		String[] Locale.getISOLanguages() 
      		Locale Locale.getInstance(String,String,String,String,LocaleExtensions) 
      		String Locale.getISO3Code(String,String) 
      		Locale Locale.lookup(List,Collection) 
      		String Locale.getDisplayLanguage() 
      		String[] Locale.getDisplayVariantArray(Locale) 
      		String Locale.toLanguageTag() 
      		String Locale.getScript() 
      		String Locale.getDisplayCountry(Locale) 
      		String Locale.toString() 
      		Locale Locale.initDefault() 
      		String Locale.convertOldISOCodes(String) 
      		String Locale.getDisplayName() 
      		String Locale.getUnicodeLocaleType(String) 
      		String Locale.getExtension(char) 
      		String Locale.getDisplayString(String,Locale,int) 
      		LocaleExtensions Locale.getCompatibilityExtensions(String,String,String,String) 
      		Locale Locale.getDefault() 
      		String Locale.getDisplayCountry() 
      		Object Locale.readResolve() 
      		String Locale.formatList(String[],String,String) 
      		Locale.<init>(String) 
      		List Locale.filter(List,Collection,Locale$FilteringMode) 
      		String Locale.getISO3Language() 
      		String Locale.getVariant() 
      		Locale.<init>(String,String,String) 
      		void Locale.setDefault(Locale) 
      		BaseLocale Locale.getBaseLocale() 
      		List Locale.filterTags(List,Collection) 
      		String[] Locale.composeList(MessageFormat,String[])
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.management.OperatingSystemMXBean
TYPE: class java.lang.management.OperatingSystemMXBean 
      	fields: {
      	}
      	supers: {
      		class java.lang.management.PlatformManagedObject
      	}
      	methods: {
      		int OperatingSystemMXBean.getAvailableProcessors() 
      		String OperatingSystemMXBean.getArch() 
      		String OperatingSystemMXBean.getName() 
      		double OperatingSystemMXBean.getSystemLoadAverage() 
      		String OperatingSystemMXBean.getVersion()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.pojo.Grupa
TYPE: class com.stn.pojo.Grupa 
      	fields: {
      		int idSerie <> 
      		java.lang.String* nume <> 
      		int idGrupa <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Grupa.setNume(String) 
      		int Grupa.getIdSerie() 
      		int Grupa.getIdGrupa() 
      		void Grupa.setIdSerie(int) 
      		String Grupa.getNume() 
      		void Grupa.setIdGrupa(int) 
      		Grupa.<init>(int,String,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.HashMap$TreeNode
TYPE: class java.util.HashMap$TreeNode 
      	fields: {
      		_Bool red <> 
      		java.util.HashMap$TreeNode* left <> 
      		java.util.HashMap$TreeNode* prev <> 
      		java.util.HashMap$TreeNode* parent <> 
      		java.util.HashMap$TreeNode* right <> 
      		java.util.LinkedHashMap$Entry* after <> 
      		java.util.LinkedHashMap$Entry* before <> 
      		java.util.HashMap$Node* next <> 
      		java.lang.Object* key <_final> 
      		java.lang.Object* value <> 
      		int hash <_final>
      	}
      	supers: {
      		class java.util.LinkedHashMap$Entry
      	}
      	methods: {
      		void HashMap$TreeNode.<clinit>() 
      		int HashMap$TreeNode.tieBreakOrder(Object,Object) 
      		void HashMap$TreeNode.split(HashMap,HashMap$Node[],int,int) 
      		HashMap$TreeNode HashMap$TreeNode.balanceDeletion(HashMap$TreeNode,HashMap$TreeNode) 
      		void HashMap$TreeNode.removeTreeNode(HashMap,HashMap$Node[],boolean) 
      		HashMap$TreeNode HashMap$TreeNode.putTreeVal(HashMap,HashMap$Node[],int,Object,Object) 
      		void HashMap$TreeNode.moveRootToFront(HashMap$Node[],HashMap$TreeNode) 
      		void HashMap$TreeNode.treeify(HashMap$Node[]) 
      		HashMap$TreeNode HashMap$TreeNode.getTreeNode(int,Object) 
      		HashMap$TreeNode HashMap$TreeNode.rotateRight(HashMap$TreeNode,HashMap$TreeNode) 
      		HashMap$TreeNode HashMap$TreeNode.find(int,Object,Class) 
      		HashMap$TreeNode HashMap$TreeNode.balanceInsertion(HashMap$TreeNode,HashMap$TreeNode) 
      		HashMap$TreeNode.<init>(int,Object,Object,HashMap$Node) 
      		HashMap$TreeNode HashMap$TreeNode.rotateLeft(HashMap$TreeNode,HashMap$TreeNode) 
      		boolean HashMap$TreeNode.checkInvariants(HashMap$TreeNode) 
      		HashMap$Node HashMap$TreeNode.untreeify(HashMap) 
      		HashMap$TreeNode HashMap$TreeNode.root()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.ObjectInputValidation
TYPE: class java.io.ObjectInputValidation 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void ObjectInputValidation.validateObject()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Character
TYPE: class java.lang.Character 
      	fields: {
      		unsigned short value <_final>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable 
      		class java.lang.Comparable
      	}
      	methods: {
      		void Character.<clinit>() 
      		char[] Character.toChars(int) 
      		boolean Character.isLetterOrDigit(int) 
      		int Character.hashCode() 
      		int Character.codePointBefore(char[],int,int) 
      		char Character.lowSurrogate(int) 
      		boolean Character.isISOControl(int) 
      		int Character.codePointCountImpl(char[],int,int) 
      		int Character.getNumericValue(char) 
      		boolean Character.isUnicodeIdentifierPart(int) 
      		boolean Character.isLetter(char) 
      		boolean Character.equals(Object) 
      		boolean Character.isDefined(char) 
      		String Character.toString(char) 
      		boolean Character.isHighSurrogate(char) 
      		boolean Character.isMirrored(char) 
      		boolean Character.isIdeographic(int) 
      		boolean Character.isValidCodePoint(int) 
      		int Character.offsetByCodePoints(char[],int,int,int,int) 
      		int Character.compareTo(Object) 
      		char Character.charValue() 
      		boolean Character.isISOControl(char) 
      		int Character.digit(char,int) 
      		int Character.digit(int,int) 
      		boolean Character.isUnicodeIdentifierStart(char) 
      		int Character.codePointAt(char[],int) 
      		boolean Character.isTitleCase(int) 
      		int Character.toUpperCaseEx(int) 
      		boolean Character.isJavaIdentifierPart(char) 
      		int Character.codePointCount(char[],int,int) 
      		boolean Character.isMirrored(int) 
      		Character.<init>(char) 
      		boolean Character.isSpaceChar(char) 
      		int Character.toUpperCase(int) 
      		boolean Character.isJavaLetterOrDigit(char) 
      		boolean Character.isSurrogatePair(char,char) 
      		char Character.toUpperCase(char) 
      		boolean Character.isUpperCase(int) 
      		String Character.getName(int) 
      		int Character.toLowerCase(int) 
      		boolean Character.isJavaIdentifierPart(int) 
      		void Character.toSurrogates(int,char[],int) 
      		boolean Character.isUpperCase(char) 
      		boolean Character.isLetterOrDigit(char) 
      		int Character.compareTo(Character) 
      		boolean Character.isLowerCase(int) 
      		char Character.forDigit(int,int) 
      		boolean Character.isSpaceChar(int) 
      		int Character.codePointAtImpl(char[],int,int) 
      		boolean Character.isIdentifierIgnorable(char) 
      		int Character.codePointBefore(CharSequence,int) 
      		boolean Character.isDefined(int) 
      		boolean Character.isJavaIdentifierStart(char) 
      		int Character.codePointCount(CharSequence,int,int) 
      		byte Character.getDirectionality(int) 
      		int Character.offsetByCodePointsImpl(char[],int,int,int,int) 
      		boolean Character.isSpace(char) 
      		boolean Character.isIdentifierIgnorable(int) 
      		boolean Character.isJavaLetter(char) 
      		boolean Character.isSupplementaryCodePoint(int) 
      		char Character.reverseBytes(char) 
      		char[] Character.toUpperCaseCharArray(int) 
      		boolean Character.isJavaIdentifierStart(int) 
      		boolean Character.isLowerCase(char) 
      		boolean Character.isSurrogate(char) 
      		int Character.toCodePoint(char,char) 
      		int Character.getType(char) 
      		String Character.toString() 
      		int Character.getNumericValue(int) 
      		boolean Character.isUnicodeIdentifierPart(char) 
      		int Character.codePointAt(char[],int,int) 
      		boolean Character.isDigit(int) 
      		boolean Character.isBmpCodePoint(int) 
      		int Character.offsetByCodePoints(CharSequence,int,int) 
      		int Character.compare(char,char) 
      		int Character.hashCode(char) 
      		boolean Character.isWhitespace(char) 
      		int Character.toTitleCase(int) 
      		boolean Character.isAlphabetic(int) 
      		int Character.codePointAt(CharSequence,int) 
      		char Character.toLowerCase(char) 
      		boolean Character.isDigit(char) 
      		int Character.charCount(int) 
      		boolean Character.isUnicodeIdentifierStart(int) 
      		boolean Character.isTitleCase(char) 
      		Character Character.valueOf(char) 
      		boolean Character.isLowSurrogate(char) 
      		int Character.getType(int) 
      		byte Character.getDirectionality(char) 
      		boolean Character.isWhitespace(int) 
      		int Character.codePointBeforeImpl(char[],int,int) 
      		char Character.toTitleCase(char) 
      		int Character.codePointBefore(char[],int) 
      		char Character.highSurrogate(int) 
      		boolean Character.isLetter(int) 
      		int Character.toChars(int,char[],int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.pojo.User
TYPE: class com.stn.pojo.User 
      	fields: {
      		java.lang.String* password <> 
      		int idSerie <> 
      		java.lang.String* userName <> 
      		int id <> 
      		java.lang.String* serie <> 
      		int idFacultate <> 
      		java.sql.Timestamp* lastSeen <> 
      		int countryId <> 
      		int donor <> 
      		java.lang.String* lastName <> 
      		java.lang.String* email <> 
      		java.lang.String* ip <> 
      		java.lang.String* countryImage <> 
      		int anonymity <> 
      		int userClass <> 
      		java.lang.String* firstName <> 
      		java.lang.String* grupa <> 
      		int idGrupa <> 
      		java.lang.String* avatar <> 
      		java.lang.String* countryName <> 
      		java.lang.String* facultate <> 
      		java.sql.Timestamp* joinDate <> 
      		signed char[_*_](*) salt <> 
      		int gender <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void User.setGender(int) 
      		Timestamp User.getJoinDate() 
      		String User.getFacultate() 
      		void User.setLastName(String) 
      		int User.getUserClass() 
      		int User.getGender() 
      		void User.setIp(String) 
      		void User.setIdFacultate(int) 
      		void User.setCountryName(String) 
      		int User.getIdSerie() 
      		String User.getCountryName() 
      		void User.setDonor(int) 
      		String User.getAvatar() 
      		String User.getGrupa() 
      		void User.setLastSeen(Timestamp) 
      		User.<init>() 
      		String User.getFirstName() 
      		void User.setEmail(String) 
      		int User.getId() 
      		void User.setSerie(String) 
      		String User.getUserName() 
      		byte[] User.getSalt() 
      		void User.setCountryId(int) 
      		int User.getIdGrupa() 
      		int User.getCountryId() 
      		void User.setAnonymity(int) 
      		Timestamp User.getLastSeen() 
      		String User.getSerie() 
      		void User.setIdSerie(int) 
      		void User.setJoinDate(Timestamp) 
      		void User.setId(int) 
      		String User.getPassword() 
      		void User.setUserName(String) 
      		int User.getAnonymity() 
      		void User.setGrupa(String) 
      		void User.setIdGrupa(int) 
      		void User.setCountryImage(String) 
      		String User.getEmail() 
      		int User.getIdFacultate() 
      		String User.getCountryImage() 
      		void User.setPassword(String) 
      		String User.getIp() 
      		void User.setUserClass(int) 
      		void User.setAvatar(String) 
      		String User.getLastName() 
      		void User.setFirstName(String) 
      		void User.setFacultate(String) 
      		int User.getDonor() 
      		void User.setSalt(byte[])
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.net.InetAddress
TYPE: class java.net.InetAddress 
      	fields: {
      		java.lang.String* canonicalHostName <> 
      		java.net.InetAddress$InetAddressHolder* holder <_final>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable
      	}
      	methods: {
      		void InetAddress.<clinit>() 
      		String InetAddress.getHostFromNameService(InetAddress,boolean) 
      		int InetAddress.hashCode() 
      		boolean InetAddress.isAnyLocalAddress() 
      		String InetAddress.getHostName() 
      		void InetAddress.readObjectNoData(ObjectInputStream) 
      		boolean InetAddress.equals(Object) 
      		boolean InetAddress.isMCOrgLocal() 
      		void InetAddress.updateLookupTable(String) 
      		InetAddress InetAddress.anyLocalAddress() 
      		boolean InetAddress.isMCGlobal() 
      		InetAddress[] InetAddress.getAddressesFromNameService(String,InetAddress) 
      		InetAddress InetAddress.getLoopbackAddress() 
      		void InetAddress.writeObject(ObjectOutputStream) 
      		boolean InetAddress.isLinkLocalAddress() 
      		InetAddress[] InetAddress.getAllByName0(String,InetAddress,boolean) 
      		InetAddress[] InetAddress.getAllByName(String) 
      		String InetAddress.getCanonicalHostName() 
      		InetAddress.<init>() 
      		void InetAddress.cacheInitIfNeeded() 
      		boolean InetAddress.isMCLinkLocal() 
      		int InetAddress.checkNumericZone(String) 
      		InetAddress InetAddress.getByAddress(byte[]) 
      		NameService InetAddress.createNSProvider(String) 
      		void InetAddress.readObject(ObjectInputStream) 
      		byte[] InetAddress.getAddress() 
      		boolean InetAddress.isLoopbackAddress() 
      		boolean InetAddress.isReachable(int) 
      		InetAddress InetAddress.getByAddress(String,byte[]) 
      		boolean InetAddress.isMCNodeLocal() 
      		InetAddress[] InetAddress.checkLookupTable(String) 
      		InetAddress InetAddress.getByName(String) 
      		String InetAddress.toString() 
      		InetAddress[] InetAddress.getAllByName0(String) 
      		boolean InetAddress.isReachable(NetworkInterface,int,int) 
      		String InetAddress.getHostAddress() 
      		InetAddress[] InetAddress.getAllByName0(String,boolean) 
      		boolean InetAddress.isSiteLocalAddress() 
      		InetAddress[] InetAddress.getCachedAddresses(String) 
      		InetAddress[] InetAddress.getAllByName(String,InetAddress) 
      		InetAddress InetAddress.getByName(String,InetAddress) 
      		Object InetAddress.readResolve() 
      		InetAddress$InetAddressHolder InetAddress.holder() 
      		boolean InetAddress.isMCSiteLocal() 
      		void InetAddress.cacheAddresses(String,InetAddress[],boolean) 
      		InetAddress InetAddress.getLocalHost() 
      		InetAddressImpl InetAddress.loadImpl(String) 
      		boolean InetAddress.isMulticastAddress() 
      		String InetAddress.getHostName(boolean) 
      		void InetAddress.init()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.CategoryProcess
TYPE: class com.stn.servlets.CategoryProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void CategoryProcess.doPost(HttpServletRequest,HttpServletResponse) 
      		CategoryProcess.<init>() 
      		void CategoryProcess.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/CategoryProcess")>
      	}NAME: class javax.mail.Multipart
TYPE: class javax.mail.Multipart 
      	fields: {
      		java.util.Vector* parts <> 
      		javax.mail.Part* parent <> 
      		java.lang.String* contentType <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		BodyPart Multipart.getBodyPart(int) 
      		String Multipart.getContentType() 
      		void Multipart.addBodyPart(BodyPart,int) 
      		boolean Multipart.removeBodyPart(BodyPart) 
      		Multipart.<init>() 
      		void Multipart.setMultipartDataSource(MultipartDataSource) 
      		void Multipart.setParent(Part) 
      		void Multipart.addBodyPart(BodyPart) 
      		Part Multipart.getParent() 
      		void Multipart.writeTo(OutputStream) 
      		int Multipart.getCount() 
      		void Multipart.removeBodyPart(int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.DoublePredicate
TYPE: class java.util.function.DoublePredicate 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		boolean DoublePredicate.lambda$or$2(DoublePredicate,double) 
      		DoublePredicate DoublePredicate.callsite_java.util.function.DoublePredicate$Lambda$_1_7(DoublePredicate,DoublePredicate) 
      		DoublePredicate DoublePredicate.callsite_java.util.function.DoublePredicate$Lambda$_6_7(DoublePredicate,DoublePredicate) 
      		DoublePredicate DoublePredicate.negate() 
      		boolean DoublePredicate.lambda$and$0(DoublePredicate,double) 
      		boolean DoublePredicate.access_java.util.function.DoublePredicate$Lambda$_1_7(DoublePredicate,DoublePredicate,double) 
      		boolean DoublePredicate.access_java.util.function.DoublePredicate$Lambda$_5_1(DoublePredicate,double) 
      		DoublePredicate DoublePredicate.and(DoublePredicate) 
      		boolean DoublePredicate.test(double) 
      		boolean DoublePredicate.access_java.util.function.DoublePredicate$Lambda$_6_7(DoublePredicate,DoublePredicate,double) 
      		DoublePredicate DoublePredicate.or(DoublePredicate) 
      		boolean DoublePredicate.lambda$negate$1(double) 
      		DoublePredicate DoublePredicate.callsite_java.util.function.DoublePredicate$Lambda$_5_1(DoublePredicate)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.util.stream.IntStream$Builder
TYPE: class java.util.stream.IntStream$Builder 
      	fields: {
      	}
      	supers: {
      		class java.util.function.IntConsumer
      	}
      	methods: {
      		void IntStream$Builder.accept(int) 
      		IntStream IntStream$Builder.build() 
      		IntStream$Builder IntStream$Builder.add(int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.LeaveGrupaProcess
TYPE: class com.stn.servlets.LeaveGrupaProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void LeaveGrupaProcess.doPost(HttpServletRequest,HttpServletResponse) 
      		LeaveGrupaProcess.<init>() 
      		void LeaveGrupaProcess.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/LeaveGrupaProcess")>
      	}NAME: class java.io.Externalizable
TYPE: class java.io.Externalizable 
      	fields: {
      	}
      	supers: {
      		class java.io.Serializable
      	}
      	methods: {
      		void Externalizable.writeExternal(ObjectOutput) 
      		void Externalizable.readExternal(ObjectInput)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.EditNewsProcess
TYPE: class com.stn.servlets.EditNewsProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void EditNewsProcess.doPost(HttpServletRequest,HttpServletResponse) 
      		EditNewsProcess.<init>() 
      		void EditNewsProcess.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/EditNewsProcess")>
      	}NAME: class java.util.Properties$LineReader
TYPE: class java.util.Properties$LineReader 
      	fields: {
      		java.io.InputStream* inStream <> 
      		int inLimit <> 
      		java.io.Reader* reader <> 
      		java.util.Properties* this$0 <_final> 
      		signed char[_*_](*) inByteBuf <> 
      		unsigned short[_*_](*) lineBuf <> 
      		int inOff <> 
      		unsigned short[_*_](*) inCharBuf <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		int Properties$LineReader.readLine() 
      		Properties$LineReader.<init>(Properties,Reader) 
      		Properties$LineReader.<init>(Properties,InputStream)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Class$AnnotationData
TYPE: class java.lang.Class$AnnotationData 
      	fields: {
      		java.util.Map* declaredAnnotations <_final> 
      		int redefinedCount <_final> 
      		java.util.Map* annotations <_final>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		Class$AnnotationData.<init>(Map,Map,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.FacultateProcess
TYPE: class com.stn.servlets.FacultateProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void FacultateProcess.doPost(HttpServletRequest,HttpServletResponse) 
      		FacultateProcess.<init>() 
      		void FacultateProcess.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/FacultateProcess")>
      	}NAME: class javax.management.QueryExp
TYPE: class javax.management.QueryExp 
      	fields: {
      	}
      	supers: {
      		class java.io.Serializable
      	}
      	methods: {
      		void QueryExp.setMBeanServer(MBeanServer) 
      		boolean QueryExp.apply(ObjectName)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.xml.transform.Result
TYPE: class javax.xml.transform.Result 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void Result.setSystemId(String) 
      		String Result.getSystemId()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.management.RuntimeMXBean
TYPE: class java.lang.management.RuntimeMXBean 
      	fields: {
      	}
      	supers: {
      		class java.lang.management.PlatformManagedObject
      	}
      	methods: {
      		Map RuntimeMXBean.getSystemProperties() 
      		String RuntimeMXBean.getManagementSpecVersion() 
      		String RuntimeMXBean.getVmVersion() 
      		String RuntimeMXBean.getBootClassPath() 
      		String RuntimeMXBean.getVmName() 
      		String RuntimeMXBean.getLibraryPath() 
      		String RuntimeMXBean.getName() 
      		String RuntimeMXBean.getSpecVendor() 
      		long RuntimeMXBean.getUptime() 
      		String RuntimeMXBean.getClassPath() 
      		String RuntimeMXBean.getSpecName() 
      		List RuntimeMXBean.getInputArguments() 
      		String RuntimeMXBean.getVmVendor() 
      		boolean RuntimeMXBean.isBootClassPathSupported() 
      		String RuntimeMXBean.getSpecVersion() 
      		long RuntimeMXBean.getStartTime()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.text.AttributedCharacterIterator
TYPE: class java.text.AttributedCharacterIterator 
      	fields: {
      	}
      	supers: {
      		class java.text.CharacterIterator
      	}
      	methods: {
      		Set AttributedCharacterIterator.getAllAttributeKeys() 
      		int AttributedCharacterIterator.getRunStart() 
      		int AttributedCharacterIterator.getRunLimit(AttributedCharacterIterator$Attribute) 
      		int AttributedCharacterIterator.getRunStart(Set) 
      		Map AttributedCharacterIterator.getAttributes() 
      		int AttributedCharacterIterator.getRunStart(AttributedCharacterIterator$Attribute) 
      		int AttributedCharacterIterator.getRunLimit(Set) 
      		int AttributedCharacterIterator.getRunLimit() 
      		Object AttributedCharacterIterator.getAttribute(AttributedCharacterIterator$Attribute)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.reflect.generics.repository.ClassRepository
TYPE: class sun.reflect.generics.repository.ClassRepository 
      	fields: {
      		java.lang.reflect.Type*[_*_](*) superInterfaces <_volatile> 
      		java.lang.reflect.Type* superclass <_volatile> 
      		java.lang.reflect.TypeVariable*[_*_](*) typeParams <_volatile> 
      		sun.reflect.generics.factory.GenericsFactory* factory <_final> 
      		sun.reflect.generics.tree.Tree* tree <_final>
      	}
      	supers: {
      		class sun.reflect.generics.repository.GenericDeclRepository
      	}
      	methods: {
      		void ClassRepository.<clinit>() 
      		ClassRepository.<init>(String,GenericsFactory) 
      		Type[] ClassRepository.getSuperInterfaces() 
      		ClassRepository ClassRepository.make(String,GenericsFactory) 
      		Tree ClassRepository.parse(String) 
      		ClassSignature ClassRepository.parse(String) 
      		Type ClassRepository.getSuperclass()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.ServletRequest
TYPE: class javax.servlet.ServletRequest 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		RequestDispatcher ServletRequest.getRequestDispatcher(String) 
      		String ServletRequest.getCharacterEncoding() 
      		boolean ServletRequest.isAsyncStarted() 
      		Map ServletRequest.getParameterMap() 
      		String ServletRequest.getLocalAddr() 
      		String ServletRequest.getContentType() 
      		void ServletRequest.removeAttribute(String) 
      		Object ServletRequest.getAttribute(String) 
      		int ServletRequest.getRemotePort() 
      		String ServletRequest.getServerName() 
      		String ServletRequest.getProtocol() 
      		int ServletRequest.getContentLength() 
      		AsyncContext ServletRequest.getAsyncContext() 
      		String ServletRequest.getRemoteAddr() 
      		BufferedReader ServletRequest.getReader() 
      		AsyncContext ServletRequest.startAsync() 
      		void ServletRequest.setAttribute(String,Object) 
      		Enumeration ServletRequest.getParameterNames() 
      		Enumeration ServletRequest.getLocales() 
      		String ServletRequest.getRealPath(String) 
      		String ServletRequest.getScheme() 
      		void ServletRequest.setCharacterEncoding(String) 
      		String ServletRequest.getParameter(String) 
      		boolean ServletRequest.isAsyncSupported() 
      		int ServletRequest.getServerPort() 
      		int ServletRequest.getLocalPort() 
      		ServletInputStream ServletRequest.getInputStream() 
      		Locale ServletRequest.getLocale() 
      		ServletContext ServletRequest.getServletContext() 
      		String ServletRequest.getLocalName() 
      		long ServletRequest.getContentLengthLong() 
      		DispatcherType ServletRequest.getDispatcherType() 
      		String ServletRequest.getRemoteHost() 
      		AsyncContext ServletRequest.startAsync(ServletRequest,ServletResponse) 
      		String[] ServletRequest.getParameterValues(String) 
      		Enumeration ServletRequest.getAttributeNames() 
      		boolean ServletRequest.isSecure()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.SQLXML
TYPE: class java.sql.SQLXML 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Writer SQLXML.setCharacterStream() 
      		Result SQLXML.setResult(Class) 
      		InputStream SQLXML.getBinaryStream() 
      		void SQLXML.setString(String) 
      		OutputStream SQLXML.setBinaryStream() 
      		String SQLXML.getString() 
      		Source SQLXML.getSource(Class) 
      		void SQLXML.free() 
      		Reader SQLXML.getCharacterStream()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.GrupaProcess
TYPE: class com.stn.servlets.GrupaProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void GrupaProcess.doPost(HttpServletRequest,HttpServletResponse) 
      		GrupaProcess.<init>() 
      		void GrupaProcess.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/GrupaProcess")>
      	}NAME: class java.lang.Math
TYPE: class java.lang.Math 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Math.<clinit>() 
      		double Math.max(double,double) 
      		double Math.floor(double) 
      		int Math.subtractExact(int,int) 
      		double Math.nextAfter(double,double) 
      		double Math.asin(double) 
      		double Math.expm1(double) 
      		long Math.floorDiv(long,long) 
      		int Math.negateExact(int) 
      		int Math.min(int,int) 
      		double Math.ulp(double) 
      		double Math.sinh(double) 
      		int Math.incrementExact(int) 
      		double Math.nextDown(double) 
      		double Math.log10(double) 
      		int Math.round(float) 
      		int Math.getExponent(float) 
      		long Math.floorMod(long,long) 
      		float Math.min(float,float) 
      		double Math.atan2(double,double) 
      		int Math.multiplyExact(int,int) 
      		double Math.nextUp(double) 
      		double Math.atan(double) 
      		double Math.toRadians(double) 
      		double Math.abs(double) 
      		int Math.toIntExact(long) 
      		Math.<init>() 
      		double Math.signum(double) 
      		double Math.cos(double) 
      		double Math.tanh(double) 
      		long Math.abs(long) 
      		int Math.decrementExact(int) 
      		double Math.scalb(double,int) 
      		double Math.IEEEremainder(double,double) 
      		int Math.addExact(int,int) 
      		double Math.log(double) 
      		float Math.powerOfTwoF(int) 
      		long Math.max(long,long) 
      		long Math.min(long,long) 
      		double Math.copySign(double,double) 
      		double Math.rint(double) 
      		long Math.subtractExact(long,long) 
      		float Math.nextAfter(float,double) 
      		double Math.acos(double) 
      		double Math.log1p(double) 
      		int Math.getExponent(double) 
      		long Math.negateExact(long) 
      		float Math.ulp(float) 
      		double Math.sin(double) 
      		double Math.cosh(double) 
      		long Math.incrementExact(long) 
      		float Math.nextDown(float) 
      		double Math.cbrt(double) 
      		double Math.random() 
      		float Math.abs(float) 
      		int Math.abs(int) 
      		double Math.min(double,double) 
      		float Math.copySign(float,float) 
      		double Math.pow(double,double) 
      		long Math.multiplyExact(long,long) 
      		float Math.nextUp(float) 
      		double Math.exp(double) 
      		double Math.toDegrees(double) 
      		double Math.powerOfTwoD(int) 
      		int Math.floorMod(int,int) 
      		float Math.signum(float) 
      		double Math.tan(double) 
      		int Math.max(int,int) 
      		double Math.hypot(double,double) 
      		int Math.floorDiv(int,int) 
      		long Math.round(double) 
      		long Math.decrementExact(long) 
      		float Math.scalb(float,int) 
      		double Math.ceil(double) 
      		long Math.addExact(long,long) 
      		double Math.sqrt(double) 
      		float Math.max(float,float)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.DoubleFunction
TYPE: class java.util.function.DoubleFunction 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Object DoubleFunction.apply(double)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class javax.activation.DataSource
TYPE: class javax.activation.DataSource 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		InputStream DataSource.getInputStream() 
      		String DataSource.getContentType() 
      		String DataSource.getName() 
      		OutputStream DataSource.getOutputStream()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.Part
TYPE: class javax.mail.Part 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void Part.setDataHandler(DataHandler) 
      		Enumeration Part.getNonMatchingHeaders(String[]) 
      		String Part.getDisposition() 
      		InputStream Part.getInputStream() 
      		String[] Part.getHeader(String) 
      		String Part.getContentType() 
      		String Part.getFileName() 
      		void Part.setContent(Multipart) 
      		void Part.addHeader(String,String) 
      		String Part.getDescription() 
      		Enumeration Part.getAllHeaders() 
      		int Part.getLineCount() 
      		DataHandler Part.getDataHandler() 
      		void Part.setText(String) 
      		void Part.setDisposition(String) 
      		void Part.removeHeader(String) 
      		int Part.getSize() 
      		void Part.setFileName(String) 
      		void Part.writeTo(OutputStream) 
      		void Part.setHeader(String,String) 
      		void Part.setDescription(String) 
      		Enumeration Part.getMatchingHeaders(String[]) 
      		boolean Part.isMimeType(String) 
      		void Part.setContent(Object,String) 
      		Object Part.getContent()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.DoubleSupplier
TYPE: class java.util.function.DoubleSupplier 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		double DoubleSupplier.getAsDouble()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class javax.servlet.ServletInputStream
TYPE: class javax.servlet.ServletInputStream 
      	fields: {
      	}
      	supers: {
      		class java.io.InputStream
      	}
      	methods: {
      		boolean ServletInputStream.isReady() 
      		ServletInputStream.<init>() 
      		int ServletInputStream.readLine(byte[],int,int) 
      		void ServletInputStream.setReadListener(ReadListener) 
      		boolean ServletInputStream.isFinished()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.management.ObjectName
TYPE: class javax.management.ObjectName 
      	fields: {
      		java.util.Map* _propertyList <> 
      		_Bool _property_list_pattern <> 
      		javax.management.ObjectName$Property*[_*_](*) _ca_array <> 
      		_Bool _domain_pattern <> 
      		javax.management.ObjectName$Property*[_*_](*) _kp_array <> 
      		java.lang.String* _canonicalName <> 
      		_Bool _property_value_pattern <> 
      		int _domain_length <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.lang.Comparable 
      		class javax.management.QueryExp
      	}
      	methods: {
      		void ObjectName.<clinit>() 
      		boolean ObjectName.isPattern() 
      		int ObjectName.hashCode() 
      		void ObjectName.setMBeanServer(MBeanServer) 
      		int[] ObjectName.parseValue(char[],int) 
      		boolean ObjectName.equals(Object) 
      		boolean ObjectName.isPropertyValuePattern() 
      		boolean ObjectName.isDomain(String) 
      		String ObjectName.unquote(String) 
      		int ObjectName.compareTo(Object) 
      		String ObjectName.getKeyPropertyListString() 
      		void ObjectName.checkKey(String) 
      		ObjectName ObjectName.getInstance(String) 
      		void ObjectName.writeObject(ObjectOutputStream) 
      		boolean ObjectName.isPropertyPattern() 
      		void ObjectName.addProperty(ObjectName$Property,int,Map,String) 
      		void ObjectName.construct(String) 
      		String ObjectName.getKeyProperty(String) 
      		String ObjectName.quote(String) 
      		boolean ObjectName.matchDomains(ObjectName) 
      		ObjectName.<init>(String,Hashtable) 
      		ObjectName ObjectName.getInstance(String,Hashtable) 
      		void ObjectName.readObject(ObjectInputStream) 
      		boolean ObjectName.isDomainPattern() 
      		String ObjectName.getCanonicalName() 
      		void ObjectName.construct(String,Map) 
      		int ObjectName.parseKey(char[],int) 
      		String ObjectName.getCanonicalKeyPropertyListString() 
      		boolean ObjectName.isPropertyValuePattern(String) 
      		boolean ObjectName.checkValue(String) 
      		int ObjectName.writeKeyPropertyListString(char[],char[],int) 
      		String ObjectName.toString() 
      		String ObjectName.getSerializedNameString() 
      		ObjectName ObjectName.getInstance(String,String,String) 
      		boolean ObjectName.isPropertyListPattern() 
      		void ObjectName.setCanonicalName(char[],char[],String[],Map,int,int) 
      		Map ObjectName._getKeyPropertyList() 
      		Hashtable ObjectName.getKeyPropertyList() 
      		int ObjectName.compareTo(ObjectName) 
      		ObjectName.<init>(String) 
      		boolean ObjectName.apply(ObjectName) 
      		String ObjectName.getDomain() 
      		boolean ObjectName.matchKeys(ObjectName) 
      		ObjectName.<init>(String,String,String) 
      		ObjectName ObjectName.getInstance(ObjectName)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.LinkedHashMap
TYPE: class java.util.LinkedHashMap 
      	fields: {
      		java.util.LinkedHashMap$Entry* head <> 
      		java.util.LinkedHashMap$Entry* tail <> 
      		_Bool accessOrder <_final> 
      		java.lang.Object* lastKey2 <> 
      		java.lang.Object* lastKey1 <> 
      		float loadFactor <_final> 
      		int size <> 
      		java.util.Set* entrySet <> 
      		int threshold <> 
      		java.util.HashMap$Node*[_*_](*) table <> 
      		int modCount <> 
      		java.util.Set* keySet <> 
      		java.util.Collection* values <>
      	}
      	supers: {
      		class java.util.HashMap 
      		class java.util.Map
      	}
      	methods: {
      		LinkedHashMap.<init>(int) 
      		void LinkedHashMap.internalWriteEntries(ObjectOutputStream) 
      		boolean LinkedHashMap.containsValue(Object) 
      		Object LinkedHashMap.get(Object) 
      		void LinkedHashMap.replaceAll(BiFunction) 
      		void LinkedHashMap.transferLinks(LinkedHashMap$Entry,LinkedHashMap$Entry) 
      		Set LinkedHashMap.keySet() 
      		Object LinkedHashMap.getOrDefault(Object,Object) 
      		LinkedHashMap.<init>() 
      		HashMap$TreeNode LinkedHashMap.newTreeNode(int,Object,Object,HashMap$Node) 
      		void LinkedHashMap.afterNodeAccess(HashMap$Node) 
      		HashMap$TreeNode LinkedHashMap.replacementTreeNode(HashMap$Node,HashMap$Node) 
      		Set LinkedHashMap.entrySet() 
      		Collection LinkedHashMap.values() 
      		LinkedHashMap.<init>(int,float) 
      		void LinkedHashMap.afterNodeRemoval(HashMap$Node) 
      		HashMap$Node LinkedHashMap.replacementNode(HashMap$Node,HashMap$Node) 
      		boolean LinkedHashMap.removeEldestEntry(Map$Entry) 
      		void LinkedHashMap.forEach(BiConsumer) 
      		void LinkedHashMap.linkNodeLast(LinkedHashMap$Entry) 
      		HashMap$Node LinkedHashMap.newNode(int,Object,Object,HashMap$Node) 
      		void LinkedHashMap.clear() 
      		void LinkedHashMap.reinitialize() 
      		LinkedHashMap.<init>(Map) 
      		LinkedHashMap.<init>(int,float,boolean) 
      		void LinkedHashMap.afterNodeInsertion(boolean)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.EventObject
TYPE: class java.util.EventObject 
      	fields: {
      		java.lang.Object* source <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable
      	}
      	methods: {
      		EventObject.<init>(Object) 
      		Object EventObject.getSource() 
      		String EventObject.toString()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.management.DescriptorRead
TYPE: class javax.management.DescriptorRead 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Descriptor DescriptorRead.getDescriptor()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Dictionary
TYPE: class java.util.Dictionary 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		Object Dictionary.put(Object,Object) 
      		Object Dictionary.get(Object) 
      		int Dictionary.size() 
      		Enumeration Dictionary.elements() 
      		Dictionary.<init>() 
      		Object Dictionary.remove(Object) 
      		Enumeration Dictionary.keys() 
      		boolean Dictionary.isEmpty()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.AddTopic
TYPE: class com.stn.servlets.AddTopic 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void AddTopic.doPost(HttpServletRequest,HttpServletResponse) 
      		AddTopic.<init>()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/AddTopic")>
      	}NAME: class java.lang.Thread
TYPE: class java.lang.Thread 
      	fields: {
      		java.lang.Runnable* target <> 
      		java.lang.Object* parkBlocker <_volatile> 
      		java.lang.String* name <_volatile> 
      		_Bool stillborn <> 
      		long threadLocalRandomSeed <_sun.misc.Contended(value="tlr")> 
      		java.lang.Thread* threadQ <> 
      		java.lang.ThreadGroup* group <> 
      		long stackSize <> 
      		sun.nio.ch.Interruptible* blocker <_volatile> 
      		int threadStatus <_volatile> 
      		int threadLocalRandomSecondarySeed <_sun.misc.Contended(value="tlr")> 
      		_Bool single_step <> 
      		java.lang.ClassLoader* contextClassLoader <> 
      		java.lang.ThreadLocal$ThreadLocalMap* inheritableThreadLocals <> 
      		java.lang.Object* blockerLock <_final> 
      		java.lang.ThreadLocal$ThreadLocalMap* threadLocals <> 
      		int threadLocalRandomProbe <_sun.misc.Contended(value="tlr")> 
      		long eetop <> 
      		int priority <> 
      		long tid <> 
      		_Bool daemon <> 
      		java.lang.Thread$UncaughtExceptionHandler* uncaughtExceptionHandler <_volatile> 
      		long nativeParkEventPointer <> 
      		java.security.AccessControlContext* inheritedAccessControlContext <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.lang.Runnable
      	}
      	methods: {
      		void Thread.<clinit>() 
      		void Thread.sleep(long,int) 
      		long Thread.getId() 
      		void Thread.init(ThreadGroup,Runnable,String,long) 
      		boolean Thread.interrupted() 
      		boolean Thread.isAlive() 
      		void Thread.setPriority0(int) 
      		Thread.<init>(ThreadGroup,Runnable,String) 
      		void Thread.checkAccess() 
      		void Thread.setDaemon(boolean) 
      		void Thread.processQueue(ReferenceQueue,ConcurrentMap) 
      		void Thread.dispatchUncaughtException(Throwable) 
      		void Thread.start() 
      		void Thread.join() 
      		Object Thread.clone() 
      		void Thread.stop() 
      		int Thread.getPriority() 
      		void Thread.destroy() 
      		Thread[] Thread.getThreads() 
      		Thread.<init>(Runnable,AccessControlContext) 
      		Thread.<init>(ThreadGroup,String) 
      		void Thread.setDefaultUncaughtExceptionHandler(Thread$UncaughtExceptionHandler) 
      		void Thread.stop0(Object) 
      		int Thread.countStackFrames() 
      		void Thread.init(ThreadGroup,Runnable,String,long,AccessControlContext,boolean) 
      		void Thread.run() 
      		void Thread.interrupt() 
      		void Thread.join(long) 
      		Thread.<init>() 
      		void Thread.exit() 
      		int Thread.activeCount() 
      		boolean Thread.auditSubclass(Class) 
      		String Thread.getName() 
      		boolean Thread.isDaemon() 
      		void Thread.setName(String) 
      		void Thread.suspend0() 
      		void Thread.setContextClassLoader(ClassLoader) 
      		void Thread.resume() 
      		long Thread.nextThreadID() 
      		void Thread.yield() 
      		Thread$UncaughtExceptionHandler Thread.getUncaughtExceptionHandler() 
      		Thread.<init>(Runnable) 
      		Thread$State Thread.getState() 
      		void Thread.start0() 
      		boolean Thread.isInterrupted() 
      		void Thread.sleep(long) 
      		Thread Thread.currentThread() 
      		int Thread.enumerate(Thread[]) 
      		void Thread.setNativeName(String) 
      		Thread.<init>(ThreadGroup,Runnable,String,long) 
      		boolean Thread.isInterrupted(boolean) 
      		void Thread.dumpStack() 
      		String Thread.toString() 
      		void Thread.suspend() 
      		ThreadGroup Thread.getThreadGroup() 
      		Thread.<init>(ThreadGroup,Runnable) 
      		ClassLoader Thread.getContextClassLoader() 
      		void Thread.setPriority(int) 
      		void Thread.setUncaughtExceptionHandler(Thread$UncaughtExceptionHandler) 
      		Thread$UncaughtExceptionHandler Thread.getDefaultUncaughtExceptionHandler() 
      		Thread.<init>(Runnable,String) 
      		void Thread.interrupt0() 
      		void Thread.join(long,int) 
      		void Thread.registerNatives() 
      		boolean Thread.isCCLOverridden(Class) 
      		boolean Thread.holdsLock(Object) 
      		StackTraceElement[][] Thread.dumpThreads(Thread[]) 
      		Thread.<init>(String) 
      		void Thread.stop(Throwable) 
      		void Thread.resume0() 
      		Map Thread.getAllStackTraces() 
      		int Thread.nextThreadNum() 
      		StackTraceElement[] Thread.getStackTrace() 
      		void Thread.blockedOn(Interruptible)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.ThreadGroup
TYPE: class java.lang.ThreadGroup 
      	fields: {
      		int nthreads <> 
      		java.lang.String* name <> 
      		int nUnstartedThreads <> 
      		_Bool vmAllowSuspension <> 
      		java.lang.ThreadGroup* parent <_final> 
      		int ngroups <> 
      		java.lang.Thread*[_*_](*) threads <> 
      		int maxPriority <> 
      		_Bool destroyed <> 
      		_Bool daemon <> 
      		java.lang.ThreadGroup*[_*_](*) groups <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.lang.Thread$UncaughtExceptionHandler
      	}
      	methods: {
      		void ThreadGroup.list() 
      		void ThreadGroup.remove(Thread) 
      		boolean ThreadGroup.parentOf(ThreadGroup) 
      		void ThreadGroup.checkAccess() 
      		void ThreadGroup.setDaemon(boolean) 
      		void ThreadGroup.stop() 
      		void ThreadGroup.destroy() 
      		int ThreadGroup.enumerate(ThreadGroup[],boolean) 
      		ThreadGroup.<init>(Void,ThreadGroup,String) 
      		ThreadGroup.<init>(ThreadGroup,String) 
      		void ThreadGroup.uncaughtException(Thread,Throwable) 
      		int ThreadGroup.enumerate(ThreadGroup[],int,boolean) 
      		void ThreadGroup.interrupt() 
      		int ThreadGroup.enumerate(Thread[],boolean) 
      		ThreadGroup.<init>() 
      		int ThreadGroup.activeCount() 
      		String ThreadGroup.getName() 
      		boolean ThreadGroup.isDaemon() 
      		void ThreadGroup.resume() 
      		void ThreadGroup.add(Thread) 
      		void ThreadGroup.threadStartFailed(Thread) 
      		Void ThreadGroup.checkParentAccess(ThreadGroup) 
      		boolean ThreadGroup.allowThreadSuspension(boolean) 
      		void ThreadGroup.list(PrintStream,int) 
      		int ThreadGroup.activeGroupCount() 
      		ThreadGroup ThreadGroup.getParent() 
      		int ThreadGroup.enumerate(Thread[]) 
      		void ThreadGroup.setMaxPriority(int) 
      		int ThreadGroup.getMaxPriority() 
      		String ThreadGroup.toString() 
      		void ThreadGroup.suspend() 
      		void ThreadGroup.addUnstarted() 
      		void ThreadGroup.add(ThreadGroup) 
      		boolean ThreadGroup.stopOrSuspend(boolean) 
      		int ThreadGroup.enumerate(ThreadGroup[]) 
      		ThreadGroup.<init>(String) 
      		int ThreadGroup.enumerate(Thread[],int,boolean) 
      		boolean ThreadGroup.isDestroyed() 
      		void ThreadGroup.remove(ThreadGroup) 
      		void ThreadGroup.threadTerminated(Thread)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.ListIterator
TYPE: class java.util.ListIterator 
      	fields: {
      	}
      	supers: {
      		class java.util.Iterator
      	}
      	methods: {
      		int ListIterator.previousIndex() 
      		void ListIterator.add(Object) 
      		Object ListIterator.previous() 
      		boolean ListIterator.hasNext() 
      		boolean ListIterator.hasPrevious() 
      		int ListIterator.nextIndex() 
      		Object ListIterator.next() 
      		void ListIterator.remove() 
      		void ListIterator.set(Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.helpers.CategoryHelper
TYPE: class com.stn.helpers.CategoryHelper 
      	fields: {
      		java.lang.String* dbUser <> 
      		java.sql.PreparedStatement* preparedStatement <> 
      		java.lang.String* query <> 
      		java.lang.String* dbPort <> 
      		java.lang.String* dbHost <> 
      		java.lang.String* dbPassword <> 
      		java.sql.ResultSet* resultSet <> 
      		java.sql.Connection* connection <> 
      		java.lang.String* dbName <>
      	}
      	supers: {
      		class com.stn.utils.DBConnection
      	}
      	methods: {
      		void CategoryHelper.addCategory(String,String,int,int,int,int) 
      		List CategoryHelper.getCategories(int) 
      		CategoryHelper.<init>()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.TimeZone
TYPE: class java.util.TimeZone 
      	fields: {
      		java.lang.String* ID <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable 
      		class java.lang.Cloneable
      	}
      	methods: {
      		void TimeZone.<clinit>() 
      		TimeZone TimeZone.getTimeZone(ZoneId) 
      		int TimeZone.getOffsets(long,int[]) 
      		void TimeZone.setRawOffset(int) 
      		TimeZone TimeZone.getDefault() 
      		String TimeZone.getDisplayName(boolean,int,Locale) 
      		Object TimeZone.clone() 
      		String[] TimeZone.getAvailableIDs() 
      		String TimeZone.getDisplayName(Locale) 
      		boolean TimeZone.inDaylightTime(Date) 
      		String TimeZone.getID() 
      		TimeZone TimeZone.parseCustomTimeZone(String) 
      		void TimeZone.setDefault(TimeZone) 
      		TimeZone TimeZone.getDefaultRef() 
      		TimeZone.<init>() 
      		TimeZone TimeZone.getTimeZone(String,boolean) 
      		String[] TimeZone.getDisplayNames(String,Locale) 
      		String TimeZone.getSystemTimeZoneID(String) 
      		boolean TimeZone.hasSameRules(TimeZone) 
      		void TimeZone.setID(String) 
      		ZoneId TimeZone.toZoneId() 
      		int TimeZone.getOffset(long) 
      		int TimeZone.getDSTSavings() 
      		boolean TimeZone.useDaylightTime() 
      		String TimeZone.getDisplayName(boolean,int) 
      		TimeZone TimeZone.setDefaultZone() 
      		String TimeZone.getDisplayName() 
      		int TimeZone.getRawOffset() 
      		int TimeZone.getOffset(int,int,int,int,int,int) 
      		String[] TimeZone.getAvailableIDs(int) 
      		boolean TimeZone.observesDaylightTime() 
      		String TimeZone.getSystemGMTOffsetID() 
      		TimeZone TimeZone.getTimeZone(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.time.temporal.TemporalAccessor
TYPE: class java.time.temporal.TemporalAccessor 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		int TemporalAccessor.get(TemporalField) 
      		Object TemporalAccessor.query(TemporalQuery) 
      		ValueRange TemporalAccessor.range(TemporalField) 
      		long TemporalAccessor.getLong(TemporalField) 
      		boolean TemporalAccessor.isSupported(TemporalField)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.SQLType
TYPE: class java.sql.SQLType 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Integer SQLType.getVendorTypeNumber() 
      		String SQLType.getName() 
      		String SQLType.getVendor()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.Transport
TYPE: class javax.mail.Transport 
      	fields: {
      		java.util.Vector* transportListeners <_volatile> 
      		java.util.Vector* connectionListeners <_final> 
      		javax.mail.Session* session <> 
      		javax.mail.EventQueue* q <> 
      		javax.mail.URLName* url <> 
      		java.lang.Object* qLock <> 
      		_Bool debug <> 
      		_Bool connected <>
      	}
      	supers: {
      		class javax.mail.Service
      	}
      	methods: {
      		void Transport.send(Message) 
      		void Transport.send(Message,String,String) 
      		void Transport.notifyTransportListeners(int,Address[],Address[],Address[],Message) 
      		Transport.<init>(Session,URLName) 
      		void Transport.addTransportListener(TransportListener) 
      		void Transport.send(Message,Address[],String,String) 
      		void Transport.send0(Message,Address[],String,String) 
      		void Transport.removeTransportListener(TransportListener) 
      		void Transport.send(Message,Address[]) 
      		void Transport.sendMessage(Message,Address[])
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.Wrapper
TYPE: class java.sql.Wrapper 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Object Wrapper.unwrap(Class) 
      		boolean Wrapper.isWrapperFor(Class)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.ObjectStreamClass
TYPE: class java.io.ObjectStreamClass 
      	fields: {
      		_Bool isEnum <> 
      		java.lang.String* name <> 
      		java.lang.reflect.Method* readObjectMethod <> 
      		_Bool isProxy <> 
      		java.lang.reflect.Method* writeReplaceMethod <> 
      		int primDataSize <> 
      		java.io.ObjectStreamClass$ExceptionInfo* deserializeEx <> 
      		_Bool initialized <> 
      		java.io.ObjectStreamClass$ExceptionInfo* defaultSerializeEx <> 
      		java.lang.reflect.Constructor* cons <> 
      		java.io.ObjectStreamClass* superDesc <> 
      		_Bool hasWriteObjectData <> 
      		java.io.ObjectStreamClass$ClassDataSlot*[_*_](*) dataLayout <_volatile> 
      		java.io.ObjectStreamField*[_*_](*) fields <> 
      		java.lang.Class* cl <> 
      		java.io.ObjectStreamClass$FieldReflector* fieldRefl <> 
      		java.lang.reflect.Method* writeObjectMethod <> 
      		_Bool serializable <> 
      		java.security.ProtectionDomain*[_*_](*) domains <> 
      		int numObjFields <> 
      		java.io.ObjectStreamClass$ExceptionInfo* serializeEx <> 
      		_Bool hasBlockExternalData <> 
      		java.lang.reflect.Method* readResolveMethod <> 
      		java.lang.ClassNotFoundException* resolveEx <> 
      		_Bool externalizable <> 
      		java.io.ObjectStreamClass* localDesc <> 
      		java.lang.reflect.Method* readObjectNoDataMethod <> 
      		java.lang.Long* suid <_volatile>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable
      	}
      	methods: {
      		void ObjectStreamClass.<clinit>() 
      		Long ObjectStreamClass.getDeclaredSUID(Class) 
      		ObjectStreamClass$ExceptionInfo ObjectStreamClass.access$1102(ObjectStreamClass,ObjectStreamClass$ExceptionInfo) 
      		Method ObjectStreamClass.access$2502(ObjectStreamClass,Method) 
      		boolean ObjectStreamClass.hasReadObjectMethod() 
      		void ObjectStreamClass.initNative() 
      		Method ObjectStreamClass.access$1902(ObjectStreamClass,Method) 
      		void ObjectStreamClass.throwMiscException(Throwable) 
      		void ObjectStreamClass.getObjFieldValues(Object,Object[]) 
      		long ObjectStreamClass.access$100(Class) 
      		String ObjectStreamClass.getClassSignature(Class) 
      		ObjectStreamField ObjectStreamClass.getField(String,Class) 
      		Constructor ObjectStreamClass.access$1500(Class) 
      		ObjectStreamClass.<init>(Class) 
      		void ObjectStreamClass.processQueue(ReferenceQueue,ConcurrentMap) 
      		int ObjectStreamClass.getPrimDataSize() 
      		PrivilegedAction ObjectStreamClass.callsite_java.io.ObjectStreamClass$Lambda$_94_43(ObjectStreamClass) 
      		ObjectStreamField ObjectStreamClass.getField(String) 
      		boolean ObjectStreamClass.hasWriteObjectData() 
      		Constructor ObjectStreamClass.access$1300(ObjectStreamClass) 
      		ObjectStreamField[] ObjectStreamClass.matchFields(ObjectStreamField[],ObjectStreamClass) 
      		Object ObjectStreamClass.invokeWriteReplace(Object) 
      		Long ObjectStreamClass.access$700(Class) 
      		void ObjectStreamClass.initNonProxy(ObjectStreamClass,Class,ClassNotFoundException,ObjectStreamClass) 
      		Constructor ObjectStreamClass.getSerializableConstructor(Class) 
      		Constructor ObjectStreamClass.access$1302(ObjectStreamClass,Constructor) 
      		ObjectStreamField[] ObjectStreamClass.getDeclaredSerialFields(Class) 
      		String ObjectStreamClass.access$2700(Class[],Class) 
      		boolean ObjectStreamClass.hasReadObjectNoDataMethod() 
      		ObjectStreamClass ObjectStreamClass.lookup(Class) 
      		boolean ObjectStreamClass.isExternalizable() 
      		Method ObjectStreamClass.access$1600(ObjectStreamClass) 
      		boolean ObjectStreamClass.hasReadResolveMethod() 
      		ObjectStreamClass ObjectStreamClass.lookup(Class,boolean) 
      		Long ObjectStreamClass.access$502(ObjectStreamClass,Long) 
      		ObjectStreamClass ObjectStreamClass.getSuperDesc() 
      		ProtectionDomain[] ObjectStreamClass.getProtectionDomains(Constructor,Class) 
      		ObjectStreamClass.<init>() 
      		Method ObjectStreamClass.access$1700(Class,String,Class[],Class) 
      		void ObjectStreamClass.checkDeserialize() 
      		String ObjectStreamClass.getName() 
      		ObjectStreamField[] ObjectStreamClass.getFields(boolean) 
      		boolean ObjectStreamClass.isSerializable() 
      		Class ObjectStreamClass.forClass() 
      		boolean ObjectStreamClass.classNamesEqual(String,String) 
      		ObjectStreamClass$ClassDataSlot[] ObjectStreamClass.getClassDataLayout() 
      		Method ObjectStreamClass.access$2302(ObjectStreamClass,Method) 
      		boolean ObjectStreamClass.hasBlockExternalData() 
      		boolean ObjectStreamClass.packageEquals(Class,Class) 
      		void ObjectStreamClass.access$900(ObjectStreamClass) 
      		void ObjectStreamClass.computeFieldOffsets() 
      		long ObjectStreamClass.computeDefaultSUID(Class) 
      		boolean ObjectStreamClass.access$1200(ObjectStreamClass) 
      		String ObjectStreamClass.getPackageName(Class) 
      		void ObjectStreamClass.invokeWriteObject(Object,ObjectOutputStream) 
      		String ObjectStreamClass.access$2600(Class) 
      		void ObjectStreamClass.invokeReadObject(Object,ObjectInputStream) 
      		Object ObjectStreamClass.lambda$newInstance$0() 
      		ClassNotFoundException ObjectStreamClass.getResolveException() 
      		void ObjectStreamClass.checkSerialize() 
      		boolean ObjectStreamClass.access$2002(ObjectStreamClass,boolean) 
      		ObjectStreamClass$ClassDataSlot[] ObjectStreamClass.getClassDataLayout0() 
      		boolean ObjectStreamClass.access$400(ObjectStreamClass) 
      		void ObjectStreamClass.initProxy(Class,ClassNotFoundException,ObjectStreamClass) 
      		Method ObjectStreamClass.getInheritableMethod(Class,String,Class[],Class) 
      		long ObjectStreamClass.getSerialVersionUID() 
      		Method ObjectStreamClass.access$1602(ObjectStreamClass,Method) 
      		void ObjectStreamClass.getPrimFieldValues(Object,byte[]) 
      		Object ObjectStreamClass.access_java.io.ObjectStreamClass$Lambda$_94_43(ObjectStreamClass) 
      		void ObjectStreamClass.setPrimFieldValues(Object,byte[]) 
      		ObjectStreamClass ObjectStreamClass.getLocalDesc() 
      		ProtectionDomain ObjectStreamClass.noPermissionsDomain() 
      		String ObjectStreamClass.toString() 
      		ProtectionDomain[] ObjectStreamClass.access$2200(ObjectStreamClass,Constructor,Class) 
      		boolean ObjectStreamClass.isEnum() 
      		void ObjectStreamClass.writeNonProxy(ObjectOutputStream) 
      		ObjectStreamField[] ObjectStreamClass.access$800(Class) 
      		Object ObjectStreamClass.newInstance() 
      		Constructor ObjectStreamClass.getExternalizableConstructor(Class) 
      		void ObjectStreamClass.requireInitialized() 
      		Constructor ObjectStreamClass.access$1400(Class) 
      		ObjectStreamField[] ObjectStreamClass.getDefaultSerialFields(Class) 
      		void ObjectStreamClass.checkDefaultSerialize() 
      		void ObjectStreamClass.readNonProxy(ObjectInputStream) 
      		void ObjectStreamClass.invokeReadObjectNoData(Object) 
      		ObjectStreamClass ObjectStreamClass.lookupAny(Class) 
      		boolean ObjectStreamClass.isProxy() 
      		ObjectStreamClass$FieldReflector ObjectStreamClass.getReflector(ObjectStreamField[],ObjectStreamClass) 
      		ProtectionDomain[] ObjectStreamClass.access$2102(ObjectStreamClass,ProtectionDomain[]) 
      		Object ObjectStreamClass.invokeReadResolve(Object) 
      		boolean ObjectStreamClass.hasWriteReplaceMethod() 
      		ObjectStreamClass ObjectStreamClass.getVariantFor(Class) 
      		ObjectStreamField[] ObjectStreamClass.access$602(ObjectStreamClass,ObjectStreamField[]) 
      		Method ObjectStreamClass.getPrivateMethod(Class,String,Class[],Class) 
      		Method ObjectStreamClass.access$1802(ObjectStreamClass,Method) 
      		boolean ObjectStreamClass.isInstantiable() 
      		boolean ObjectStreamClass.hasStaticInitializer(Class) 
      		int ObjectStreamClass.getNumObjFields() 
      		void ObjectStreamClass.setObjFieldValues(Object,Object[]) 
      		Class ObjectStreamClass.access$000(ObjectStreamClass) 
      		String ObjectStreamClass.getMethodSignature(Class[],Class) 
      		ObjectStreamField[] ObjectStreamClass.getFields() 
      		boolean ObjectStreamClass.hasWriteObjectMethod() 
      		Method ObjectStreamClass.access$2400(Class,String,Class[],Class) 
      		boolean ObjectStreamClass.superHasAccessibleConstructor(Class) 
      		ObjectStreamClass$ExceptionInfo ObjectStreamClass.access$1002(ObjectStreamClass,ObjectStreamClass$ExceptionInfo) 
      		ObjectStreamField[] ObjectStreamClass.getSerialFields(Class)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.management.ObjectInstance
TYPE: class javax.management.ObjectInstance 
      	fields: {
      		java.lang.String* className <> 
      		javax.management.ObjectName* name <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable
      	}
      	methods: {
      		int ObjectInstance.hashCode() 
      		ObjectInstance.<init>(ObjectName,String) 
      		boolean ObjectInstance.equals(Object) 
      		ObjectInstance.<init>(String,String) 
      		ObjectName ObjectInstance.getObjectName() 
      		String ObjectInstance.toString() 
      		String ObjectInstance.getClassName()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.pojo.Country
TYPE: class com.stn.pojo.Country 
      	fields: {
      		int countryId <> 
      		java.lang.String* countryImage <> 
      		java.lang.String* countryName <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Country.setCountryName(String) 
      		String Country.getCountryName() 
      		Country.<init>() 
      		void Country.setCountryId(int) 
      		int Country.getCountryId() 
      		void Country.setCountryImage(String) 
      		String Country.getCountryImage()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.RowId
TYPE: class java.sql.RowId 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		int RowId.hashCode() 
      		boolean RowId.equals(Object) 
      		String RowId.toString() 
      		byte[] RowId.getBytes()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.StringBuffer
TYPE: class java.lang.StringBuffer 
      	fields: {
      		unsigned short[_*_](*) toStringCache <> 
      		int count <> 
      		unsigned short[_*_](*) value <>
      	}
      	supers: {
      		class java.lang.AbstractStringBuilder 
      		class java.io.Serializable 
      		class java.lang.CharSequence
      	}
      	methods: {
      		void StringBuffer.<clinit>() 
      		AbstractStringBuilder StringBuffer.insert(int,Object) 
      		StringBuffer.<init>(int) 
      		void StringBuffer.getChars(int,int,char[],int) 
      		StringBuffer StringBuffer.append(StringBuffer) 
      		StringBuffer StringBuffer.append(char) 
      		StringBuffer StringBuffer.insert(int,char[]) 
      		AbstractStringBuilder StringBuffer.append(AbstractStringBuilder) 
      		AbstractStringBuilder StringBuffer.append(StringBuffer) 
      		StringBuffer StringBuffer.insert(int,double) 
      		AbstractStringBuilder StringBuffer.insert(int,long) 
      		void StringBuffer.ensureCapacity(int) 
      		String StringBuffer.substring(int,int) 
      		StringBuffer StringBuffer.append(double) 
      		AbstractStringBuilder StringBuffer.append(long) 
      		AbstractStringBuilder StringBuffer.insert(int,CharSequence,int,int) 
      		StringBuffer StringBuffer.replace(int,int,String) 
      		char StringBuffer.charAt(int) 
      		AbstractStringBuilder StringBuffer.append(char[],int,int) 
      		StringBuffer StringBuffer.insert(int,char) 
      		int StringBuffer.indexOf(String) 
      		StringBuffer StringBuffer.append(boolean) 
      		AbstractStringBuilder StringBuffer.delete(int,int) 
      		AbstractStringBuilder StringBuffer.insert(int,char[]) 
      		void StringBuffer.writeObject(ObjectOutputStream) 
      		StringBuffer StringBuffer.insert(int,Object) 
      		String StringBuffer.substring(int) 
      		AbstractStringBuilder StringBuffer.append(CharSequence,int,int) 
      		StringBuffer StringBuffer.insert(int,long) 
      		AbstractStringBuilder StringBuffer.insert(int,double) 
      		AbstractStringBuilder StringBuffer.append(Object) 
      		StringBuffer StringBuffer.append(long) 
      		AbstractStringBuilder StringBuffer.append(double) 
      		StringBuffer.<init>() 
      		StringBuffer StringBuffer.append(CharSequence) 
      		AbstractStringBuilder StringBuffer.insert(int,char) 
      		void StringBuffer.setLength(int) 
      		int StringBuffer.codePointCount(int,int) 
      		StringBuffer StringBuffer.appendCodePoint(int) 
      		AbstractStringBuilder StringBuffer.append(char) 
      		StringBuffer StringBuffer.insert(int,CharSequence,int,int) 
      		StringBuffer StringBuffer.append(CharSequence,int,int) 
      		Appendable StringBuffer.append(CharSequence,int,int) 
      		AbstractStringBuilder StringBuffer.replace(int,int,String) 
      		AbstractStringBuilder StringBuffer.insert(int,String) 
      		void StringBuffer.readObject(ObjectInputStream) 
      		StringBuffer StringBuffer.append(Object) 
      		StringBuffer StringBuffer.append(char[],int,int) 
      		StringBuffer StringBuffer.insert(int,String) 
      		AbstractStringBuilder StringBuffer.append(CharSequence) 
      		StringBuffer StringBuffer.insert(int,float) 
      		AbstractStringBuilder StringBuffer.insert(int,float) 
      		int StringBuffer.capacity() 
      		StringBuffer StringBuffer.append(float) 
      		AbstractStringBuilder StringBuffer.append(float) 
      		int StringBuffer.codePointAt(int) 
      		AbstractStringBuilder StringBuffer.insert(int,boolean) 
      		void StringBuffer.setCharAt(int,char) 
      		int StringBuffer.lastIndexOf(String,int) 
      		int StringBuffer.codePointBefore(int) 
      		StringBuffer StringBuffer.deleteCharAt(int) 
      		AbstractStringBuilder StringBuffer.append(boolean) 
      		int StringBuffer.lastIndexOf(String) 
      		StringBuffer StringBuffer.insert(int,boolean) 
      		String StringBuffer.toString() 
      		StringBuffer StringBuffer.append(char[]) 
      		Appendable StringBuffer.append(char) 
      		AbstractStringBuilder StringBuffer.deleteCharAt(int) 
      		AbstractStringBuilder StringBuffer.insert(int,CharSequence) 
      		StringBuffer StringBuffer.append(String) 
      		int StringBuffer.indexOf(String,int) 
      		int StringBuffer.length() 
      		StringBuffer StringBuffer.insert(int,char[],int,int) 
      		AbstractStringBuilder StringBuffer.append(char[]) 
      		StringBuffer StringBuffer.insert(int,int) 
      		AbstractStringBuilder StringBuffer.reverse() 
      		StringBuffer StringBuffer.append(int) 
      		AbstractStringBuilder StringBuffer.appendCodePoint(int) 
      		StringBuffer.<init>(String) 
      		StringBuffer StringBuffer.reverse() 
      		AbstractStringBuilder StringBuffer.insert(int,int) 
      		void StringBuffer.trimToSize() 
      		int StringBuffer.offsetByCodePoints(int,int) 
      		StringBuffer StringBuffer.delete(int,int) 
      		AbstractStringBuilder StringBuffer.append(int) 
      		StringBuffer.<init>(CharSequence) 
      		StringBuffer StringBuffer.insert(int,CharSequence) 
      		CharSequence StringBuffer.subSequence(int,int) 
      		AbstractStringBuilder StringBuffer.append(String) 
      		StringBuffer StringBuffer.append(AbstractStringBuilder) 
      		Appendable StringBuffer.append(CharSequence) 
      		AbstractStringBuilder StringBuffer.insert(int,char[],int,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.AbstractCollection
TYPE: class java.util.AbstractCollection 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object 
      		class java.util.Collection
      	}
      	methods: {
      		boolean AbstractCollection.removeAll(Collection) 
      		Object[] AbstractCollection.finishToArray(Object[],Iterator) 
      		int AbstractCollection.size() 
      		Iterator AbstractCollection.iterator() 
      		boolean AbstractCollection.contains(Object) 
      		Object[] AbstractCollection.toArray() 
      		boolean AbstractCollection.containsAll(Collection) 
      		Object[] AbstractCollection.toArray(Object[]) 
      		AbstractCollection.<init>() 
      		boolean AbstractCollection.remove(Object) 
      		boolean AbstractCollection.retainAll(Collection) 
      		boolean AbstractCollection.addAll(Collection) 
      		String AbstractCollection.toString() 
      		int AbstractCollection.hugeCapacity(int) 
      		boolean AbstractCollection.add(Object) 
      		boolean AbstractCollection.isEmpty() 
      		void AbstractCollection.clear()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.Closeable
TYPE: class java.io.Closeable 
      	fields: {
      	}
      	supers: {
      		class java.lang.AutoCloseable
      	}
      	methods: {
      		void Closeable.close()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.Flags
TYPE: class javax.mail.Flags 
      	fields: {
      		int system_flags <> 
      		java.util.Hashtable* user_flags <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.lang.Cloneable 
      		class java.io.Serializable
      	}
      	methods: {
      		int Flags.hashCode() 
      		Flags$Flag[] Flags.getSystemFlags() 
      		void Flags.add(Flags) 
      		boolean Flags.equals(Object) 
      		void Flags.remove(Flags$Flag) 
      		Object Flags.clone() 
      		void Flags.add(Flags$Flag) 
      		boolean Flags.contains(Flags$Flag) 
      		Flags.<init>() 
      		boolean Flags.contains(String) 
      		Flags.<init>(Flags) 
      		String[] Flags.getUserFlags() 
      		void Flags.remove(Flags) 
      		void Flags.remove(String) 
      		void Flags.add(String) 
      		Flags.<init>(Flags$Flag) 
      		Flags.<init>(String) 
      		boolean Flags.contains(Flags)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.pojo.Category
TYPE: class com.stn.pojo.Category 
      	fields: {
      		int idSerie <> 
      		int id <> 
      		int idFacultate <> 
      		java.lang.String* categorie <> 
      		int totalTopics <> 
      		int pinned <> 
      		int idGrupa <> 
      		java.lang.String* descriere <> 
      		int totalPosts <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Category.setPinned(int) 
      		int Category.getTotalTopics() 
      		void Category.setTotalTopics(int) 
      		Category.<init>(int,int,String,String,int,int,int) 
      		void Category.setIdFacultate(int) 
      		int Category.getIdSerie() 
      		Category.<init>() 
      		int Category.getId() 
      		String Category.getCategorie() 
      		void Category.setDescriere(String) 
      		int Category.getTotalPosts() 
      		int Category.getIdGrupa() 
      		void Category.setIdSerie(int) 
      		void Category.setId(int) 
      		void Category.setTotalPosts(int) 
      		int Category.getPinned() 
      		void Category.setIdGrupa(int) 
      		int Category.getIdFacultate() 
      		String Category.getDescriere() 
      		void Category.setCategorie(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.http.HttpSession
TYPE: class javax.servlet.http.HttpSession 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		int HttpSession.getMaxInactiveInterval() 
      		long HttpSession.getCreationTime() 
      		void HttpSession.putValue(String,Object) 
      		void HttpSession.removeAttribute(String) 
      		Object HttpSession.getAttribute(String) 
      		Object HttpSession.getValue(String) 
      		long HttpSession.getLastAccessedTime() 
      		void HttpSession.setAttribute(String,Object) 
      		boolean HttpSession.isNew() 
      		void HttpSession.invalidate() 
      		HttpSessionContext HttpSession.getSessionContext() 
      		String HttpSession.getId() 
      		void HttpSession.removeValue(String) 
      		ServletContext HttpSession.getServletContext() 
      		String[] HttpSession.getValueNames() 
      		void HttpSession.setMaxInactiveInterval(int) 
      		Enumeration HttpSession.getAttributeNames()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.stream.IntStream
TYPE: class java.util.stream.IntStream 
      	fields: {
      	}
      	supers: {
      		class java.util.stream.BaseStream
      	}
      	methods: {
      		IntStream IntStream.limit(long) 
      		boolean IntStream.noneMatch(IntPredicate) 
      		int IntStream.sum() 
      		IntStream IntStream.of(int[]) 
      		IntStream IntStream.map(IntUnaryOperator) 
      		int[] IntStream.toArray() 
      		DoubleStream IntStream.asDoubleStream() 
      		IntStream IntStream.parallel() 
      		OptionalDouble IntStream.average() 
      		IntStream IntStream.rangeClosed(int,int) 
      		IntStream IntStream.flatMap(IntFunction) 
      		Iterator IntStream.iterator() 
      		void IntStream.forEach(IntConsumer) 
      		OptionalInt IntStream.findAny() 
      		OptionalInt IntStream.max() 
      		IntStream IntStream.generate(IntSupplier) 
      		LongStream IntStream.mapToLong(IntToLongFunction) 
      		OptionalInt IntStream.reduce(IntBinaryOperator) 
      		IntStream$Builder IntStream.builder() 
      		PrimitiveIterator$OfInt IntStream.iterator() 
      		boolean IntStream.anyMatch(IntPredicate) 
      		BaseStream IntStream.parallel() 
      		IntStream IntStream.sorted() 
      		IntStream IntStream.skip(long) 
      		OptionalInt IntStream.findFirst() 
      		OptionalInt IntStream.min() 
      		Spliterator IntStream.spliterator() 
      		IntStream IntStream.iterate(int,IntUnaryOperator) 
      		Stream IntStream.mapToObj(IntFunction) 
      		int IntStream.reduce(int,IntBinaryOperator) 
      		Stream IntStream.boxed() 
      		IntStream IntStream.sequential() 
      		IntSummaryStatistics IntStream.summaryStatistics() 
      		IntStream IntStream.empty() 
      		IntStream IntStream.concat(IntStream,IntStream) 
      		IntStream IntStream.distinct() 
      		void IntStream.forEachOrdered(IntConsumer) 
      		LongStream IntStream.asLongStream() 
      		long IntStream.count() 
      		IntStream IntStream.range(int,int) 
      		DoubleStream IntStream.mapToDouble(IntToDoubleFunction) 
      		Object IntStream.collect(Supplier,ObjIntConsumer,BiConsumer) 
      		IntStream IntStream.of(int) 
      		IntStream IntStream.filter(IntPredicate) 
      		boolean IntStream.allMatch(IntPredicate) 
      		Spliterator$OfInt IntStream.spliterator() 
      		BaseStream IntStream.sequential() 
      		IntStream IntStream.peek(IntConsumer)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.ObjectOutputStream
TYPE: class java.io.ObjectOutputStream 
      	fields: {
      		java.io.DataOutputStream* output <> 
      		java.io.SerialCallbackContext* curContext <> 
      		java.io.ObjectOutputStream$ReplaceTable* subs <_final> 
      		_Bool enableReplace <> 
      		int protocol <> 
      		java.io.ObjectOutputStream$PutFieldImpl* curPut <> 
      		java.io.ObjectOutputStream$BlockDataOutputStream* bout <_final> 
      		_Bool enableOverride <_final> 
      		java.io.ObjectOutputStream$HandleTable* handles <_final> 
      		signed char[_*_](*) primVals <> 
      		java.io.ObjectOutputStream$DebugTraceInfoStack* debugInfoStack <_final> 
      		int depth <>
      	}
      	supers: {
      		class java.io.OutputStream 
      		class java.io.ObjectOutput 
      		class java.io.ObjectStreamConstants
      	}
      	methods: {
      		void ObjectOutputStream.<clinit>() 
      		boolean ObjectOutputStream.access$100() 
      		void ObjectOutputStream.writeNull() 
      		void ObjectOutputStream.writeUnshared(Object) 
      		void ObjectOutputStream.writeInt(int) 
      		void ObjectOutputStream.writeEnum(Enum,ObjectStreamClass,boolean) 
      		void ObjectOutputStream.writeClass(Class,boolean) 
      		void ObjectOutputStream.writeFatalException(IOException) 
      		void ObjectOutputStream.access$500(double[],int,byte[],int,int) 
      		void ObjectOutputStream.write(byte[]) 
      		void ObjectOutputStream.verifySubclass() 
      		void ObjectOutputStream.writeBytes(String) 
      		void ObjectOutputStream.writeProxyDesc(ObjectStreamClass,boolean) 
      		void ObjectOutputStream.writeSerialData(Object,ObjectStreamClass) 
      		void ObjectOutputStream.writeBoolean(boolean) 
      		boolean ObjectOutputStream.enableReplaceObject(boolean) 
      		void ObjectOutputStream.annotateClass(Class) 
      		void ObjectOutputStream.access$300(ObjectOutputStream,Object,boolean) 
      		void ObjectOutputStream.writeHandle(int) 
      		void ObjectOutputStream.write(int) 
      		void ObjectOutputStream.floatsToBytes(float[],int,byte[],int,int) 
      		void ObjectOutputStream.writeFloat(float) 
      		void ObjectOutputStream.close() 
      		ObjectOutputStream$PutField ObjectOutputStream.putFields() 
      		ObjectOutputStream.<init>() 
      		boolean ObjectOutputStream.auditSubclass(Class) 
      		void ObjectOutputStream.writeUTF(String) 
      		void ObjectOutputStream.writeFields() 
      		void ObjectOutputStream.writeShort(int) 
      		void ObjectOutputStream.writeTypeString(String) 
      		ObjectOutputStream$DebugTraceInfoStack ObjectOutputStream.access$200(ObjectOutputStream) 
      		void ObjectOutputStream.flush() 
      		void ObjectOutputStream.doublesToBytes(double[],int,byte[],int,int) 
      		void ObjectOutputStream.writeLong(long) 
      		void ObjectOutputStream.writeOrdinaryObject(Object,ObjectStreamClass,boolean) 
      		void ObjectOutputStream.writeClassDesc(ObjectStreamClass,boolean) 
      		void ObjectOutputStream.annotateProxyClass(Class) 
      		void ObjectOutputStream.writeStreamHeader() 
      		void ObjectOutputStream.writeChars(String) 
      		void ObjectOutputStream.writeNonProxyDesc(ObjectStreamClass,boolean) 
      		void ObjectOutputStream.defaultWriteObject() 
      		void ObjectOutputStream.writeByte(int) 
      		Object ObjectOutputStream.replaceObject(Object) 
      		int ObjectOutputStream.getProtocolVersion() 
      		void ObjectOutputStream.access$400(float[],int,byte[],int,int) 
      		void ObjectOutputStream.writeString(String,boolean) 
      		void ObjectOutputStream.write(byte[],int,int) 
      		void ObjectOutputStream.writeObject0(Object,boolean) 
      		void ObjectOutputStream.writeDouble(double) 
      		void ObjectOutputStream.writeExternalData(Externalizable) 
      		void ObjectOutputStream.useProtocolVersion(int) 
      		void ObjectOutputStream.defaultWriteFields(Object,ObjectStreamClass) 
      		void ObjectOutputStream.reset() 
      		void ObjectOutputStream.writeClassDescriptor(ObjectStreamClass) 
      		void ObjectOutputStream.clear() 
      		void ObjectOutputStream.writeObjectOverride(Object) 
      		boolean ObjectOutputStream.isCustomSubclass() 
      		ObjectOutputStream.<init>(OutputStream) 
      		void ObjectOutputStream.writeObject(Object) 
      		void ObjectOutputStream.writeChar(int) 
      		void ObjectOutputStream.writeArray(Object,ObjectStreamClass,boolean) 
      		ObjectOutputStream$BlockDataOutputStream ObjectOutputStream.access$000(ObjectOutputStream) 
      		void ObjectOutputStream.drain()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Locale$FilteringMode
TYPE: class java.util.Locale$FilteringMode 
      	fields: {
      		java.lang.String* name <_final> 
      		int ordinal <_final>
      	}
      	supers: {
      		class java.lang.Enum
      	}
      	methods: {
      		void Locale$FilteringMode.<clinit>() 
      		Locale$FilteringMode.<init>(String,int) 
      		Locale$FilteringMode[] Locale$FilteringMode.values() 
      		Locale$FilteringMode Locale$FilteringMode.valueOf(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.Function
TYPE: class java.util.function.Function 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Object Function.apply(Object) 
      		Object Function.lambda$identity$2(Object) 
      		Function Function.callsite_java.util.function.Function$Lambda$_3_0() 
      		Function Function.andThen(Function) 
      		Function Function.callsite_java.util.function.Function$Lambda$_2_7(Function,Function) 
      		Object Function.lambda$compose$0(Function,Object) 
      		Function Function.compose(Function) 
      		Object Function.access_java.util.function.Function$Lambda$_3_0(Object) 
      		Object Function.access_java.util.function.Function$Lambda$_1_7(Function,Function,Object) 
      		Function Function.callsite_java.util.function.Function$Lambda$_1_7(Function,Function) 
      		Function Function.identity() 
      		Object Function.access_java.util.function.Function$Lambda$_2_7(Function,Function,Object) 
      		Object Function.lambda$andThen$1(Function,Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.util.stream.LongStream
TYPE: class java.util.stream.LongStream 
      	fields: {
      	}
      	supers: {
      		class java.util.stream.BaseStream
      	}
      	methods: {
      		boolean LongStream.anyMatch(LongPredicate) 
      		LongStream LongStream.empty() 
      		LongStream LongStream.flatMap(LongFunction) 
      		LongStream LongStream.iterate(long,LongUnaryOperator) 
      		LongStream LongStream.parallel() 
      		long[] LongStream.toArray() 
      		OptionalLong LongStream.findAny() 
      		DoubleStream LongStream.asDoubleStream() 
      		LongStream LongStream.limit(long) 
      		OptionalDouble LongStream.average() 
      		LongStream LongStream.map(LongUnaryOperator) 
      		long LongStream.sum() 
      		Iterator LongStream.iterator() 
      		boolean LongStream.noneMatch(LongPredicate) 
      		LongStream LongStream.range(long,long) 
      		LongStream LongStream.sorted() 
      		PrimitiveIterator$OfLong LongStream.iterator() 
      		OptionalLong LongStream.reduce(LongBinaryOperator) 
      		LongStream LongStream.of(long) 
      		Spliterator$OfLong LongStream.spliterator() 
      		void LongStream.forEach(LongConsumer) 
      		IntStream LongStream.mapToInt(LongToIntFunction) 
      		BaseStream LongStream.parallel() 
      		OptionalLong LongStream.max() 
      		boolean LongStream.allMatch(LongPredicate) 
      		LongStream LongStream.distinct() 
      		LongStream LongStream.generate(LongSupplier) 
      		Spliterator LongStream.spliterator() 
      		LongStream LongStream.sequential() 
      		long LongStream.reduce(long,LongBinaryOperator) 
      		LongStream$Builder LongStream.builder() 
      		LongStream LongStream.rangeClosed(long,long) 
      		Stream LongStream.boxed() 
      		LongStream LongStream.skip(long) 
      		Stream LongStream.mapToObj(LongFunction) 
      		OptionalLong LongStream.min() 
      		OptionalLong LongStream.findFirst() 
      		LongStream LongStream.concat(LongStream,LongStream) 
      		LongStream LongStream.peek(LongConsumer) 
      		long LongStream.count() 
      		LongStream LongStream.filter(LongPredicate) 
      		Object LongStream.collect(Supplier,ObjLongConsumer,BiConsumer) 
      		LongStream LongStream.of(long[]) 
      		void LongStream.forEachOrdered(LongConsumer) 
      		DoubleStream LongStream.mapToDouble(LongToDoubleFunction) 
      		BaseStream LongStream.sequential() 
      		LongSummaryStatistics LongStream.summaryStatistics()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.management.Attribute
TYPE: class javax.management.Attribute 
      	fields: {
      		java.lang.String* name <> 
      		java.lang.Object* value <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable
      	}
      	methods: {
      		int Attribute.hashCode() 
      		boolean Attribute.equals(Object) 
      		String Attribute.getName() 
      		Attribute.<init>(String,Object) 
      		String Attribute.toString() 
      		Object Attribute.getValue()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.text.MessageFormat
TYPE: class java.text.MessageFormat 
      	fields: {
      		java.util.Locale* locale <> 
      		int[_*_](*) argumentNumbers <> 
      		java.text.Format*[_*_](*) formats <> 
      		java.lang.String* pattern <> 
      		int maxOffset <> 
      		int[_*_](*) offsets <>
      	}
      	supers: {
      		class java.text.Format
      	}
      	methods: {
      		void MessageFormat.<clinit>() 
      		int MessageFormat.hashCode() 
      		void MessageFormat.setFormatsByArgumentIndex(Format[]) 
      		boolean MessageFormat.equals(Object) 
      		Object[] MessageFormat.parse(String,ParsePosition) 
      		AttributedCharacterIterator MessageFormat.formatToCharacterIterator(Object) 
      		Format[] MessageFormat.getFormatsByArgumentIndex() 
      		Object MessageFormat.clone() 
      		void MessageFormat.applyPattern(String) 
      		void MessageFormat.makeFormat(int,int,StringBuilder[]) 
      		String MessageFormat.toPattern() 
      		void MessageFormat.setFormatByArgumentIndex(int,Format) 
      		void MessageFormat.append(StringBuffer,CharacterIterator) 
      		String MessageFormat.format(String,Object[]) 
      		StringBuffer MessageFormat.format(Object[],StringBuffer,FieldPosition) 
      		void MessageFormat.readObject(ObjectInputStream) 
      		void MessageFormat.setLocale(Locale) 
      		Object MessageFormat.parseObject(String,ParsePosition) 
      		void MessageFormat.setFormats(Format[]) 
      		Format[] MessageFormat.getFormats() 
      		int MessageFormat.findKeyword(String,String[]) 
      		Locale MessageFormat.getLocale() 
      		void MessageFormat.copyAndFixQuotes(String,int,int,StringBuilder) 
      		void MessageFormat.setFormat(int,Format) 
      		MessageFormat.<init>(String) 
      		MessageFormat.<init>(String,Locale) 
      		StringBuffer MessageFormat.subformat(Object[],StringBuffer,FieldPosition,List) 
      		Object[] MessageFormat.parse(String) 
      		StringBuffer MessageFormat.format(Object,StringBuffer,FieldPosition)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.DeleteOraProcess
TYPE: class com.stn.servlets.DeleteOraProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		DeleteOraProcess.<init>() 
      		void DeleteOraProcess.doGet(HttpServletRequest,HttpServletResponse) 
      		void DeleteOraProcess.setTempFields(HttpServletRequest,Integer,Integer)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/DeleteOraProcess")>
      	}NAME: class java.util.AbstractList
TYPE: class java.util.AbstractList 
      	fields: {
      		int mIsEmpty <> 
      		int modCount <>
      	}
      	supers: {
      		class java.util.AbstractCollection 
      		class java.util.List
      	}
      	methods: {
      		int AbstractList.hashCode() 
      		int AbstractList.indexOf(Object) 
      		boolean AbstractList.equals(Object) 
      		void AbstractList.add(int,Object) 
      		Object AbstractList.set(int,Object) 
      		String AbstractList.outOfBoundsMsg(int) 
      		List AbstractList.subList(int,int) 
      		Iterator AbstractList.iterator() 
      		void AbstractList.rangeCheckForAdd(int) 
      		ListIterator AbstractList.listIterator(int) 
      		AbstractList.<init>() 
      		boolean AbstractList.addAll(int,Collection) 
      		Object AbstractList.remove(int) 
      		boolean AbstractList.add(Object) 
      		int AbstractList.lastIndexOf(Object) 
      		Object AbstractList.get(int) 
      		ListIterator AbstractList.listIterator() 
      		void AbstractList.clear() 
      		void AbstractList.removeRange(int,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.reflect.generics.repository.FieldRepository
TYPE: class sun.reflect.generics.repository.FieldRepository 
      	fields: {
      		java.lang.reflect.Type* genericType <> 
      		sun.reflect.generics.factory.GenericsFactory* factory <_final> 
      		sun.reflect.generics.tree.Tree* tree <_final>
      	}
      	supers: {
      		class sun.reflect.generics.repository.AbstractRepository
      	}
      	methods: {
      		FieldRepository.<init>(String,GenericsFactory) 
      		Tree FieldRepository.parse(String) 
      		FieldRepository FieldRepository.make(String,GenericsFactory) 
      		Type FieldRepository.getGenericType() 
      		TypeSignature FieldRepository.parse(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.ChangePasswordProcess
TYPE: class com.stn.servlets.ChangePasswordProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void ChangePasswordProcess.doPost(HttpServletRequest,HttpServletResponse) 
      		ChangePasswordProcess.<init>() 
      		void ChangePasswordProcess.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/ChangePasswordProcess")>
      	}NAME: class java.io.DataOutput
TYPE: class java.io.DataOutput 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void DataOutput.writeInt(int) 
      		void DataOutput.write(byte[]) 
      		void DataOutput.writeBytes(String) 
      		void DataOutput.writeBoolean(boolean) 
      		void DataOutput.write(int) 
      		void DataOutput.writeFloat(float) 
      		void DataOutput.writeUTF(String) 
      		void DataOutput.writeShort(int) 
      		void DataOutput.writeLong(long) 
      		void DataOutput.writeChars(String) 
      		void DataOutput.writeByte(int) 
      		void DataOutput.write(byte[],int,int) 
      		void DataOutput.writeDouble(double) 
      		void DataOutput.writeChar(int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Class$MethodArray
TYPE: class java.lang.Class$MethodArray 
      	fields: {
      		java.lang.reflect.Method*[_*_](*) methods <> 
      		int defaults <> 
      		int length <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		Class$MethodArray.<init>(int) 
      		void Class$MethodArray.addAllIfNotPresent(Class$MethodArray) 
      		boolean Class$MethodArray.hasDefaults() 
      		void Class$MethodArray.removeByNameAndDescriptor(Method) 
      		boolean Class$MethodArray.matchesNameAndDescriptor(Method,Method) 
      		Class$MethodArray.<init>() 
      		void Class$MethodArray.compactAndTrim() 
      		void Class$MethodArray.addInterfaceMethods(Method[]) 
      		void Class$MethodArray.addIfNotPresent(Method) 
      		void Class$MethodArray.removeLessSpecifics() 
      		boolean Class$MethodArray.hasMoreSpecificClass(Method,Method) 
      		void Class$MethodArray.addAll(Method[]) 
      		void Class$MethodArray.add(Method) 
      		int Class$MethodArray.length() 
      		void Class$MethodArray.addAll(Class$MethodArray) 
      		void Class$MethodArray.remove(int) 
      		Method Class$MethodArray.getFirst() 
      		Method[] Class$MethodArray.getArray() 
      		Method Class$MethodArray.get(int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.IntToDoubleFunction
TYPE: class java.util.function.IntToDoubleFunction 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		double IntToDoubleFunction.applyAsDouble(int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.security.MessageDigest
TYPE: class java.security.MessageDigest 
      	fields: {
      		java.security.Provider* provider <> 
      		java.lang.String* algorithm <> 
      		int state <> 
      		signed char[_*_](*) tempArray <>
      	}
      	supers: {
      		class java.security.MessageDigestSpi
      	}
      	methods: {
      		void MessageDigest.<clinit>() 
      		byte[] MessageDigest.digest(byte[]) 
      		Provider MessageDigest.getProvider() 
      		String MessageDigest.access$000(MessageDigest) 
      		int MessageDigest.digest(byte[],int,int) 
      		Object MessageDigest.clone() 
      		int MessageDigest.access$200(MessageDigest) 
      		void MessageDigest.update(byte[],int,int) 
      		Provider MessageDigest.access$100(MessageDigest) 
      		String MessageDigest.getAlgorithm() 
      		void MessageDigest.update(byte[]) 
      		MessageDigest MessageDigest.getInstance(String,String) 
      		void MessageDigest.update(byte) 
      		byte[] MessageDigest.digest() 
      		Provider MessageDigest.access$102(MessageDigest,Provider) 
      		boolean MessageDigest.isEqual(byte[],byte[]) 
      		String MessageDigest.toString() 
      		MessageDigest MessageDigest.getInstance(String) 
      		void MessageDigest.update(ByteBuffer) 
      		void MessageDigest.reset() 
      		int MessageDigest.access$202(MessageDigest,int) 
      		MessageDigest.<init>(String) 
      		int MessageDigest.getDigestLength() 
      		MessageDigest MessageDigest.getInstance(String,Provider)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.Driver
TYPE: class java.sql.Driver 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Connection Driver.connect(String,Properties) 
      		int Driver.getMajorVersion() 
      		boolean Driver.acceptsURL(String) 
      		boolean Driver.jdbcCompliant() 
      		DriverPropertyInfo[] Driver.getPropertyInfo(String,Properties) 
      		int Driver.getMinorVersion() 
      		Logger Driver.getParentLogger()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.reflect.Field
TYPE: class java.lang.reflect.Field 
      	fields: {
      		java.lang.Class* clazz <> 
      		java.lang.String* name <> 
      		java.lang.reflect.Field* root <> 
      		int slot <> 
      		java.util.Map* declaredAnnotations <> 
      		sun.reflect.FieldAccessor* overrideFieldAccessor <> 
      		signed char[_*_](*) annotations <> 
      		sun.reflect.generics.repository.FieldRepository* genericInfo <> 
      		sun.reflect.FieldAccessor* fieldAccessor <> 
      		java.lang.String* signature <> 
      		int modifiers <> 
      		java.lang.Class* type <> 
      		java.lang.Object* securityCheckCache <_volatile> 
      		_Bool override <>
      	}
      	supers: {
      		class java.lang.reflect.AccessibleObject 
      		class java.lang.reflect.Member
      	}
      	methods: {
      		int Field.hashCode() 
      		long Field.getLong(Object) 
      		Field Field.copy() 
      		boolean Field.equals(Object) 
      		void Field.setInt(Object,int) 
      		Annotation Field.getAnnotation(Class) 
      		FieldRepository Field.getGenericInfo() 
      		void Field.setBoolean(Object,boolean) 
      		Object Field.get(Object) 
      		GenericsFactory Field.getFactory() 
      		FieldAccessor Field.acquireFieldAccessor(boolean) 
      		Class Field.getDeclaringClass() 
      		byte Field.getByte(Object) 
      		double Field.getDouble(Object) 
      		Map Field.declaredAnnotations() 
      		AnnotatedType Field.getAnnotatedType() 
      		int Field.getModifiers() 
      		void Field.setFloat(Object,float) 
      		FieldAccessor Field.getFieldAccessor(Object) 
      		void Field.setChar(Object,char) 
      		String Field.getName() 
      		short Field.getShort(Object) 
      		boolean Field.isSynthetic() 
      		float Field.getFloat(Object) 
      		boolean Field.isEnumConstant() 
      		void Field.setLong(Object,long) 
      		Annotation[] Field.getAnnotationsByType(Class) 
      		Class Field.getType() 
      		Type Field.getGenericType() 
      		void Field.setByte(Object,byte) 
      		String Field.getGenericSignature() 
      		String Field.toString() 
      		FieldAccessor Field.getFieldAccessor(boolean) 
      		Annotation[] Field.getDeclaredAnnotations() 
      		char Field.getChar(Object) 
      		void Field.set(Object,Object) 
      		byte[] Field.getTypeAnnotationBytes0() 
      		void Field.setDouble(Object,double) 
      		boolean Field.getBoolean(Object) 
      		String Field.toGenericString() 
      		void Field.setShort(Object,short) 
      		Field.<init>(Class,String,Class,int,int,String,byte[]) 
      		void Field.setFieldAccessor(FieldAccessor,boolean) 
      		int Field.getInt(Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.ServletContext
TYPE: class javax.servlet.ServletContext 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		int ServletContext.getSessionTimeout() 
      		RequestDispatcher ServletContext.getRequestDispatcher(String) 
      		RequestDispatcher ServletContext.getNamedDispatcher(String) 
      		FilterRegistration$Dynamic ServletContext.addFilter(String,Filter) 
      		ServletRegistration$Dynamic ServletContext.addServlet(String,String) 
      		Set ServletContext.getEffectiveSessionTrackingModes() 
      		String ServletContext.getResponseCharacterEncoding() 
      		void ServletContext.log(Exception,String) 
      		InputStream ServletContext.getResourceAsStream(String) 
      		Map ServletContext.getFilterRegistrations() 
      		Servlet ServletContext.createServlet(Class) 
      		int ServletContext.getEffectiveMajorVersion() 
      		void ServletContext.removeAttribute(String) 
      		Object ServletContext.getAttribute(String) 
      		EventListener ServletContext.createListener(Class) 
      		String ServletContext.getRequestCharacterEncoding() 
      		Enumeration ServletContext.getInitParameterNames() 
      		Enumeration ServletContext.getServlets() 
      		Filter ServletContext.createFilter(Class) 
      		ServletRegistration$Dynamic ServletContext.addServlet(String,Class) 
      		int ServletContext.getMajorVersion() 
      		void ServletContext.addListener(EventListener) 
      		void ServletContext.log(String,Throwable) 
      		boolean ServletContext.setInitParameter(String,String) 
      		void ServletContext.setAttribute(String,Object) 
      		URL ServletContext.getResource(String) 
      		void ServletContext.setSessionTrackingModes(Set) 
      		Map ServletContext.getServletRegistrations() 
      		String ServletContext.getMimeType(String) 
      		void ServletContext.declareRoles(String[]) 
      		void ServletContext.setSessionTimeout(int) 
      		String ServletContext.getInitParameter(String) 
      		String ServletContext.getRealPath(String) 
      		Servlet ServletContext.getServlet(String) 
      		FilterRegistration$Dynamic ServletContext.addFilter(String,Class) 
      		ServletRegistration$Dynamic ServletContext.addServlet(String,Servlet) 
      		ServletContext ServletContext.getContext(String) 
      		ClassLoader ServletContext.getClassLoader() 
      		void ServletContext.addListener(String) 
      		void ServletContext.setResponseCharacterEncoding(String) 
      		void ServletContext.log(String) 
      		String ServletContext.getServerInfo() 
      		SessionCookieConfig ServletContext.getSessionCookieConfig() 
      		ServletRegistration ServletContext.getServletRegistration(String) 
      		int ServletContext.getEffectiveMinorVersion() 
      		JspConfigDescriptor ServletContext.getJspConfigDescriptor() 
      		void ServletContext.setRequestCharacterEncoding(String) 
      		String ServletContext.getContextPath() 
      		Enumeration ServletContext.getServletNames() 
      		FilterRegistration ServletContext.getFilterRegistration(String) 
      		ServletRegistration$Dynamic ServletContext.addJspFile(String,String) 
      		int ServletContext.getMinorVersion() 
      		void ServletContext.addListener(Class) 
      		String ServletContext.getServletContextName() 
      		Set ServletContext.getDefaultSessionTrackingModes() 
      		Enumeration ServletContext.getAttributeNames() 
      		FilterRegistration$Dynamic ServletContext.addFilter(String,String) 
      		Set ServletContext.getResourcePaths(String) 
      		String ServletContext.getVirtualServerName()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.math.BigDecimal
TYPE: class java.math.BigDecimal 
      	fields: {
      		int precision <> 
      		java.math.BigInteger* intVal <_final> 
      		long intCompact <_final> 
      		int scale <_final> 
      		java.lang.String* stringCache <>
      	}
      	supers: {
      		class java.lang.Number 
      		class java.lang.Comparable
      	}
      	methods: {
      		void BigDecimal.<clinit>() 
      		String BigDecimal.toPlainString() 
      		BigDecimal.<init>(int) 
      		BigDecimal BigDecimal.divide(long,int,long,int,int,int) 
      		long BigDecimal.multiply(long,long) 
      		int BigDecimal.hashCode() 
      		BigInteger BigDecimal.bigMultiplyPowerTen(BigInteger,int) 
      		long BigDecimal.add(long,long) 
      		BigDecimal BigDecimal.divideToIntegralValue(BigDecimal) 
      		BigDecimal BigDecimal.divide(BigDecimal,RoundingMode) 
      		void BigDecimal.matchScale(BigDecimal[]) 
      		BigDecimal BigDecimal.setScale(int,int) 
      		boolean BigDecimal.equals(Object) 
      		BigDecimal.<init>(BigInteger) 
      		BigDecimal BigDecimal.add(BigDecimal) 
      		int BigDecimal.compareMagnitudeNormalized(long,int,BigInteger,int) 
      		int BigDecimal.longDigitLength(long) 
      		BigDecimal BigDecimal.plus(MathContext) 
      		BigDecimal BigDecimal.round(MathContext) 
      		BigDecimal BigDecimal.add(BigDecimal,MathContext) 
      		byte BigDecimal.byteValueExact() 
      		BigDecimal BigDecimal.divide(BigDecimal,int,int) 
      		boolean BigDecimal.unsignedLongCompareEq(long,long) 
      		BigDecimal.<init>(BigInteger,long,int,int) 
      		BigDecimal BigDecimal.multiplyDivideAndRound(long,long,long,int,int,int) 
      		long BigDecimal.parseExp(char[],int,int) 
      		BigDecimal.<init>(BigInteger,int) 
      		int BigDecimal.compareTo(Object) 
      		BigDecimal BigDecimal.abs() 
      		BigDecimal BigDecimal.valueOf(long,int) 
      		BigDecimal BigDecimal.divide(BigInteger,int,long,int,long,MathContext) 
      		BigDecimal BigDecimal.valueOf(double) 
      		BigDecimal BigDecimal.stripZerosToMatchScale(BigInteger,long,int,int) 
      		long[] BigDecimal.divRemNegativeLong(long,long) 
      		BigDecimal.<init>(double,MathContext) 
      		BigInteger BigDecimal.bigMultiplyPowerTen(int) 
      		BigDecimal BigDecimal.stripTrailingZeros() 
      		BigDecimal BigDecimal.multiply(BigDecimal) 
      		boolean BigDecimal.needIncrement(long,int,int,long,long) 
      		void BigDecimal.writeObject(ObjectOutputStream) 
      		int BigDecimal.intValueExact() 
      		BigDecimal BigDecimal.divide(BigInteger,int,long,int,int,int) 
      		BigDecimal BigDecimal.doRound128(long,long,int,int,MathContext) 
      		BigDecimal BigDecimal.valueOf(long) 
      		BigDecimal BigDecimal.createAndStripZerosToMatchScale(long,int,long) 
      		BigDecimal BigDecimal.add(long,long,int) 
      		BigInteger BigDecimal.inflated() 
      		BigDecimal[] BigDecimal.divideAndRemainder(BigDecimal,MathContext) 
      		BigDecimal BigDecimal.remainder(BigDecimal,MathContext) 
      		BigDecimal BigDecimal.doRound(BigInteger,int,MathContext) 
      		BigDecimal BigDecimal.divide(long,int,long,int,long,MathContext) 
      		BigDecimal.<init>(int,MathContext) 
      		int BigDecimal.scale() 
      		boolean BigDecimal.fractionOnly() 
      		long BigDecimal.make64(long,long) 
      		BigInteger BigDecimal.divideAndRoundByTenPow(BigInteger,int,int) 
      		BigDecimal BigDecimal.movePointRight(int) 
      		BigDecimal BigDecimal.multiply(long,BigInteger,int) 
      		BigInteger BigDecimal.divideAndRound(BigInteger,long,int) 
      		BigDecimal BigDecimal.audit() 
      		BigDecimal.<init>(char[],MathContext) 
      		BigDecimal BigDecimal.add(long,int,BigInteger,int) 
      		int BigDecimal.compareTo(BigDecimal) 
      		BigDecimal BigDecimal.divideSmallFastPath(long,int,long,int,long,MathContext) 
      		int BigDecimal.checkScaleNonZero(long) 
      		BigDecimal BigDecimal.multiply(BigDecimal,MathContext) 
      		BigDecimal BigDecimal.plus() 
      		BigDecimal BigDecimal.subtract(BigDecimal) 
      		BigDecimal BigDecimal.valueOf(BigInteger,int,int) 
      		int BigDecimal.compareMagnitude(BigDecimal) 
      		BigDecimal BigDecimal.divide(BigDecimal,int,RoundingMode) 
      		BigDecimal BigDecimal.setScale(int) 
      		long BigDecimal.mulsub(long,long,long,long,long) 
      		float BigDecimal.floatValue() 
      		BigInteger BigDecimal.bigTenToThe(int) 
      		BigDecimal BigDecimal.max(BigDecimal) 
      		BigDecimal BigDecimal.multiplyAndRound(long,BigInteger,int,MathContext) 
      		boolean BigDecimal.commonNeedIncrement(int,int,int,boolean) 
      		boolean BigDecimal.needIncrement(long,int,int,MutableBigInteger,long) 
      		void BigDecimal.readObject(ObjectInputStream) 
      		BigInteger BigDecimal.toBigIntegerExact() 
      		BigDecimal BigDecimal.divide(long,int,BigInteger,int,int,int) 
      		BigDecimal BigDecimal.doRound(long,int,MathContext) 
      		BigDecimal.<init>(BigInteger,int,MathContext) 
      		BigDecimal BigDecimal.divideAndRound(BigInteger,long,int,int,int) 
      		BigDecimal[] BigDecimal.divideAndRemainder(BigDecimal) 
      		BigDecimal BigDecimal.remainder(BigDecimal) 
      		BigDecimal.<init>(char[]) 
      		boolean BigDecimal.needIncrement(MutableBigInteger,int,int,MutableBigInteger,MutableBigInteger) 
      		BigDecimal BigDecimal.divide(BigDecimal) 
      		int BigDecimal.intValue() 
      		BigDecimal.<init>(BigInteger,MathContext) 
      		int BigDecimal.signum() 
      		String BigDecimal.getValueString(int,String,int) 
      		int BigDecimal.compareMagnitudeNormalized(BigInteger,int,BigInteger,int) 
      		long BigDecimal.compactValFor(BigInteger) 
      		BigDecimal BigDecimal.valueOf(long,int,int) 
      		BigDecimal BigDecimal.movePointLeft(int) 
      		BigDecimal BigDecimal.multiply(long,long,int) 
      		void BigDecimal.print(String,BigDecimal) 
      		BigDecimal BigDecimal.ulp() 
      		int BigDecimal.saturateLong(long) 
      		boolean BigDecimal.longLongCompareMagnitude(long,long,long,long) 
      		BigDecimal BigDecimal.add(long,int,long,int) 
      		int BigDecimal.longCompareMagnitude(long,long) 
      		BigDecimal BigDecimal.roundedTenPower(int,int,int,int) 
      		int BigDecimal.adjustScale(int,long) 
      		BigDecimal BigDecimal.pow(int) 
      		BigDecimal BigDecimal.abs(MathContext) 
      		int BigDecimal.checkScale(BigInteger,long) 
      		String BigDecimal.toString() 
      		BigDecimal BigDecimal.divide(BigInteger,int,BigInteger,int,long,MathContext) 
      		double BigDecimal.doubleValue() 
      		BigDecimal BigDecimal.subtract(BigDecimal,MathContext) 
      		int BigDecimal.precision() 
      		long BigDecimal.longValueExact() 
      		boolean BigDecimal.unsignedLongCompare(long,long) 
      		long BigDecimal.longValue() 
      		BigDecimal BigDecimal.divideAndRound(long,long,int,int,int) 
      		BigDecimal BigDecimal.min(BigDecimal) 
      		BigDecimal BigDecimal.multiplyAndRound(long,long,int,MathContext) 
      		short BigDecimal.shortValueExact() 
      		BigDecimal BigDecimal.divide(BigInteger,int,BigInteger,int,int,int) 
      		int BigDecimal.precision(long,long) 
      		BigDecimal BigDecimal.zeroValueOf(int) 
      		BigDecimal BigDecimal.createAndStripZerosToMatchScale(BigInteger,int,long) 
      		BigInteger BigDecimal.bigMultiplyPowerTen(long,int) 
      		BigDecimal.<init>(char[],int,int,MathContext) 
      		BigDecimal BigDecimal.divideToIntegralValue(BigDecimal,MathContext) 
      		BigDecimal BigDecimal.pow(int,MathContext) 
      		int BigDecimal.checkScale(long) 
      		BigInteger BigDecimal.expandBigIntegerTenPowers(int) 
      		BigDecimal BigDecimal.divide(long,int,BigInteger,int,long,MathContext) 
      		BigDecimal.<init>(double) 
      		BigDecimal.<init>(long,MathContext) 
      		BigDecimal BigDecimal.doRound(BigDecimal,MathContext) 
      		BigInteger BigDecimal.toBigInteger() 
      		BigDecimal BigDecimal.divideAndRound128(long,long,long,int,int,int,int) 
      		int BigDecimal.bigDigitLength(BigInteger) 
      		long BigDecimal.longMultiplyPowerTen(long,int) 
      		BigDecimal BigDecimal.scaleByPowerOfTen(int) 
      		BigDecimal BigDecimal.multiply(BigInteger,BigInteger,int) 
      		BigInteger BigDecimal.divideAndRound(BigInteger,BigInteger,int) 
      		BigDecimal.<init>(String) 
      		BigInteger BigDecimal.access$000(BigDecimal) 
      		BigDecimal BigDecimal.divide(BigDecimal,MathContext) 
      		BigDecimal.<init>(String,MathContext) 
      		BigDecimal BigDecimal.add(BigInteger,int,BigInteger,int) 
      		String BigDecimal.layoutChars(boolean) 
      		BigDecimal.<init>(char[],int,int) 
      		int BigDecimal.compareMagnitudeNormalized(long,int,long,int) 
      		long BigDecimal.divideAndRound(long,long,int) 
      		BigDecimal BigDecimal.negate(MathContext) 
      		BigInteger BigDecimal.unscaledValue() 
      		BigDecimal BigDecimal.negate() 
      		int BigDecimal.checkScale(long,long) 
      		BigDecimal BigDecimal.setScale(int,RoundingMode) 
      		BigDecimal BigDecimal.divide(BigDecimal,int) 
      		BigDecimal[] BigDecimal.preAlign(BigDecimal,BigDecimal,long,MathContext) 
      		BigDecimal.<init>(long) 
      		BigDecimal BigDecimal.scaledTenPow(int,int,int) 
      		BigDecimal BigDecimal.divideAndRound(BigInteger,BigInteger,int,int,int) 
      		String BigDecimal.toEngineeringString() 
      		BigDecimal BigDecimal.multiplyAndRound(BigInteger,BigInteger,int,MathContext)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Locale$1
TYPE: class java.util.Locale$1 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Locale$1.<clinit>()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.reflect.ReflectionFactory
TYPE: class sun.reflect.ReflectionFactory 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void ReflectionFactory.<clinit>() 
      		int ReflectionFactory.access$102(int) 
      		Constructor ReflectionFactory.newConstructorForSerialization(Class,Constructor) 
      		void ReflectionFactory.setConstructorAccessor(Constructor,ConstructorAccessor) 
      		Field ReflectionFactory.copyField(Field) 
      		MethodHandle ReflectionFactory.readObjectNoDataForSerialization(Class) 
      		Constructor ReflectionFactory.newConstructor(Class,Class[],Class[],int,int,String,byte[],byte[]) 
      		void ReflectionFactory.setLangReflectAccess(LangReflectAccess) 
      		boolean ReflectionFactory.hasStaticInitializerForSerialization(Class) 
      		Field ReflectionFactory.newField(Class,String,Class,int,int,String,byte[]) 
      		MethodHandle ReflectionFactory.readResolveForSerialization(Class) 
      		ReflectionFactory.<init>() 
      		byte[] ReflectionFactory.getExecutableTypeAnnotationBytes(Executable) 
      		void ReflectionFactory.setMethodAccessor(Method,MethodAccessor) 
      		Constructor ReflectionFactory.newConstructorForExternalization(Class) 
      		ConstructorAccessor ReflectionFactory.newConstructorAccessor(Constructor) 
      		FieldAccessor ReflectionFactory.newFieldAccessor(Field,boolean) 
      		boolean ReflectionFactory.packageEquals(Class,Class) 
      		Constructor ReflectionFactory.copyConstructor(Constructor) 
      		int ReflectionFactory.inflationThreshold() 
      		boolean ReflectionFactory.access$202(boolean) 
      		LangReflectAccess ReflectionFactory.langReflectAccess() 
      		Constructor ReflectionFactory.generateConstructor(Class,Constructor) 
      		Method ReflectionFactory.copyMethod(Method) 
      		MethodHandle ReflectionFactory.writeObjectForSerialization(Class) 
      		ReflectionFactory ReflectionFactory.getReflectionFactory() 
      		MethodAccessor ReflectionFactory.getMethodAccessor(Method) 
      		MethodAccessor ReflectionFactory.newMethodAccessor(Method) 
      		Constructor ReflectionFactory.newConstructorForSerialization(Class) 
      		OptionalDataException ReflectionFactory.newOptionalDataExceptionForSerialization(boolean) 
      		Method ReflectionFactory.newMethod(Class,String,Class[],Class,Class[],int,int,String,byte[],byte[],byte[]) 
      		MethodHandle ReflectionFactory.getReplaceResolveForSerialization(Class,String) 
      		MethodHandle ReflectionFactory.writeReplaceForSerialization(Class) 
      		void ReflectionFactory.checkInitted() 
      		ConstructorAccessor ReflectionFactory.getConstructorAccessor(Constructor) 
      		MethodHandle ReflectionFactory.readObjectForSerialization(Class) 
      		MethodHandle ReflectionFactory.findReadWriteObjectForSerialization(Class,String,Class) 
      		boolean ReflectionFactory.access$002(boolean)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.OutputStream
TYPE: class java.io.OutputStream 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Closeable 
      		class java.io.Flushable
      	}
      	methods: {
      		void OutputStream.write(byte[]) 
      		void OutputStream.write(int) 
      		void OutputStream.close() 
      		OutputStream.<init>() 
      		void OutputStream.flush() 
      		void OutputStream.write(byte[],int,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Collection
TYPE: class java.util.Collection 
      	fields: {
      	}
      	supers: {
      		class java.lang.Iterable
      	}
      	methods: {
      		int Collection.hashCode() 
      		boolean Collection.removeAll(Collection) 
      		boolean Collection.equals(Object) 
      		int Collection.size() 
      		boolean Collection.removeIf(Predicate) 
      		Iterator Collection.iterator() 
      		boolean Collection.contains(Object) 
      		Object[] Collection.toArray() 
      		boolean Collection.containsAll(Collection) 
      		Object[] Collection.toArray(Object[]) 
      		boolean Collection.remove(Object) 
      		Stream Collection.parallelStream() 
      		boolean Collection.retainAll(Collection) 
      		Spliterator Collection.spliterator() 
      		boolean Collection.addAll(Collection) 
      		boolean Collection.add(Object) 
      		Stream Collection.stream() 
      		boolean Collection.isEmpty() 
      		void Collection.clear()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.AbstractStringBuilder
TYPE: class java.lang.AbstractStringBuilder 
      	fields: {
      		int count <> 
      		unsigned short[_*_](*) value <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.lang.Appendable 
      		class java.lang.CharSequence
      	}
      	methods: {
      		AbstractStringBuilder AbstractStringBuilder.insert(int,Object) 
      		AbstractStringBuilder.<init>(int) 
      		void AbstractStringBuilder.getChars(int,int,char[],int) 
      		AbstractStringBuilder AbstractStringBuilder.append(AbstractStringBuilder) 
      		AbstractStringBuilder AbstractStringBuilder.append(StringBuffer) 
      		AbstractStringBuilder AbstractStringBuilder.insert(int,long) 
      		void AbstractStringBuilder.ensureCapacity(int) 
      		String AbstractStringBuilder.substring(int,int) 
      		AbstractStringBuilder AbstractStringBuilder.append(long) 
      		AbstractStringBuilder AbstractStringBuilder.insert(int,CharSequence,int,int) 
      		char AbstractStringBuilder.charAt(int) 
      		AbstractStringBuilder AbstractStringBuilder.append(char[],int,int) 
      		int AbstractStringBuilder.newCapacity(int) 
      		int AbstractStringBuilder.indexOf(String) 
      		AbstractStringBuilder AbstractStringBuilder.delete(int,int) 
      		AbstractStringBuilder AbstractStringBuilder.insert(int,char[]) 
      		String AbstractStringBuilder.substring(int) 
      		AbstractStringBuilder AbstractStringBuilder.append(CharSequence,int,int) 
      		AbstractStringBuilder AbstractStringBuilder.insert(int,double) 
      		AbstractStringBuilder AbstractStringBuilder.append(Object) 
      		AbstractStringBuilder AbstractStringBuilder.append(double) 
      		AbstractStringBuilder.<init>() 
      		AbstractStringBuilder AbstractStringBuilder.insert(int,char) 
      		void AbstractStringBuilder.setLength(int) 
      		int AbstractStringBuilder.codePointCount(int,int) 
      		void AbstractStringBuilder.reverseAllValidSurrogatePairs() 
      		AbstractStringBuilder AbstractStringBuilder.append(char) 
      		Appendable AbstractStringBuilder.append(CharSequence,int,int) 
      		AbstractStringBuilder AbstractStringBuilder.replace(int,int,String) 
      		AbstractStringBuilder AbstractStringBuilder.insert(int,String) 
      		AbstractStringBuilder AbstractStringBuilder.append(CharSequence) 
      		AbstractStringBuilder AbstractStringBuilder.insert(int,float) 
      		int AbstractStringBuilder.capacity() 
      		AbstractStringBuilder AbstractStringBuilder.append(float) 
      		int AbstractStringBuilder.codePointAt(int) 
      		AbstractStringBuilder AbstractStringBuilder.insert(int,boolean) 
      		void AbstractStringBuilder.setCharAt(int,char) 
      		int AbstractStringBuilder.lastIndexOf(String,int) 
      		int AbstractStringBuilder.codePointBefore(int) 
      		AbstractStringBuilder AbstractStringBuilder.append(boolean) 
      		int AbstractStringBuilder.lastIndexOf(String) 
      		String AbstractStringBuilder.toString() 
      		char[] AbstractStringBuilder.getValue() 
      		int AbstractStringBuilder.hugeCapacity(int) 
      		Appendable AbstractStringBuilder.append(char) 
      		AbstractStringBuilder AbstractStringBuilder.deleteCharAt(int) 
      		AbstractStringBuilder AbstractStringBuilder.insert(int,CharSequence) 
      		int AbstractStringBuilder.indexOf(String,int) 
      		int AbstractStringBuilder.length() 
      		AbstractStringBuilder AbstractStringBuilder.append(char[]) 
      		AbstractStringBuilder AbstractStringBuilder.reverse() 
      		void AbstractStringBuilder.ensureCapacityInternal(int) 
      		AbstractStringBuilder AbstractStringBuilder.appendCodePoint(int) 
      		AbstractStringBuilder AbstractStringBuilder.insert(int,int) 
      		void AbstractStringBuilder.trimToSize() 
      		int AbstractStringBuilder.offsetByCodePoints(int,int) 
      		AbstractStringBuilder AbstractStringBuilder.append(int) 
      		AbstractStringBuilder AbstractStringBuilder.appendNull() 
      		CharSequence AbstractStringBuilder.subSequence(int,int) 
      		AbstractStringBuilder AbstractStringBuilder.append(String) 
      		Appendable AbstractStringBuilder.append(CharSequence) 
      		AbstractStringBuilder AbstractStringBuilder.insert(int,char[],int,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.Flags$Flag
TYPE: class javax.mail.Flags$Flag 
      	fields: {
      		int bit <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Flags$Flag.<clinit>() 
      		Flags$Flag.<init>(int) 
      		int Flags$Flag.access$000(Flags$Flag)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.pojo.Facultate
TYPE: class com.stn.pojo.Facultate 
      	fields: {
      		int idFacultate <> 
      		java.lang.String* nume <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Facultate.setIdFacultate(int) 
      		void Facultate.setNume(String) 
      		Facultate.<init>(int,String) 
      		String Facultate.getNume() 
      		int Facultate.getIdFacultate()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.Predicate
TYPE: class java.util.function.Predicate 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		boolean Predicate.lambda$negate$1(Object) 
      		Predicate Predicate.callsite_java.util.function.Predicate$Lambda$_1_7(Predicate,Predicate) 
      		Predicate Predicate.and(Predicate) 
      		boolean Predicate.access_java.util.function.Predicate$Lambda$_2_5(Object) 
      		Predicate Predicate.callsite_java.util.function.Predicate$Lambda$_8_7(Predicate,Predicate) 
      		boolean Predicate.access_java.util.function.Predicate$Lambda$_1_7(Predicate,Predicate,Object) 
      		Predicate Predicate.or(Predicate) 
      		boolean Predicate.access_java.util.function.Predicate$Lambda$_2_14(Object,Object) 
      		boolean Predicate.lambda$or$2(Predicate,Object) 
      		boolean Predicate.access_java.util.function.Predicate$Lambda$_7_1(Predicate,Object) 
      		Predicate Predicate.negate() 
      		Predicate Predicate.callsite_java.util.function.Predicate$Lambda$_2_14(Object) 
      		boolean Predicate.test(Object) 
      		boolean Predicate.lambda$isEqual$3(Object,Object) 
      		boolean Predicate.access_java.util.function.Predicate$Lambda$_8_7(Predicate,Predicate,Object) 
      		Predicate Predicate.callsite_java.util.function.Predicate$Lambda$_2_5() 
      		Predicate Predicate.isEqual(Object) 
      		Predicate Predicate.callsite_java.util.function.Predicate$Lambda$_7_1(Predicate) 
      		boolean Predicate.lambda$and$0(Predicate,Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.text.Format$FieldDelegate
TYPE: class java.text.Format$FieldDelegate 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void Format$FieldDelegate.formatted(Format$Field,Object,int,int,StringBuffer) 
      		void Format$FieldDelegate.formatted(int,Format$Field,Object,int,int,StringBuffer)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.IntSupplier
TYPE: class java.util.function.IntSupplier 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		int IntSupplier.getAsInt()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.lang.Appendable
TYPE: class java.lang.Appendable 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Appendable Appendable.append(CharSequence,int,int) 
      		Appendable Appendable.append(char) 
      		Appendable Appendable.append(CharSequence)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.SecurityManager
TYPE: class java.lang.SecurityManager 
      	fields: {
      		_Bool inCheck <_java.lang.Deprecated> 
      		_Bool initialized <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void SecurityManager.<clinit>() 
      		void SecurityManager.checkDelete(String) 
      		Class SecurityManager.currentLoadedClass() 
      		void SecurityManager.checkSystemClipboardAccess() 
      		void SecurityManager.checkExit(int) 
      		void SecurityManager.checkMulticast(InetAddress) 
      		Class SecurityManager.currentLoadedClass0() 
      		Object SecurityManager.getSecurityContext() 
      		void SecurityManager.checkSecurityAccess(String) 
      		String[] SecurityManager.getPackages(String) 
      		void SecurityManager.checkRead(String) 
      		void SecurityManager.checkListen(int) 
      		ClassLoader SecurityManager.currentClassLoader0() 
      		boolean SecurityManager.inClass(String) 
      		void SecurityManager.checkPackageDefinition(String) 
      		void SecurityManager.checkPropertiesAccess() 
      		void SecurityManager.checkLink(String) 
      		SecurityManager.<init>() 
      		boolean SecurityManager.checkTopLevelWindow(Object) 
      		int SecurityManager.classDepth(String) 
      		void SecurityManager.checkAccess(Thread) 
      		ThreadGroup SecurityManager.getRootGroup() 
      		void SecurityManager.checkWrite(FileDescriptor) 
      		void SecurityManager.checkConnect(String,int,Object) 
      		int SecurityManager.classLoaderDepth() 
      		void SecurityManager.checkAwtEventQueueAccess() 
      		void SecurityManager.checkExec(String) 
      		void SecurityManager.checkMulticast(InetAddress,byte) 
      		int SecurityManager.classLoaderDepth0() 
      		void SecurityManager.checkCreateClassLoader() 
      		void SecurityManager.checkPermission(Permission) 
      		Class[] SecurityManager.getClassContext() 
      		ThreadGroup SecurityManager.getThreadGroup() 
      		void SecurityManager.checkPropertyAccess(String) 
      		void SecurityManager.checkRead(String,Object) 
      		void SecurityManager.checkPackageAccess(String) 
      		void SecurityManager.checkSetFactory() 
      		void SecurityManager.checkAccept(String,int) 
      		boolean SecurityManager.hasAllPermission() 
      		boolean SecurityManager.inClassLoader() 
      		void SecurityManager.checkMemberAccess(Class,int) 
      		void SecurityManager.checkPermission(Permission,Object) 
      		void SecurityManager.checkRead(FileDescriptor) 
      		void SecurityManager.checkConnect(String,int) 
      		void SecurityManager.checkPrintJobAccess() 
      		ClassLoader SecurityManager.currentClassLoader() 
      		void SecurityManager.checkAccess(ThreadGroup) 
      		boolean SecurityManager.getInCheck() 
      		void SecurityManager.checkWrite(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.Supplier
TYPE: class java.util.function.Supplier 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Object Supplier.get()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.text.DateFormatSymbols
TYPE: class java.text.DateFormatSymbols 
      	fields: {
      		java.lang.String*[_*_](*) ampms <> 
      		java.util.Locale* locale <> 
      		int cachedHashCode <_volatile> 
      		java.lang.String*[_*_](*) months <> 
      		java.lang.String* localPatternChars <> 
      		java.lang.String*[_*_](*) weekdays <> 
      		java.lang.String*[_*_](*)[_*_](*) zoneStrings <> 
      		_Bool isZoneStringsSet <> 
      		java.lang.String*[_*_](*) shortMonths <> 
      		int lastZoneIndex <> 
      		java.lang.String*[_*_](*) eras <> 
      		java.lang.String*[_*_](*) shortWeekdays <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable 
      		class java.lang.Cloneable
      	}
      	methods: {
      		void DateFormatSymbols.<clinit>() 
      		int DateFormatSymbols.hashCode() 
      		DateFormatSymbols.<init>(Locale) 
      		boolean DateFormatSymbols.equals(Object) 
      		void DateFormatSymbols.copyMembers(DateFormatSymbols,DateFormatSymbols) 
      		String[] DateFormatSymbols.getEras() 
      		void DateFormatSymbols.setMonths(String[]) 
      		Locale[] DateFormatSymbols.getAvailableLocales() 
      		DateFormatSymbols DateFormatSymbols.getInstance(Locale) 
      		String[][] DateFormatSymbols.getZoneStrings() 
      		Object DateFormatSymbols.clone() 
      		void DateFormatSymbols.setAmPmStrings(String[]) 
      		void DateFormatSymbols.writeObject(ObjectOutputStream) 
      		DateFormatSymbols.<init>(boolean) 
      		String[] DateFormatSymbols.toOneBasedArray(String[]) 
      		String[] DateFormatSymbols.getMonths() 
      		void DateFormatSymbols.setWeekdays(String[]) 
      		DateFormatSymbols.<init>() 
      		DateFormatSymbols DateFormatSymbols.getInstance() 
      		String[] DateFormatSymbols.getShortWeekdays() 
      		void DateFormatSymbols.setLocalPatternChars(String) 
      		void DateFormatSymbols.setShortMonths(String[]) 
      		DateFormatSymbols DateFormatSymbols.getProviderInstance(Locale) 
      		String[][] DateFormatSymbols.getZoneStringsWrapper() 
      		DateFormatSymbols DateFormatSymbols.getInstanceRef(Locale) 
      		String[] DateFormatSymbols.getWeekdays() 
      		void DateFormatSymbols.setZoneStrings(String[][]) 
      		void DateFormatSymbols.initializeData(Locale) 
      		boolean DateFormatSymbols.isSubclassObject() 
      		int DateFormatSymbols.getZoneIndex(String) 
      		String[] DateFormatSymbols.getShortMonths() 
      		void DateFormatSymbols.setShortWeekdays(String[]) 
      		String[][] DateFormatSymbols.getZoneStringsImpl(boolean) 
      		void DateFormatSymbols.setEras(String[]) 
      		String DateFormatSymbols.getLocalPatternChars() 
      		String[] DateFormatSymbols.getAmPmStrings()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.reflect.Parameter
TYPE: class java.lang.reflect.Parameter 
      	fields: {
      		java.lang.reflect.Executable* executable <_final> 
      		java.lang.String* name <_final> 
      		java.util.Map* declaredAnnotations <> 
      		int index <_final> 
      		java.lang.reflect.Type* parameterTypeCache <_volatile> 
      		int modifiers <_final> 
      		java.lang.Class* parameterClassCache <_volatile>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.lang.reflect.AnnotatedElement
      	}
      	methods: {
      		int Parameter.hashCode() 
      		boolean Parameter.isNamePresent() 
      		boolean Parameter.equals(Object) 
      		boolean Parameter.isImplicit() 
      		Annotation Parameter.getAnnotation(Class) 
      		boolean Parameter.isVarArgs() 
      		Annotation[] Parameter.getDeclaredAnnotationsByType(Class) 
      		Map Parameter.declaredAnnotations() 
      		AnnotatedType Parameter.getAnnotatedType() 
      		Parameter.<init>(String,int,Executable,int) 
      		int Parameter.getModifiers() 
      		Annotation[] Parameter.getAnnotations() 
      		String Parameter.getName() 
      		Type Parameter.getParameterizedType() 
      		boolean Parameter.isSynthetic() 
      		Executable Parameter.getDeclaringExecutable() 
      		Annotation[] Parameter.getAnnotationsByType(Class) 
      		Class Parameter.getType() 
      		String Parameter.toString() 
      		Annotation[] Parameter.getDeclaredAnnotations() 
      		String Parameter.getRealName() 
      		Annotation Parameter.getDeclaredAnnotation(Class)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.pojo.Orar
TYPE: class com.stn.pojo.Orar 
      	fields: {
      		java.lang.String* zi <> 
      		java.lang.String* name <> 
      		int id <> 
      		java.lang.String* tip_act <> 
      		int grupa <> 
      		int id_grupa <> 
      		java.lang.String* sala <> 
      		java.lang.String* sapt <> 
      		int sgr <> 
      		java.lang.String* durata <> 
      		java.lang.String* nume_prof <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Orar.setSala(String) 
      		String Orar.getTip_act() 
      		int Orar.getId_grupa() 
      		void Orar.setSapt(String) 
      		void Orar.setId_grupa(int) 
      		String Orar.getZi() 
      		void Orar.setZi(String) 
      		String Orar.getSala() 
      		Orar.<init>() 
      		int Orar.getId() 
      		String Orar.getName() 
      		void Orar.setName(String) 
      		void Orar.setTip_act(String) 
      		String Orar.getSapt() 
      		void Orar.setNume_prof(String) 
      		int Orar.getSgr() 
      		void Orar.setId(int) 
      		void Orar.setDurata(String) 
      		int Orar.getGrupa() 
      		void Orar.setGrupa(int) 
      		String Orar.getNume_prof() 
      		String Orar.getDurata() 
      		void Orar.setSgr(int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.nio.charset.Charset
TYPE: class java.nio.charset.Charset 
      	fields: {
      		java.lang.String* name <_final> 
      		java.lang.String*[_*_](*) aliases <_final> 
      		java.util.Set* aliasSet <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.lang.Comparable
      	}
      	methods: {
      		void Charset.<clinit>() 
      		CharBuffer Charset.decode(ByteBuffer) 
      		int Charset.hashCode() 
      		CharsetDecoder Charset.newDecoder() 
      		Charset Charset.forName(String) 
      		SortedMap Charset.availableCharsets() 
      		boolean Charset.equals(Object) 
      		Charset Charset.lookupExtendedCharset(String) 
      		ByteBuffer Charset.encode(CharBuffer) 
      		Iterator Charset.access$000() 
      		int Charset.compareTo(Object) 
      		String Charset.displayName() 
      		Charset Charset.lookup(String) 
      		boolean Charset.canEncode() 
      		void Charset.put(Iterator,Map) 
      		Charset.<init>(String,String[]) 
      		void Charset.cache(String,Charset) 
      		int Charset.compareTo(Charset) 
      		void Charset.access$200(Iterator,Map) 
      		String Charset.displayName(Locale) 
      		CharsetEncoder Charset.newEncoder() 
      		Charset Charset.defaultCharset() 
      		Charset Charset.lookupViaProviders(String) 
      		String Charset.name() 
      		CharsetProvider Charset.access$100() 
      		boolean Charset.atBugLevel(String) 
      		boolean Charset.isRegistered() 
      		String Charset.toString() 
      		ByteBuffer Charset.encode(String) 
      		Iterator Charset.providers() 
      		Set Charset.aliases() 
      		void Charset.checkName(String) 
      		boolean Charset.isSupported(String) 
      		Charset Charset.lookup2(String) 
      		boolean Charset.contains(Charset)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.pojo.Invitatie
TYPE: class com.stn.pojo.Invitatie 
      	fields: {
      		int idSerie <> 
      		int idFacultate <> 
      		java.lang.String* token <> 
      		java.lang.String* email <> 
      		int userClass <> 
      		int idInvitatie <> 
      		int idGrupa <> 
      		java.sql.Timestamp* expDate <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Invitatie.setToken(String) 
      		int Invitatie.getUserClass() 
      		void Invitatie.setIdFacultate(int) 
      		int Invitatie.getIdSerie() 
      		Invitatie.<init>(int,String,String,int,int,int,int,Timestamp) 
      		String Invitatie.getToken() 
      		void Invitatie.setEmail(String) 
      		int Invitatie.getIdInvitatie() 
      		int Invitatie.getIdGrupa() 
      		void Invitatie.setIdSerie(int) 
      		void Invitatie.setExpDate(Timestamp) 
      		void Invitatie.setIdGrupa(int) 
      		void Invitatie.setIdInvitatie(int) 
      		String Invitatie.getEmail() 
      		int Invitatie.getIdFacultate() 
      		void Invitatie.setUserClass(int) 
      		Timestamp Invitatie.getExpDate()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.invoke.SerializedLambda
TYPE: class java.lang.invoke.SerializedLambda 
      	fields: {
      		int implMethodKind <_final> 
      		java.lang.Class* capturingClass <_final> 
      		java.lang.String* instantiatedMethodType <_final> 
      		java.lang.String* implMethodName <_final> 
      		java.lang.String* functionalInterfaceMethodName <_final> 
      		java.lang.String* implClass <_final> 
      		java.lang.String* functionalInterfaceClass <_final> 
      		java.lang.Object*[_*_](*) capturedArgs <_final> 
      		java.lang.String* implMethodSignature <_final> 
      		java.lang.String* functionalInterfaceMethodSignature <_final>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable
      	}
      	methods: {
      		String SerializedLambda.getImplMethodName() 
      		String SerializedLambda.getFunctionalInterfaceMethodSignature() 
      		String SerializedLambda.getCapturingClass() 
      		String SerializedLambda.getFunctionalInterfaceClass() 
      		String SerializedLambda.getImplMethodSignature() 
      		int SerializedLambda.getCapturedArgCount() 
      		int SerializedLambda.getImplMethodKind() 
      		String SerializedLambda.getImplClass() 
      		String SerializedLambda.toString() 
      		String SerializedLambda.getInstantiatedMethodType() 
      		String SerializedLambda.getFunctionalInterfaceMethodName() 
      		SerializedLambda.<init>(Class,String,String,String,int,String,String,String,String,Object[]) 
      		Object SerializedLambda.readResolve() 
      		Object SerializedLambda.getCapturedArg(int) 
      		Class SerializedLambda.access$000(SerializedLambda)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.utils.Tools$1
TYPE: class com.stn.utils.Tools$1 
      	fields: {
      		com.stn.utils.Tools* this$0 <_final> 
      		java.lang.String* requestingProtocol <> 
      		java.net.InetAddress* requestingSite <> 
      		java.lang.String* requestingUserName <> 
      		java.lang.String* requestingPrompt <> 
      		int requestingPort <>
      	}
      	supers: {
      		class javax.mail.Authenticator
      	}
      	methods: {
      		Tools$1.<init>(Tools) 
      		PasswordAuthentication Tools$1.getPasswordAuthentication()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.misc.JavaObjectInputStreamAccess
TYPE: class sun.misc.JavaObjectInputStreamAccess 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void JavaObjectInputStreamAccess.setValidator(ObjectInputStream,ObjectStreamClassValidator)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.ToLongFunction
TYPE: class java.util.function.ToLongFunction 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		long ToLongFunction.applyAsLong(Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.lang.Package
TYPE: class java.lang.Package 
      	fields: {
      		java.lang.String* specTitle <_final> 
      		java.lang.ClassLoader* loader <_final> 
      		java.lang.String* implVersion <_final> 
      		java.lang.String* specVendor <_final> 
      		java.net.URL* sealBase <_final> 
      		java.lang.String* specVersion <_final> 
      		java.lang.String* implVendor <_final> 
      		java.lang.String* implTitle <_final> 
      		java.lang.Class* packageInfo <> 
      		java.lang.String* pkgName <_final>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.lang.reflect.AnnotatedElement
      	}
      	methods: {
      		void Package.<clinit>() 
      		Package.<init>(String,Manifest,URL,ClassLoader,Package$1) 
      		int Package.hashCode() 
      		String Package.getSystemPackage0(String) 
      		Package Package.getPackage(String) 
      		Annotation Package.getAnnotation(Class) 
      		String Package.getImplementationVendor() 
      		Package Package.getPackage(Class) 
      		String Package.getSpecificationVersion() 
      		Class Package.getPackageInfo() 
      		Annotation[] Package.getDeclaredAnnotationsByType(Class) 
      		Package.<init>(String,String,String,String,String,String,String,URL,ClassLoader) 
      		String[] Package.getSystemPackages0() 
      		Package[] Package.getPackages() 
      		Annotation[] Package.getAnnotations() 
      		boolean Package.isSealed(URL) 
      		Package.<init>(String,Manifest,URL,ClassLoader) 
      		String Package.getName() 
      		String Package.getImplementationTitle() 
      		Manifest Package.access$100(String) 
      		Map Package.access$400() 
      		Package Package.defineSystemPackage(String,String) 
      		Package Package.getSystemPackage(String) 
      		boolean Package.isAnnotationPresent(Class) 
      		Annotation[] Package.getAnnotationsByType(Class) 
      		boolean Package.isSealed() 
      		String Package.getSpecificationVendor() 
      		String Package.toString() 
      		Annotation[] Package.getDeclaredAnnotations() 
      		Map Package.access$000() 
      		String Package.getSpecificationTitle() 
      		Package[] Package.getSystemPackages() 
      		Annotation Package.getDeclaredAnnotation(Class) 
      		boolean Package.isCompatibleWith(String) 
      		Manifest Package.loadManifest(String) 
      		String Package.getImplementationVersion() 
      		Map Package.access$200()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.pojo.Stats
TYPE: class com.stn.pojo.Stats 
      	fields: {
      		int userCount <> 
      		int latestUserId <> 
      		int guestOfHonour <> 
      		int seriiCount <> 
      		int sefDeGrupa <> 
      		int latestUserUserClass <> 
      		int administrators <> 
      		int facultatiCount <> 
      		int students <> 
      		java.lang.String* latestUserUsername <> 
      		int moderators <> 
      		int grupeCount <> 
      		int vips <> 
      		int latestUserDonor <> 
      		int owners <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Stats.setStats(List,List,List,List) 
      		int Stats.getStudents() 
      		int Stats.getGrupeCount() 
      		int Stats.getModerators() 
      		int Stats.getFacultatiCount() 
      		int Stats.getVips() 
      		Stats.<init>() 
      		String Stats.getLatestUserUsername() 
      		int Stats.getOwners() 
      		int Stats.getUserCount() 
      		int Stats.getSefDeGrupa() 
      		int Stats.getLatestUserId() 
      		int Stats.getAdministrators() 
      		int Stats.getSeriiCount() 
      		int Stats.getGuestOfHonour() 
      		int Stats.getLatestUserUserClass() 
      		int Stats.getLatestUserDonor()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.EditUserProcess
TYPE: class com.stn.servlets.EditUserProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void EditUserProcess.doPost(HttpServletRequest,HttpServletResponse) 
      		EditUserProcess.<init>() 
      		void EditUserProcess.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/EditUserProcess")>
      	}NAME: class java.sql.Blob
TYPE: class java.sql.Blob 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		int Blob.setBytes(long,byte[],int,int) 
      		InputStream Blob.getBinaryStream() 
      		InputStream Blob.getBinaryStream(long,long) 
      		void Blob.truncate(long) 
      		long Blob.position(Blob,long) 
      		OutputStream Blob.setBinaryStream(long) 
      		long Blob.position(byte[],long) 
      		byte[] Blob.getBytes(long,int) 
      		void Blob.free() 
      		int Blob.setBytes(long,byte[]) 
      		long Blob.length()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.Filter
TYPE: class javax.servlet.Filter 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void Filter.doFilter(ServletRequest,ServletResponse,FilterChain) 
      		void Filter.destroy() 
      		void Filter.init(FilterConfig)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.AdminAppProcess
TYPE: class com.stn.servlets.AdminAppProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void AdminAppProcess.doPost(HttpServletRequest,HttpServletResponse) 
      		AdminAppProcess.<init>() 
      		void AdminAppProcess.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/AdminAppProcess")>
      	}NAME: class java.lang.management.ClassLoadingMXBean
TYPE: class java.lang.management.ClassLoadingMXBean 
      	fields: {
      	}
      	supers: {
      		class java.lang.management.PlatformManagedObject
      	}
      	methods: {
      		boolean ClassLoadingMXBean.isVerbose() 
      		int ClassLoadingMXBean.getLoadedClassCount() 
      		long ClassLoadingMXBean.getTotalLoadedClassCount() 
      		void ClassLoadingMXBean.setVerbose(boolean) 
      		long ClassLoadingMXBean.getUnloadedClassCount()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.IOException
TYPE: class java.io.IOException 
      	fields: {
      		java.lang.String* detailMessage <> 
      		java.lang.Object* backtrace <> 
      		java.lang.StackTraceElement*[_*_](*) stackTrace <> 
      		java.lang.Throwable* cause <> 
      		java.util.List* suppressedExceptions <>
      	}
      	supers: {
      		class java.lang.Exception
      	}
      	methods: {
      		IOException.<init>(String,Throwable) 
      		IOException.<init>() 
      		IOException.<init>(Throwable) 
      		IOException.<init>(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Properties
TYPE: class java.util.Properties 
      	fields: {
      		java.util.Properties* defaults <> 
      		float loadFactor <> 
      		java.util.Set* entrySet <_volatile> 
      		int count <> 
      		int threshold <> 
      		java.util.Set* keySet <_volatile> 
      		int modCount <> 
      		java.util.Collection* values <_volatile> 
      		java.util.Hashtable$Entry*[_*_](*) table <>
      	}
      	supers: {
      		class java.util.Hashtable
      	}
      	methods: {
      		void Properties.<clinit>() 
      		void Properties.store(OutputStream,String) 
      		Enumeration Properties.propertyNames() 
      		Properties.<init>(Properties) 
      		void Properties.writeComments(BufferedWriter,String) 
      		String Properties.getProperty(String,String) 
      		void Properties.enumerateStringProperties(Hashtable) 
      		String Properties.getProperty(String) 
      		char Properties.toHex(int) 
      		void Properties.storeToXML(OutputStream,String) 
      		Properties.<init>() 
      		void Properties.load0(Properties$LineReader) 
      		void Properties.list(PrintStream) 
      		void Properties.load(InputStream) 
      		String Properties.saveConvert(String,boolean,boolean) 
      		Object Properties.setProperty(String,String) 
      		void Properties.enumerate(Hashtable) 
      		String Properties.loadConvert(char[],int,int,char[]) 
      		void Properties.loadFromXML(InputStream) 
      		Set Properties.stringPropertyNames() 
      		void Properties.load(Reader) 
      		void Properties.save(OutputStream,String) 
      		void Properties.store0(BufferedWriter,String,boolean) 
      		void Properties.storeToXML(OutputStream,String,String) 
      		void Properties.list(PrintWriter) 
      		void Properties.store(Writer,String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.util.calendar.Gregorian
TYPE: class sun.util.calendar.Gregorian 
      	fields: {
      		sun.util.calendar.Era*[_*_](*) eras <>
      	}
      	supers: {
      		class sun.util.calendar.BaseCalendar
      	}
      	methods: {
      		Gregorian$Date Gregorian.newCalendarDate(TimeZone) 
      		Gregorian$Date Gregorian.getCalendarDate() 
      		CalendarDate Gregorian.newCalendarDate() 
      		CalendarDate Gregorian.getCalendarDate(long) 
      		Gregorian.<init>() 
      		String Gregorian.getName() 
      		Gregorian$Date Gregorian.getCalendarDate(long,TimeZone) 
      		Gregorian$Date Gregorian.getCalendarDate(long,CalendarDate) 
      		CalendarDate Gregorian.getCalendarDate() 
      		Gregorian$Date Gregorian.newCalendarDate() 
      		CalendarDate Gregorian.getCalendarDate(long,CalendarDate) 
      		CalendarDate Gregorian.newCalendarDate(TimeZone) 
      		Gregorian$Date Gregorian.getCalendarDate(long) 
      		CalendarDate Gregorian.getCalendarDate(long,TimeZone)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.helpers.SecurityHelper
TYPE: class com.stn.helpers.SecurityHelper 
      	fields: {
      		java.security.SecureRandom* rnd <> 
      		java.lang.String* AB <> 
      		signed char[_*_](*) salt <> 
      		java.lang.String* dbUser <> 
      		java.sql.PreparedStatement* preparedStatement <> 
      		java.lang.String* query <> 
      		java.lang.String* dbPort <> 
      		java.lang.String* dbHost <> 
      		java.lang.String* dbPassword <> 
      		java.sql.ResultSet* resultSet <> 
      		java.sql.Connection* connection <> 
      		java.lang.String* dbName <>
      	}
      	supers: {
      		class com.stn.utils.DBConnection
      	}
      	methods: {
      		void SecurityHelper.<clinit>() 
      		String SecurityHelper.getHash(String) 
      		int SecurityHelper.getAttempts(HttpServletRequest) 
      		SecurityHelper.<init>() 
      		byte[] SecurityHelper.getSalt() 
      		void SecurityHelper.generateSalt() 
      		String SecurityHelper.getClientIpAddress(HttpServletRequest) 
      		void SecurityHelper.updateAttempts(String) 
      		String SecurityHelper.generateRandomString(int) 
      		void SecurityHelper.setSalt(byte[])
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.JoinGrupaProcess
TYPE: class com.stn.servlets.JoinGrupaProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void JoinGrupaProcess.doPost(HttpServletRequest,HttpServletResponse) 
      		JoinGrupaProcess.<init>()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/JoinGrupaProcess")>
      	}NAME: class java.security.NoSuchAlgorithmException
TYPE: class java.security.NoSuchAlgorithmException 
      	fields: {
      		java.lang.String* detailMessage <> 
      		java.lang.Object* backtrace <> 
      		java.lang.StackTraceElement*[_*_](*) stackTrace <> 
      		java.lang.Throwable* cause <> 
      		java.util.List* suppressedExceptions <>
      	}
      	supers: {
      		class java.security.GeneralSecurityException
      	}
      	methods: {
      		NoSuchAlgorithmException.<init>(String,Throwable) 
      		NoSuchAlgorithmException.<init>() 
      		NoSuchAlgorithmException.<init>(Throwable) 
      		NoSuchAlgorithmException.<init>(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.Time
TYPE: class java.sql.Time 
      	fields: {
      		sun.util.calendar.BaseCalendar$Date* cdate <> 
      		long fastTime <>
      	}
      	supers: {
      		class java.util.Date
      	}
      	methods: {
      		int Time.getDay() 
      		Time Time.valueOf(LocalTime) 
      		LocalTime Time.toLocalTime() 
      		Time.<init>(int,int,int) 
      		void Time.setTime(long) 
      		Instant Time.toInstant() 
      		void Time.setMonth(int) 
      		int Time.getMonth() 
      		void Time.setYear(int) 
      		String Time.toString() 
      		int Time.getYear() 
      		Time Time.valueOf(String) 
      		void Time.setDate(int) 
      		Time.<init>(long) 
      		int Time.getDate()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.Store
TYPE: class javax.mail.Store 
      	fields: {
      		java.util.Vector* folderListeners <_volatile> 
      		java.util.Vector* storeListeners <_volatile> 
      		java.util.Vector* connectionListeners <_final> 
      		javax.mail.Session* session <> 
      		javax.mail.EventQueue* q <> 
      		javax.mail.URLName* url <> 
      		java.lang.Object* qLock <> 
      		_Bool debug <> 
      		_Bool connected <>
      	}
      	supers: {
      		class javax.mail.Service
      	}
      	methods: {
      		Folder Store.getDefaultFolder() 
      		Folder Store.getFolder(URLName) 
      		void Store.addStoreListener(StoreListener) 
      		Folder Store.getFolder(String) 
      		void Store.removeFolderListener(FolderListener) 
      		Store.<init>(Session,URLName) 
      		void Store.notifyStoreListeners(int,String) 
      		Folder[] Store.getUserNamespaces(String) 
      		void Store.notifyFolderRenamedListeners(Folder,Folder) 
      		void Store.removeStoreListener(StoreListener) 
      		Folder[] Store.getPersonalNamespaces() 
      		void Store.notifyFolderListeners(int,Folder) 
      		void Store.addFolderListener(FolderListener) 
      		Folder[] Store.getSharedNamespaces()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.AsyncContext
TYPE: class javax.servlet.AsyncContext 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		long AsyncContext.getTimeout() 
      		void AsyncContext.dispatch(String) 
      		ServletRequest AsyncContext.getRequest() 
      		void AsyncContext.addListener(AsyncListener) 
      		void AsyncContext.complete() 
      		boolean AsyncContext.hasOriginalRequestAndResponse() 
      		AsyncListener AsyncContext.createListener(Class) 
      		void AsyncContext.dispatch(ServletContext,String) 
      		ServletResponse AsyncContext.getResponse() 
      		void AsyncContext.addListener(AsyncListener,ServletRequest,ServletResponse) 
      		void AsyncContext.start(Runnable) 
      		void AsyncContext.dispatch() 
      		void AsyncContext.setTimeout(long)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.http.HttpServlet
TYPE: class javax.servlet.http.HttpServlet 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.GenericServlet
      	}
      	methods: {
      		void HttpServlet.<clinit>() 
      		void HttpServlet.doOptions(HttpServletRequest,HttpServletResponse) 
      		void HttpServlet.doPost(HttpServletRequest,HttpServletResponse) 
      		Method[] HttpServlet.getAllDeclaredMethods(Class) 
      		HttpServlet.<init>() 
      		void HttpServlet.doPut(HttpServletRequest,HttpServletResponse) 
      		void HttpServlet.doGet(HttpServletRequest,HttpServletResponse) 
      		long HttpServlet.getLastModified(HttpServletRequest) 
      		void HttpServlet.doTrace(HttpServletRequest,HttpServletResponse) 
      		void HttpServlet.doHead(HttpServletRequest,HttpServletResponse) 
      		void HttpServlet.service(HttpServletRequest,HttpServletResponse) 
      		void HttpServlet.maybeSetLastModified(HttpServletResponse,long) 
      		void HttpServlet.doDelete(HttpServletRequest,HttpServletResponse) 
      		void HttpServlet.service(ServletRequest,ServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.DispatcherType
TYPE: class javax.servlet.DispatcherType 
      	fields: {
      		java.lang.String* name <_final> 
      		int ordinal <_final>
      	}
      	supers: {
      		class java.lang.Enum
      	}
      	methods: {
      		void DispatcherType.<clinit>() 
      		DispatcherType.<init>(String,int) 
      		DispatcherType[] DispatcherType.values() 
      		DispatcherType DispatcherType.valueOf(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.ResultSet
TYPE: class java.sql.ResultSet 
      	fields: {
      	}
      	supers: {
      		class java.sql.Wrapper 
      		class java.lang.AutoCloseable
      	}
      	methods: {
      		Reader ResultSet.getCharacterStream(int) 
      		void ResultSet.updateCharacterStream(int,Reader) 
      		void ResultSet.moveToCurrentRow() 
      		void ResultSet.updateTime(int,Time) 
      		boolean ResultSet.next() 
      		SQLWarning ResultSet.getWarnings() 
      		void ResultSet.updateNString(int,String) 
      		int ResultSet.getConcurrency() 
      		Timestamp ResultSet.getTimestamp(int,Calendar) 
      		void ResultSet.updateString(String,String) 
      		void ResultSet.updateAsciiStream(int,InputStream,long) 
      		boolean ResultSet.getBoolean(String) 
      		void ResultSet.beforeFirst() 
      		void ResultSet.updateNClob(int,Reader) 
      		Ref ResultSet.getRef(String) 
      		int ResultSet.getFetchSize() 
      		void ResultSet.updateBoolean(String,boolean) 
      		int ResultSet.getHoldability() 
      		void ResultSet.updateSQLXML(int,SQLXML) 
      		float ResultSet.getFloat(int) 
      		void ResultSet.updateInt(int,int) 
      		boolean ResultSet.isClosed() 
      		void ResultSet.updateClob(int,Clob) 
      		void ResultSet.updateObject(String,Object,int) 
      		void ResultSet.updateClob(int,Reader,long) 
      		Time ResultSet.getTime(String) 
      		boolean ResultSet.isBeforeFirst() 
      		void ResultSet.updateBlob(int,InputStream) 
      		Blob ResultSet.getBlob(int) 
      		void ResultSet.updateCharacterStream(int,Reader,int) 
      		NClob ResultSet.getNClob(int) 
      		boolean ResultSet.getBoolean(int) 
      		void ResultSet.updateNull(int) 
      		void ResultSet.updateRef(int,Ref) 
      		void ResultSet.updateTimestamp(String,Timestamp) 
      		void ResultSet.updateBinaryStream(String,InputStream,long) 
      		float ResultSet.getFloat(String) 
      		int ResultSet.getRow() 
      		void ResultSet.updateObject(int,Object,SQLType,int) 
      		Date ResultSet.getDate(int,Calendar) 
      		void ResultSet.updateLong(String,long) 
      		Reader ResultSet.getNCharacterStream(int) 
      		Time ResultSet.getTime(int) 
      		void ResultSet.updateBigDecimal(int,BigDecimal) 
      		RowId ResultSet.getRowId(int) 
      		void ResultSet.deleteRow() 
      		void ResultSet.updateNCharacterStream(int,Reader) 
      		String ResultSet.getCursorName() 
      		BigDecimal ResultSet.getBigDecimal(int) 
      		void ResultSet.updateBinaryStream(String,InputStream) 
      		Object ResultSet.getObject(int,Map) 
      		void ResultSet.updateAsciiStream(int,InputStream,int) 
      		byte[] ResultSet.getBytes(int) 
      		void ResultSet.updateNClob(int,NClob) 
      		boolean ResultSet.rowInserted() 
      		URL ResultSet.getURL(int) 
      		void ResultSet.updateDate(String,Date) 
      		void ResultSet.updateCharacterStream(int,Reader,long) 
      		short ResultSet.getShort(String) 
      		boolean ResultSet.first() 
      		Object ResultSet.getObject(int,Class) 
      		Clob ResultSet.getClob(String) 
      		void ResultSet.updateShort(String,short) 
      		String ResultSet.getNString(int) 
      		BigDecimal ResultSet.getBigDecimal(int,int) 
      		void ResultSet.close() 
      		void ResultSet.updateFloat(int,float) 
      		ResultSetMetaData ResultSet.getMetaData() 
      		void ResultSet.updateArray(int,Array) 
      		void ResultSet.insertRow() 
      		void ResultSet.updateNClob(int,Reader,long) 
      		InputStream ResultSet.getUnicodeStream(String) 
      		boolean ResultSet.isFirst() 
      		void ResultSet.updateClob(int,Reader) 
      		Array ResultSet.getArray(int) 
      		int ResultSet.getFetchDirection() 
      		void ResultSet.updateObject(int,Object) 
      		Timestamp ResultSet.getTimestamp(int) 
      		SQLXML ResultSet.getSQLXML(int) 
      		short ResultSet.getShort(int) 
      		void ResultSet.updateByte(int,byte) 
      		void ResultSet.updateBlob(int,Blob) 
      		void ResultSet.updateBinaryStream(String,InputStream,int) 
      		void ResultSet.updateBlob(int,InputStream,long) 
      		BigDecimal ResultSet.getBigDecimal(String,int) 
      		boolean ResultSet.relative(int) 
      		void ResultSet.updateObject(int,Object,SQLType) 
      		Time ResultSet.getTime(int,Calendar) 
      		void ResultSet.updateDouble(String,double) 
      		void ResultSet.updateNCharacterStream(int,Reader,long) 
      		InputStream ResultSet.getUnicodeStream(int) 
      		void ResultSet.updateBytes(int,byte[]) 
      		void ResultSet.updateRowId(int,RowId) 
      		void ResultSet.cancelRowUpdates() 
      		void ResultSet.updateAsciiStream(int,InputStream) 
      		Object ResultSet.getObject(String) 
      		String ResultSet.getString(String) 
      		Reader ResultSet.getCharacterStream(String) 
      		void ResultSet.updateAsciiStream(String,InputStream) 
      		Statement ResultSet.getStatement() 
      		void ResultSet.updateTimestamp(int,Timestamp) 
      		int ResultSet.getInt(int) 
      		void ResultSet.clearWarnings() 
      		void ResultSet.updateNString(String,String) 
      		boolean ResultSet.rowUpdated() 
      		Timestamp ResultSet.getTimestamp(String,Calendar) 
      		void ResultSet.updateBytes(String,byte[]) 
      		void ResultSet.updateBinaryStream(int,InputStream,long) 
      		byte ResultSet.getByte(String) 
      		void ResultSet.afterLast() 
      		void ResultSet.updateNClob(String,Reader) 
      		Blob ResultSet.getBlob(String) 
      		void ResultSet.updateByte(String,byte) 
      		void ResultSet.updateSQLXML(String,SQLXML) 
      		double ResultSet.getDouble(int) 
      		byte[] ResultSet.getBytes(String) 
      		void ResultSet.updateLong(int,long) 
      		void ResultSet.updateClob(String,Clob) 
      		void ResultSet.updateObject(String,Object) 
      		void ResultSet.updateClob(String,Reader,long) 
      		InputStream ResultSet.getAsciiStream(String) 
      		boolean ResultSet.isAfterLast() 
      		void ResultSet.updateBlob(String,InputStream) 
      		Clob ResultSet.getClob(int) 
      		void ResultSet.setFetchDirection(int) 
      		void ResultSet.updateObject(int,Object,int) 
      		NClob ResultSet.getNClob(String) 
      		byte ResultSet.getByte(int) 
      		void ResultSet.updateBoolean(int,boolean) 
      		void ResultSet.updateRef(String,Ref) 
      		void ResultSet.updateAsciiStream(String,InputStream,int) 
      		void ResultSet.updateCharacterStream(String,Reader,long) 
      		double ResultSet.getDouble(String) 
      		boolean ResultSet.absolute(int) 
      		void ResultSet.updateObject(String,Object,SQLType,int) 
      		Date ResultSet.getDate(String,Calendar) 
      		void ResultSet.updateFloat(String,float) 
      		int ResultSet.getType() 
      		Reader ResultSet.getNCharacterStream(String) 
      		InputStream ResultSet.getAsciiStream(int) 
      		void ResultSet.updateString(int,String) 
      		RowId ResultSet.getRowId(String) 
      		int ResultSet.getInt(String) 
      		void ResultSet.refreshRow() 
      		void ResultSet.updateNCharacterStream(String,Reader) 
      		Object ResultSet.getObject(int) 
      		BigDecimal ResultSet.getBigDecimal(String) 
      		void ResultSet.updateCharacterStream(String,Reader) 
      		Ref ResultSet.getRef(int) 
      		void ResultSet.updateBinaryStream(int,InputStream,int) 
      		String ResultSet.getString(int) 
      		void ResultSet.updateNClob(String,NClob) 
      		boolean ResultSet.wasNull() 
      		boolean ResultSet.rowDeleted() 
      		URL ResultSet.getURL(String) 
      		void ResultSet.updateTime(String,Time) 
      		void ResultSet.updateAsciiStream(String,InputStream,long) 
      		long ResultSet.getLong(String) 
      		boolean ResultSet.last() 
      		Object ResultSet.getObject(String,Class) 
      		Array ResultSet.getArray(String) 
      		void ResultSet.updateInt(String,int) 
      		String ResultSet.getNString(String) 
      		Date ResultSet.getDate(int) 
      		void ResultSet.updateDouble(int,double) 
      		void ResultSet.updateArray(String,Array) 
      		Timestamp ResultSet.getTimestamp(String) 
      		void ResultSet.updateRow() 
      		void ResultSet.updateNClob(String,Reader,long) 
      		InputStream ResultSet.getBinaryStream(String) 
      		boolean ResultSet.isLast() 
      		void ResultSet.updateClob(String,Reader) 
      		Object ResultSet.getObject(String,Map) 
      		void ResultSet.setFetchSize(int) 
      		void ResultSet.updateNull(String) 
      		SQLXML ResultSet.getSQLXML(String) 
      		long ResultSet.getLong(int) 
      		void ResultSet.updateShort(int,short) 
      		void ResultSet.updateBlob(String,Blob) 
      		void ResultSet.updateCharacterStream(String,Reader,int) 
      		void ResultSet.updateBlob(String,InputStream,long) 
      		Date ResultSet.getDate(String) 
      		boolean ResultSet.previous() 
      		void ResultSet.updateObject(String,Object,SQLType) 
      		Time ResultSet.getTime(String,Calendar) 
      		void ResultSet.updateBigDecimal(String,BigDecimal) 
      		void ResultSet.updateNCharacterStream(String,Reader,long) 
      		InputStream ResultSet.getBinaryStream(int) 
      		void ResultSet.updateDate(int,Date) 
      		void ResultSet.updateRowId(String,RowId) 
      		void ResultSet.moveToInsertRow() 
      		void ResultSet.updateBinaryStream(int,InputStream) 
      		int ResultSet.findColumn(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.pojo.Topic
TYPE: class com.stn.pojo.Topic 
      	fields: {
      		java.lang.String* name <> 
      		int totalposts <> 
      		int groupId <> 
      		int authorClass <> 
      		int authorId <> 
      		int topicId <> 
      		java.lang.String* authorName <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		int Topic.getTotalposts() 
      		void Topic.setAuthorId(int) 
      		int Topic.getGroupId() 
      		void Topic.setAuthorClass(int) 
      		Topic.<init>() 
      		String Topic.getName() 
      		void Topic.setName(String) 
      		int Topic.getAuthorClass() 
      		void Topic.setAuthorName(String) 
      		void Topic.setTopicId(int) 
      		int Topic.getAuthorId() 
      		int Topic.getTopicId() 
      		void Topic.setTotalposts(int) 
      		void Topic.setGroupId(int) 
      		String Topic.getAuthorName()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Enum
TYPE: class java.lang.Enum 
      	fields: {
      		java.lang.String* name <_final> 
      		int ordinal <_final>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.lang.Comparable 
      		class java.io.Serializable
      	}
      	methods: {
      		Enum.<init>(String,int) 
      		int Enum.hashCode() 
      		boolean Enum.equals(Object) 
      		int Enum.compareTo(Object) 
      		Object Enum.clone() 
      		Class Enum.getDeclaringClass() 
      		void Enum.readObjectNoData() 
      		void Enum.finalize() 
      		void Enum.readObject(ObjectInputStream) 
      		Enum Enum.valueOf(Class,String) 
      		String Enum.name() 
      		String Enum.toString() 
      		int Enum.ordinal() 
      		int Enum.compareTo(Enum)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.management.NotificationFilter
TYPE: class javax.management.NotificationFilter 
      	fields: {
      	}
      	supers: {
      		class java.io.Serializable
      	}
      	methods: {
      		boolean NotificationFilter.isNotificationEnabled(Notification)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.LinkedHashMap$Entry
TYPE: class java.util.LinkedHashMap$Entry 
      	fields: {
      		java.util.LinkedHashMap$Entry* after <> 
      		java.util.LinkedHashMap$Entry* before <> 
      		java.util.HashMap$Node* next <> 
      		java.lang.Object* key <_final> 
      		java.lang.Object* value <> 
      		int hash <_final>
      	}
      	supers: {
      		class java.util.HashMap$Node
      	}
      	methods: {
      		LinkedHashMap$Entry.<init>(int,Object,Object,HashMap$Node)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Runnable
TYPE: class java.lang.Runnable 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void Runnable.run()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.net.URL
TYPE: class java.net.URL 
      	fields: {
      		java.lang.String* path <> 
      		int port <> 
      		java.lang.String* authority <> 
      		java.lang.String* query <> 
      		java.lang.String* host <> 
      		java.lang.String* userInfo <> 
      		java.lang.String* ref <> 
      		java.lang.String* protocol <> 
      		java.net.InetAddress* hostAddress <> 
      		java.net.URLStreamHandler* handler <> 
      		int hashCode <> 
      		java.net.UrlDeserializedState* tempState <> 
      		java.lang.String* file <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable
      	}
      	methods: {
      		void URL.<clinit>() 
      		int URL.hashCode() 
      		URI URL.toURI() 
      		URLConnection URL.openConnection() 
      		boolean URL.equals(Object) 
      		String URL.getQuery() 
      		boolean URL.isBuiltinStreamHandler(String) 
      		String URL.getRef() 
      		void URL.set(String,String,int,String,String) 
      		URL.<init>(URL,String) 
      		void URL.writeObject(ObjectOutputStream) 
      		String URL.getProtocol() 
      		void URL.setURLStreamHandlerFactory(URLStreamHandlerFactory) 
      		void URL.resetState() 
      		URL.<init>(String,String,int,String,URLStreamHandler) 
      		boolean URL.isBuiltinStreamHandler(URLStreamHandler) 
      		String URL.getPath() 
      		URL URL.setDeserializedFields(URLStreamHandler) 
      		String URL.getUserInfo() 
      		URLConnection URL.openConnection(Proxy) 
      		String URL.getFile() 
      		void URL.readObject(ObjectInputStream) 
      		InputStream URL.openStream() 
      		URLStreamHandler URL.getURLStreamHandler(String) 
      		URL URL.fabricateNewURL() 
      		void URL.set(String,String,int,String,String,String,String,String) 
      		URL.<init>(URL,String,URLStreamHandler) 
      		String URL.toString() 
      		int URL.getPort() 
      		boolean URL.isValidProtocol(String) 
      		String URL.toExternalForm() 
      		void URL.setSerializedHashCode(int) 
      		URL.<init>(String,String,int,String) 
      		Object URL.readResolve() 
      		URL.<init>(String) 
      		String URL.getAuthority() 
      		void URL.checkSpecifyHandler(SecurityManager) 
      		String URL.getHost() 
      		boolean URL.sameFile(URL) 
      		URL.<init>(String,String,String) 
      		int URL.getDefaultPort() 
      		Object URL.getContent() 
      		Object URL.getContent(Class[])
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.PrimitiveIterator
TYPE: class java.util.PrimitiveIterator 
      	fields: {
      	}
      	supers: {
      		class java.util.Iterator
      	}
      	methods: {
      		void PrimitiveIterator.forEachRemaining(Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.StackTraceElement
TYPE: class java.lang.StackTraceElement 
      	fields: {
      		java.lang.String* fileName <> 
      		java.lang.String* declaringClass <> 
      		int lineNumber <> 
      		java.lang.String* methodName <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable
      	}
      	methods: {
      		int StackTraceElement.hashCode() 
      		boolean StackTraceElement.isNativeMethod() 
      		boolean StackTraceElement.equals(Object) 
      		String StackTraceElement.getFileName() 
      		int StackTraceElement.getLineNumber() 
      		StackTraceElement.<init>(String,String,String,int) 
      		String StackTraceElement.toString() 
      		String StackTraceElement.getMethodName() 
      		String StackTraceElement.getClassName()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.pojo.Aplicatie
TYPE: class com.stn.pojo.Aplicatie 
      	fields: {
      		int appId <> 
      		int type <> 
      		java.lang.String* serie <> 
      		java.lang.String* prenume <> 
      		java.lang.String* email <> 
      		java.sql.Timestamp* date <> 
      		java.lang.String* nume <> 
      		java.lang.String* grupa <> 
      		java.lang.String* facultate <> 
      		java.lang.String* document <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		String Aplicatie.getFacultate() 
      		void Aplicatie.setDocument(String) 
      		Timestamp Aplicatie.getDate() 
      		void Aplicatie.setNume(String) 
      		String Aplicatie.getGrupa() 
      		int Aplicatie.getAppId() 
      		void Aplicatie.setEmail(String) 
      		void Aplicatie.setSerie(String) 
      		void Aplicatie.setAppId(int) 
      		String Aplicatie.getSerie() 
      		Aplicatie.<init>(int,String,String,String,String,String,String,String,Timestamp,int) 
      		void Aplicatie.setType(int) 
      		int Aplicatie.getType() 
      		void Aplicatie.setGrupa(String) 
      		String Aplicatie.getNume() 
      		String Aplicatie.getEmail() 
      		void Aplicatie.setPrenume(String) 
      		String Aplicatie.getDocument() 
      		String Aplicatie.getPrenume() 
      		void Aplicatie.setDate(Timestamp) 
      		void Aplicatie.setFacultate(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.http.HttpUpgradeHandler
TYPE: class javax.servlet.http.HttpUpgradeHandler 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void HttpUpgradeHandler.destroy() 
      		void HttpUpgradeHandler.init(WebConnection)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.util.calendar.AbstractCalendar
TYPE: class sun.util.calendar.AbstractCalendar 
      	fields: {
      		sun.util.calendar.Era*[_*_](*) eras <>
      	}
      	supers: {
      		class sun.util.calendar.CalendarSystem
      	}
      	methods: {
      		void AbstractCalendar.setEra(CalendarDate,String) 
      		int AbstractCalendar.normalizeTime(CalendarDate) 
      		long AbstractCalendar.getDayOfWeekDateAfter(long,int) 
      		CalendarDate AbstractCalendar.getNthDayOfWeek(int,int,CalendarDate) 
      		long AbstractCalendar.getTimeOfDayValue(CalendarDate) 
      		CalendarDate AbstractCalendar.getCalendarDate(long) 
      		AbstractCalendar.<init>() 
      		Era AbstractCalendar.getEra(String) 
      		CalendarDate AbstractCalendar.setTimeOfDay(CalendarDate,int) 
      		CalendarDate AbstractCalendar.getCalendarDate() 
      		long AbstractCalendar.getFixedDate(CalendarDate) 
      		void AbstractCalendar.setEras(Era[]) 
      		long AbstractCalendar.getDayOfWeekDateOnOrBefore(long,int) 
      		CalendarDate AbstractCalendar.getCalendarDate(long,CalendarDate) 
      		long AbstractCalendar.getDayOfWeekDateBefore(long,int) 
      		long AbstractCalendar.getTime(CalendarDate) 
      		int AbstractCalendar.getWeekLength() 
      		void AbstractCalendar.getCalendarDateFromFixedDate(CalendarDate,long) 
      		boolean AbstractCalendar.isLeapYear(CalendarDate) 
      		Era[] AbstractCalendar.getEras() 
      		boolean AbstractCalendar.validateTime(CalendarDate) 
      		CalendarDate AbstractCalendar.getCalendarDate(long,TimeZone) 
      		long AbstractCalendar.getTimeOfDay(CalendarDate)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.ResetProcess
TYPE: class com.stn.servlets.ResetProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void ResetProcess.doPost(HttpServletRequest,HttpServletResponse) 
      		ResetProcess.<init>() 
      		void ResetProcess.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/ResetProcess")>
      	}NAME: class javax.mail.MessagingException
TYPE: class javax.mail.MessagingException 
      	fields: {
      		java.lang.Exception* next <> 
      		java.lang.String* detailMessage <> 
      		java.lang.Object* backtrace <> 
      		java.lang.StackTraceElement*[_*_](*) stackTrace <> 
      		java.lang.Throwable* cause <> 
      		java.util.List* suppressedExceptions <>
      	}
      	supers: {
      		class java.lang.Exception
      	}
      	methods: {
      		boolean MessagingException.setNextException(Exception) 
      		MessagingException.<init>(String,Exception) 
      		MessagingException.<init>() 
      		String MessagingException.superToString() 
      		Throwable MessagingException.getCause() 
      		String MessagingException.toString() 
      		Exception MessagingException.getNextException() 
      		MessagingException.<init>(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.security.Principal
TYPE: class java.security.Principal 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		int Principal.hashCode() 
      		boolean Principal.equals(Object) 
      		String Principal.getName() 
      		boolean Principal.implies(Subject) 
      		String Principal.toString()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Spliterator$OfInt
TYPE: class java.util.Spliterator$OfInt 
      	fields: {
      	}
      	supers: {
      		class java.util.Spliterator$OfPrimitive
      	}
      	methods: {
      		void Spliterator$OfInt.forEachRemaining(Consumer) 
      		boolean Spliterator$OfInt.tryAdvance(IntConsumer) 
      		Spliterator Spliterator$OfInt.trySplit() 
      		Spliterator$OfInt Spliterator$OfInt.trySplit() 
      		IntConsumer Spliterator$OfInt.callsite_java.util.Spliterator$OfInt$Lambda$_5_40(Consumer) 
      		boolean Spliterator$OfInt.tryAdvance(Object) 
      		boolean Spliterator$OfInt.tryAdvance(Consumer) 
      		IntConsumer Spliterator$OfInt.callsite_java.util.Spliterator$OfInt$Lambda$_2_42(Consumer) 
      		void Spliterator$OfInt.forEachRemaining(Object) 
      		void Spliterator$OfInt.access_java.util.Spliterator$OfInt$Lambda$_5_40(Spliterator$OfInt,Object) 
      		void Spliterator$OfInt.forEachRemaining(IntConsumer) 
      		void Spliterator$OfInt.access_java.util.Spliterator$OfInt$Lambda$_2_42(Spliterator$OfInt,Object) 
      		Spliterator$OfPrimitive Spliterator$OfInt.trySplit()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.search.SearchTerm
TYPE: class javax.mail.search.SearchTerm 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable
      	}
      	methods: {
      		SearchTerm.<init>() 
      		boolean SearchTerm.match(Message)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.time.chrono.ChronoLocalDateTime
TYPE: class java.time.chrono.ChronoLocalDateTime 
      	fields: {
      	}
      	supers: {
      		class java.time.temporal.Temporal 
      		class java.time.temporal.TemporalAdjuster 
      		class java.lang.Comparable
      	}
      	methods: {
      		int ChronoLocalDateTime.compareTo(ChronoLocalDateTime) 
      		int ChronoLocalDateTime.hashCode() 
      		long ChronoLocalDateTime.toEpochSecond(ZoneOffset) 
      		boolean ChronoLocalDateTime.equals(Object) 
      		ChronoLocalDateTime ChronoLocalDateTime.minus(long,TemporalUnit) 
      		boolean ChronoLocalDateTime.isAfter(ChronoLocalDateTime) 
      		Temporal ChronoLocalDateTime.plus(TemporalAmount) 
      		int ChronoLocalDateTime.compareTo(Object) 
      		Comparator ChronoLocalDateTime.timeLineOrder() 
      		ChronoLocalDateTime ChronoLocalDateTime.with(TemporalField,long) 
      		LocalTime ChronoLocalDateTime.toLocalTime() 
      		Object ChronoLocalDateTime.query(TemporalQuery) 
      		Temporal ChronoLocalDateTime.minus(TemporalAmount) 
      		ChronoLocalDateTime ChronoLocalDateTime.plus(long,TemporalUnit) 
      		boolean ChronoLocalDateTime.isEqual(ChronoLocalDateTime) 
      		Temporal ChronoLocalDateTime.with(TemporalAdjuster) 
      		Instant ChronoLocalDateTime.toInstant(ZoneOffset) 
      		ChronoLocalDate ChronoLocalDateTime.toLocalDate() 
      		Temporal ChronoLocalDateTime.minus(long,TemporalUnit) 
      		Chronology ChronoLocalDateTime.getChronology() 
      		ChronoLocalDateTime ChronoLocalDateTime.minus(TemporalAmount) 
      		boolean ChronoLocalDateTime.isBefore(ChronoLocalDateTime) 
      		boolean ChronoLocalDateTime.isSupported(TemporalUnit) 
      		Temporal ChronoLocalDateTime.with(TemporalField,long) 
      		ChronoLocalDateTime ChronoLocalDateTime.from(TemporalAccessor) 
      		String ChronoLocalDateTime.toString() 
      		String ChronoLocalDateTime.format(DateTimeFormatter) 
      		ChronoLocalDateTime ChronoLocalDateTime.with(TemporalAdjuster) 
      		Temporal ChronoLocalDateTime.plus(long,TemporalUnit) 
      		ChronoLocalDateTime ChronoLocalDateTime.plus(TemporalAmount) 
      		boolean ChronoLocalDateTime.isSupported(TemporalField) 
      		ChronoZonedDateTime ChronoLocalDateTime.atZone(ZoneId) 
      		Temporal ChronoLocalDateTime.adjustInto(Temporal)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.internet.InternetAddress
TYPE: class javax.mail.internet.InternetAddress 
      	fields: {
      		java.lang.String* personal <> 
      		java.lang.String* address <> 
      		java.lang.String* encodedPersonal <>
      	}
      	supers: {
      		class javax.mail.Address 
      		class java.lang.Cloneable
      	}
      	methods: {
      		void InternetAddress.<clinit>() 
      		int InternetAddress.hashCode() 
      		boolean InternetAddress.isSimple() 
      		boolean InternetAddress.equals(Object) 
      		InternetAddress InternetAddress._getLocalAddress(Session) 
      		void InternetAddress.setPersonal(String,String) 
      		String InternetAddress.unquote(String) 
      		Object InternetAddress.clone() 
      		InternetAddress[] InternetAddress.parse(String) 
      		int InternetAddress.lengthOfLastSegment(String,int) 
      		InternetAddress InternetAddress.getLocalAddress(Session) 
      		InternetAddress[] InternetAddress.getGroup(boolean) 
      		InternetAddress.<init>(String,boolean) 
      		InternetAddress[] InternetAddress.parse(String,boolean,boolean) 
      		String InternetAddress.getAddress() 
      		String InternetAddress.toUnicodeString() 
      		InternetAddress.<init>() 
      		InternetAddress.<init>(String,String) 
      		InternetAddress[] InternetAddress.parseHeader(String,boolean) 
      		boolean InternetAddress.isGroup() 
      		boolean InternetAddress.isInetAddressLiteral(String) 
      		String InternetAddress.getPersonal() 
      		void InternetAddress.setPersonal(String) 
      		void InternetAddress.validate() 
      		int InternetAddress.indexOfAny(String,String,int) 
      		String InternetAddress.toString() 
      		String InternetAddress.getLocalHostName() 
      		InternetAddress[] InternetAddress.parse(String,boolean) 
      		String InternetAddress.toString(Address[]) 
      		void InternetAddress.checkAddress(String,boolean,boolean) 
      		void InternetAddress.setAddress(String) 
      		int InternetAddress.lengthOfFirstSegment(String) 
      		InternetAddress.<init>(String) 
      		String InternetAddress.quotePhrase(String) 
      		int InternetAddress.indexOfAny(String,String) 
      		String InternetAddress.getType() 
      		InternetAddress.<init>(String,String,String) 
      		String InternetAddress.toString(Address[],int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.Session
TYPE: class javax.mail.Session 
      	fields: {
      		java.util.Hashtable* providersByClassName <_final> 
      		java.io.PrintStream* out <> 
      		java.util.Properties* props <_final> 
      		java.util.Hashtable* authTable <_final> 
      		com.sun.mail.util.MailLogger* logger <> 
      		java.util.Vector* providers <_final> 
      		javax.mail.Authenticator* authenticator <_final> 
      		_Bool debug <> 
      		java.util.Properties* addressMap <_final> 
      		java.util.Hashtable* providersByProtocol <_final>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Session.<clinit>() 
      		PrintStream Session.getDebugOut() 
      		URL[] Session.getSystemResources(String) 
      		Folder Session.getFolder(URLName) 
      		Transport Session.getTransport(Address) 
      		Store Session.getStore(String) 
      		boolean Session.getDebug() 
      		void Session.loadResource(String,Class,StreamLoader) 
      		Session Session.getInstance(Properties,Authenticator) 
      		void Session.access$000(Session,InputStream) 
      		Store Session.getStore(Provider,URLName) 
      		Store Session.getStore() 
      		void Session.initLogger() 
      		Session.<init>(Properties,Authenticator) 
      		Transport Session.getTransport(URLName) 
      		String Session.getProperty(String) 
      		PasswordAuthentication Session.getPasswordAuthentication(URLName) 
      		Store Session.getStore(URLName) 
      		Provider[] Session.getProviders() 
      		Session Session.getDefaultInstance(Properties) 
      		void Session.loadFile(String,StreamLoader) 
      		Object Session.getService(Provider,URLName) 
      		Transport Session.getTransport() 
      		InputStream Session.getResourceAsStream(Class,String) 
      		void Session.loadProviders(Class) 
      		InputStream Session.openStream(URL) 
      		Transport Session.getTransport(String) 
      		void Session.setPasswordAuthentication(URLName,PasswordAuthentication) 
      		Session Session.getDefaultInstance(Properties,Authenticator) 
      		void Session.setDebugOut(PrintStream) 
      		Session Session.getInstance(Properties) 
      		PasswordAuthentication Session.requestPasswordAuthentication(InetAddress,int,String,String,String) 
      		Properties Session.access$100(Session) 
      		Store Session.getStore(Provider) 
      		ClassLoader Session.getContextClassLoader() 
      		Transport Session.getTransport(Provider,URLName) 
      		void Session.setProtocolForAddress(String,String) 
      		Provider Session.getProvider(String) 
      		void Session.setProvider(Provider) 
      		void Session.addProvider(Provider) 
      		void Session.loadProvidersFromStream(InputStream) 
      		void Session.setDebug(boolean) 
      		void Session.loadAllResources(String,Class,StreamLoader) 
      		Properties Session.getProperties() 
      		Transport Session.getTransport(Provider) 
      		URL[] Session.getResources(ClassLoader,String) 
      		void Session.loadAddressMap(Class)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Class$EnclosingMethodInfo
TYPE: class java.lang.Class$EnclosingMethodInfo 
      	fields: {
      		java.lang.String* name <> 
      		java.lang.Class* enclosingClass <> 
      		java.lang.String* descriptor <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Class$EnclosingMethodInfo.<clinit>() 
      		boolean Class$EnclosingMethodInfo.isMethod() 
      		String Class$EnclosingMethodInfo.getName() 
      		Class$EnclosingMethodInfo.<init>(Object[]) 
      		Class Class$EnclosingMethodInfo.getEnclosingClass() 
      		Class$EnclosingMethodInfo.<init>(Object[],Class$1) 
      		String Class$EnclosingMethodInfo.getDescriptor() 
      		boolean Class$EnclosingMethodInfo.isConstructor() 
      		boolean Class$EnclosingMethodInfo.isPartial()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.util.locale.LocaleExtensions
TYPE: class sun.util.locale.LocaleExtensions 
      	fields: {
      		java.lang.String* id <_final> 
      		java.util.Map* extensionMap <_final>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void LocaleExtensions.<clinit>() 
      		int LocaleExtensions.hashCode() 
      		Set LocaleExtensions.getKeys() 
      		boolean LocaleExtensions.equals(Object) 
      		Set LocaleExtensions.getUnicodeLocaleKeys() 
      		LocaleExtensions.<init>(String,Character,Extension) 
      		String LocaleExtensions.getID() 
      		String LocaleExtensions.getExtensionValue(Character) 
      		Extension LocaleExtensions.getExtension(Character) 
      		Set LocaleExtensions.getUnicodeLocaleAttributes() 
      		String LocaleExtensions.toID(SortedMap) 
      		String LocaleExtensions.toString() 
      		boolean LocaleExtensions.isValidKey(char) 
      		LocaleExtensions.<init>(Map,Set,Map) 
      		boolean LocaleExtensions.isEmpty() 
      		String LocaleExtensions.getUnicodeLocaleType(String) 
      		boolean LocaleExtensions.isValidUnicodeLocaleKey(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.SQLWarning
TYPE: class java.sql.SQLWarning 
      	fields: {
      		java.lang.String* SQLState <> 
      		java.sql.SQLException* next <_volatile> 
      		int vendorCode <> 
      		java.lang.String* detailMessage <> 
      		java.lang.Object* backtrace <> 
      		java.lang.StackTraceElement*[_*_](*) stackTrace <> 
      		java.lang.Throwable* cause <> 
      		java.util.List* suppressedExceptions <>
      	}
      	supers: {
      		class java.sql.SQLException
      	}
      	methods: {
      		SQLWarning.<init>(String,String,Throwable) 
      		SQLWarning.<init>(String,Throwable) 
      		SQLWarning SQLWarning.getNextWarning() 
      		SQLWarning.<init>() 
      		SQLWarning.<init>(String,String) 
      		SQLWarning.<init>(String,String,int,Throwable) 
      		SQLWarning.<init>(Throwable) 
      		void SQLWarning.setNextWarning(SQLWarning) 
      		SQLWarning.<init>(String) 
      		SQLWarning.<init>(String,String,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.utils.DBConnection
TYPE: class com.stn.utils.DBConnection 
      	fields: {
      		java.lang.String* dbUser <> 
      		java.sql.PreparedStatement* preparedStatement <> 
      		java.lang.String* query <> 
      		java.lang.String* dbPort <> 
      		java.lang.String* dbHost <> 
      		java.lang.String* dbPassword <> 
      		java.sql.ResultSet* resultSet <> 
      		java.sql.Connection* connection <> 
      		java.lang.String* dbName <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		String DBConnection.getUser() 
      		DBConnection.<init>() 
      		String DBConnection.getPassword() 
      		String DBConnection.getHost()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.management.DynamicMBean
TYPE: class javax.management.DynamicMBean 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		AttributeList DynamicMBean.getAttributes(String[]) 
      		Object DynamicMBean.getAttribute(String) 
      		Object DynamicMBean.invoke(String,Object[],String[]) 
      		AttributeList DynamicMBean.setAttributes(AttributeList) 
      		void DynamicMBean.setAttribute(Attribute) 
      		MBeanInfo DynamicMBean.getMBeanInfo()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.ServletRegistration$Dynamic
TYPE: class javax.servlet.ServletRegistration$Dynamic 
      	fields: {
      	}
      	supers: {
      		class javax.servlet.ServletRegistration 
      		class javax.servlet.Registration$Dynamic
      	}
      	methods: {
      		void ServletRegistration$Dynamic.setRunAsRole(String) 
      		Set ServletRegistration$Dynamic.setServletSecurity(ServletSecurityElement) 
      		void ServletRegistration$Dynamic.setLoadOnStartup(int) 
      		void ServletRegistration$Dynamic.setMultipartConfig(MultipartConfigElement)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Throwable
TYPE: class java.lang.Throwable 
      	fields: {
      		java.lang.String* detailMessage <> 
      		java.lang.Object* backtrace <> 
      		java.lang.StackTraceElement*[_*_](*) stackTrace <> 
      		java.lang.Throwable* cause <> 
      		java.util.List* suppressedExceptions <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable
      	}
      	methods: {
      		void Throwable.<clinit>() 
      		void Throwable.setStackTrace(StackTraceElement[]) 
      		void Throwable.printEnclosedStackTrace(Throwable$PrintStreamOrWriter,StackTraceElement[],String,String,Set) 
      		String Throwable.getLocalizedMessage() 
      		Throwable.<init>(String,Throwable,boolean,boolean) 
      		Throwable Throwable.fillInStackTrace(int) 
      		void Throwable.writeObject(ObjectOutputStream) 
      		Throwable.<init>(String,Throwable) 
      		Throwable.<init>() 
      		String Throwable.getMessage() 
      		StackTraceElement Throwable.getStackTraceElement(int) 
      		StackTraceElement[] Throwable.getOurStackTrace() 
      		void Throwable.printStackTrace(PrintWriter) 
      		void Throwable.readObject(ObjectInputStream) 
      		Throwable Throwable.getCause() 
      		void Throwable.printStackTrace(PrintStream) 
      		Throwable Throwable.fillInStackTrace() 
      		int Throwable.getStackTraceDepth() 
      		String Throwable.toString() 
      		Throwable Throwable.initCause(Throwable) 
      		void Throwable.addSuppressed(Throwable) 
      		Throwable.<init>(Throwable) 
      		void Throwable.printStackTrace() 
      		void Throwable.printStackTrace(Throwable$PrintStreamOrWriter) 
      		Throwable.<init>(String) 
      		int Throwable.validateSuppressedExceptionsList(List) 
      		Throwable[] Throwable.getSuppressed() 
      		StackTraceElement[] Throwable.getStackTrace()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.AddNewsProcess
TYPE: class com.stn.servlets.AddNewsProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void AddNewsProcess.doPost(HttpServletRequest,HttpServletResponse) 
      		AddNewsProcess.<init>()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/AddNewsProcess")>
      	}NAME: class java.io.ObjectOutputStream$DebugTraceInfoStack
TYPE: class java.io.ObjectOutputStream$DebugTraceInfoStack 
      	fields: {
      		java.util.List* stack <_final>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void ObjectOutputStream$DebugTraceInfoStack.pop() 
      		ObjectOutputStream$DebugTraceInfoStack.<init>() 
      		String ObjectOutputStream$DebugTraceInfoStack.toString() 
      		void ObjectOutputStream$DebugTraceInfoStack.push(String) 
      		void ObjectOutputStream$DebugTraceInfoStack.clear()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Map
TYPE: class java.util.Map 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		int Map.hashCode() 
      		Object Map.computeIfAbsent(Object,Function) 
      		boolean Map.equals(Object) 
      		boolean Map.containsValue(Object) 
      		Object Map.put(Object,Object) 
      		Object Map.get(Object) 
      		void Map.putAll(Map) 
      		int Map.size() 
      		void Map.replaceAll(BiFunction) 
      		Set Map.keySet() 
      		Object Map.putIfAbsent(Object,Object) 
      		Object Map.compute(Object,BiFunction) 
      		Object Map.getOrDefault(Object,Object) 
      		boolean Map.replace(Object,Object,Object) 
      		Set Map.entrySet() 
      		Object Map.computeIfPresent(Object,BiFunction) 
      		Collection Map.values() 
      		Object Map.remove(Object) 
      		boolean Map.remove(Object,Object) 
      		boolean Map.isEmpty() 
      		Object Map.merge(Object,Object,BiFunction) 
      		void Map.forEach(BiConsumer) 
      		void Map.clear() 
      		boolean Map.containsKey(Object) 
      		Object Map.replace(Object,Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.ObjectInputStream$GetField
TYPE: class java.io.ObjectInputStream$GetField 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		ObjectStreamClass ObjectInputStream$GetField.getObjectStreamClass() 
      		double ObjectInputStream$GetField.get(String,double) 
      		short ObjectInputStream$GetField.get(String,short) 
      		int ObjectInputStream$GetField.get(String,int) 
      		byte ObjectInputStream$GetField.get(String,byte) 
      		ObjectInputStream$GetField.<init>() 
      		long ObjectInputStream$GetField.get(String,long) 
      		boolean ObjectInputStream$GetField.defaulted(String) 
      		boolean ObjectInputStream$GetField.get(String,boolean) 
      		float ObjectInputStream$GetField.get(String,float) 
      		Object ObjectInputStream$GetField.get(String,Object) 
      		char ObjectInputStream$GetField.get(String,char)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.security.SecureRandomSpi
TYPE: class java.security.SecureRandomSpi 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable
      	}
      	methods: {
      		void SecureRandomSpi.engineSetSeed(byte[]) 
      		SecureRandomSpi.<init>() 
      		void SecureRandomSpi.engineNextBytes(byte[]) 
      		byte[] SecureRandomSpi.engineGenerateSeed(int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.RecoverProcess
TYPE: class com.stn.servlets.RecoverProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void RecoverProcess.doPost(HttpServletRequest,HttpServletResponse) 
      		RecoverProcess.<init>() 
      		void RecoverProcess.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/RecoverProcess")>
      	}NAME: class java.sql.DriverAction
TYPE: class java.sql.DriverAction 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void DriverAction.deregister()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.OptionalInt
TYPE: class java.util.OptionalInt 
      	fields: {
      		int value <_final> 
      		_Bool isPresent <_final>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void OptionalInt.<clinit>() 
      		OptionalInt.<init>(int) 
      		int OptionalInt.hashCode() 
      		boolean OptionalInt.equals(Object) 
      		void OptionalInt.ifPresent(IntConsumer) 
      		boolean OptionalInt.isPresent() 
      		OptionalInt OptionalInt.empty() 
      		OptionalInt.<init>() 
      		int OptionalInt.orElseGet(IntSupplier) 
      		int OptionalInt.getAsInt() 
      		String OptionalInt.toString() 
      		int OptionalInt.orElse(int) 
      		OptionalInt OptionalInt.of(int) 
      		int OptionalInt.orElseThrow(Supplier)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Integer
TYPE: class java.lang.Integer 
      	fields: {
      		int value <_final>
      	}
      	supers: {
      		class java.lang.Number 
      		class java.lang.Comparable
      	}
      	methods: {
      		void Integer.<clinit>() 
      		Integer.<init>(int) 
      		int Integer.hashCode() 
      		Integer Integer.getInteger(String,int) 
      		int Integer.hashCode(int) 
      		int Integer.formatUnsignedInt(int,int,char[],int,int) 
      		boolean Integer.equals(Object) 
      		int Integer.rotateLeft(int,int) 
      		String Integer.toBinaryString(int) 
      		int Integer.min(int,int) 
      		int Integer.highestOneBit(int) 
      		int Integer.compare(int,int) 
      		int Integer.compareTo(Object) 
      		int Integer.reverseBytes(int) 
      		short Integer.shortValue() 
      		int Integer.divideUnsigned(int,int) 
      		Integer Integer.decode(String) 
      		int Integer.parseInt(String) 
      		void Integer.getChars(int,int,char[]) 
      		int Integer.reverse(int) 
      		int Integer.parseUnsignedInt(String) 
      		int Integer.numberOfLeadingZeros(int) 
      		int Integer.numberOfTrailingZeros(int) 
      		String Integer.toUnsignedString(int,int) 
      		float Integer.floatValue() 
      		int Integer.compareUnsigned(int,int) 
      		Integer Integer.valueOf(String) 
      		Integer Integer.getInteger(String,Integer) 
      		String Integer.toString(int,int) 
      		String Integer.toHexString(int) 
      		int Integer.stringSize(int) 
      		int Integer.intValue() 
      		int Integer.rotateRight(int,int) 
      		String Integer.toUnsignedString(int) 
      		String Integer.toUnsignedString0(int,int) 
      		String Integer.toString(int) 
      		int Integer.lowestOneBit(int) 
      		int Integer.compareTo(Integer) 
      		String Integer.toString() 
      		int Integer.parseInt(String,int) 
      		double Integer.doubleValue() 
      		int Integer.sum(int,int) 
      		long Integer.longValue() 
      		long Integer.toUnsignedLong(int) 
      		int Integer.remainderUnsigned(int,int) 
      		Integer Integer.valueOf(String,int) 
      		int Integer.signum(int) 
      		byte Integer.byteValue() 
      		Integer.<init>(String) 
      		int Integer.max(int,int) 
      		Integer Integer.valueOf(int) 
      		int Integer.bitCount(int) 
      		String Integer.toOctalString(int) 
      		int Integer.parseUnsignedInt(String,int) 
      		Integer Integer.getInteger(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.FileDescriptor
TYPE: class java.io.FileDescriptor 
      	fields: {
      		java.util.List* otherParents <> 
      		int fd <> 
      		_Bool closed <> 
      		java.io.Closeable* parent <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void FileDescriptor.<clinit>() 
      		FileDescriptor.<init>(int) 
      		void FileDescriptor.sync() 
      		int FileDescriptor.access$000(FileDescriptor) 
      		void FileDescriptor.closeAll(Closeable) 
      		FileDescriptor.<init>() 
      		void FileDescriptor.attach(Closeable) 
      		void FileDescriptor.initIDs() 
      		int FileDescriptor.access$002(FileDescriptor,int) 
      		boolean FileDescriptor.valid()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.event.ConnectionListener
TYPE: class javax.mail.event.ConnectionListener 
      	fields: {
      	}
      	supers: {
      		class java.util.EventListener
      	}
      	methods: {
      		void ConnectionListener.disconnected(ConnectionEvent) 
      		void ConnectionListener.opened(ConnectionEvent) 
      		void ConnectionListener.closed(ConnectionEvent)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.utils.Validator
TYPE: class com.stn.utils.Validator 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		boolean Validator.isEmpty(String[]) 
      		Validator.<init>() 
      		boolean Validator.isName(String) 
      		boolean Validator.between(String,int,int) 
      		boolean Validator.isEmail(String) 
      		boolean Validator.isURL(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Cloneable
TYPE: class java.lang.Cloneable 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.management.MBeanServerConnection
TYPE: class javax.management.MBeanServerConnection 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		String MBeanServerConnection.getDefaultDomain() 
      		MBeanInfo MBeanServerConnection.getMBeanInfo(ObjectName) 
      		Set MBeanServerConnection.queryMBeans(ObjectName,QueryExp) 
      		void MBeanServerConnection.removeNotificationListener(ObjectName,ObjectName) 
      		ObjectInstance MBeanServerConnection.createMBean(String,ObjectName,Object[],String[]) 
      		boolean MBeanServerConnection.isRegistered(ObjectName) 
      		AttributeList MBeanServerConnection.getAttributes(ObjectName,String[]) 
      		void MBeanServerConnection.addNotificationListener(ObjectName,NotificationListener,NotificationFilter,Object) 
      		ObjectInstance MBeanServerConnection.createMBean(String,ObjectName) 
      		Integer MBeanServerConnection.getMBeanCount() 
      		void MBeanServerConnection.removeNotificationListener(ObjectName,NotificationListener) 
      		void MBeanServerConnection.unregisterMBean(ObjectName) 
      		AttributeList MBeanServerConnection.setAttributes(ObjectName,AttributeList) 
      		String[] MBeanServerConnection.getDomains() 
      		boolean MBeanServerConnection.isInstanceOf(ObjectName,String) 
      		Set MBeanServerConnection.queryNames(ObjectName,QueryExp) 
      		void MBeanServerConnection.removeNotificationListener(ObjectName,ObjectName,NotificationFilter,Object) 
      		ObjectInstance MBeanServerConnection.createMBean(String,ObjectName,ObjectName,Object[],String[]) 
      		void MBeanServerConnection.setAttribute(ObjectName,Attribute) 
      		void MBeanServerConnection.addNotificationListener(ObjectName,ObjectName,NotificationFilter,Object) 
      		ObjectInstance MBeanServerConnection.createMBean(String,ObjectName,ObjectName) 
      		Object MBeanServerConnection.getAttribute(ObjectName,String) 
      		void MBeanServerConnection.removeNotificationListener(ObjectName,NotificationListener,NotificationFilter,Object) 
      		ObjectInstance MBeanServerConnection.getObjectInstance(ObjectName) 
      		Object MBeanServerConnection.invoke(ObjectName,String,Object[],String[])
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.String
TYPE: class java.lang.String 
      	fields: {
      		int count <_final> 
      		int offset <_final> 
      		int hash <> 
      		unsigned short[_*_](*) value <_final>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable 
      		class java.lang.Comparable 
      		class java.lang.CharSequence
      	}
      	methods: {
      		void String.<clinit>() 
      		void String.getChars(int,int,char[],int) 
      		int String.indexOf(char[],int,int,String,int) 
      		int String.hashCode() 
      		String.<init>(byte[],int) 
      		String String.copyValueOf(char[]) 
      		String String.join(CharSequence,CharSequence[]) 
      		boolean String.equals(Object) 
      		String String.substring(int,int) 
      		void String.getBytes(int,int,byte[],int) 
      		boolean String.regionMatches(boolean,int,String,int,int) 
      		boolean String.contains(CharSequence) 
      		int String.indexOf(char[],int,int,char[],int,int,int) 
      		String.<init>(StringBuilder) 
      		String String.replaceAll(String,String) 
      		int String.compareTo(Object) 
      		char String.charAt(int) 
      		String String.format(Locale,String,Object[]) 
      		int String.indexOf(String) 
      		int String.compareToIgnoreCase(String) 
      		String String.valueOf(long) 
      		boolean String.startsWith(String,int) 
      		String String.concat(String) 
      		int String.lastIndexOfSupplementary(int,int) 
      		String.<init>(byte[],Charset) 
      		String.<init>(byte[]) 
      		String String.valueOf(char) 
      		String String.substring(int) 
      		String.<init>(byte[],int,int,String) 
      		String String.toLowerCase() 
      		String.<init>(char[],boolean) 
      		byte[] String.getBytes(Charset) 
      		String String.format(String,Object[]) 
      		String.<init>() 
      		String String.toUpperCase(Locale) 
      		String String.trim() 
      		String String.replace(CharSequence,CharSequence) 
      		int String.lastIndexOf(char[],int,int,char[],int,int,int) 
      		int String.codePointCount(int,int) 
      		boolean String.contentEquals(CharSequence) 
      		String[] String.split(String,int) 
      		String String.valueOf(char[],int,int) 
      		String.<init>(byte[],int,int) 
      		boolean String.startsWith(String) 
      		String String.valueOf(double) 
      		int String.indexOfSupplementary(int,int) 
      		String String.toLowerCase(Locale) 
      		int String.lastIndexOf(char[],int,int,String,int) 
      		int String.lastIndexOf(int,int) 
      		String.<init>(byte[],String) 
      		String String.valueOf(boolean) 
      		String.<init>(char[]) 
      		boolean String.matches(String) 
      		String String.join(CharSequence,Iterable) 
      		void String.getChars(char[],int) 
      		byte[] String.getBytes(String) 
      		boolean String.equalsIgnoreCase(String) 
      		int String.codePointAt(int) 
      		String String.replaceFirst(String,String) 
      		int String.lastIndexOf(String,int) 
      		int String.codePointBefore(int) 
      		int String.lastIndexOf(String) 
      		int String.compareTo(String) 
      		String String.toString() 
      		String String.valueOf(char[]) 
      		boolean String.regionMatches(int,String,int,int) 
      		String String.valueOf(float) 
      		int String.indexOf(int,int) 
      		boolean String.isEmpty() 
      		String String.replace(char,char) 
      		boolean String.endsWith(String) 
      		int String.indexOf(String,int) 
      		int String.length() 
      		String.<init>(StringBuffer) 
      		String String.intern() 
      		int String.indexOf(int) 
      		String.<init>(byte[],int,int,Charset) 
      		String String.toUpperCase() 
      		boolean String.contentEquals(StringBuffer) 
      		String String.valueOf(int) 
      		String.<init>(String) 
      		char[] String.toCharArray() 
      		String.<init>(byte[],int,int,int) 
      		String[] String.split(String) 
      		String.<init>(char[],int,int) 
      		int String.offsetByCodePoints(int,int) 
      		boolean String.nonSyncContentEquals(AbstractStringBuilder) 
      		String.<init>(int[],int,int) 
      		String String.copyValueOf(char[],int,int) 
      		byte[] String.getBytes() 
      		void String.checkBounds(byte[],int,int) 
      		CharSequence String.subSequence(int,int) 
      		int String.lastIndexOf(int) 
      		String String.valueOf(Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.reflect.ConstantPool
TYPE: class sun.reflect.ConstantPool 
      	fields: {
      		java.lang.Object* constantPoolOop <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void ConstantPool.<clinit>() 
      		Field ConstantPool.getFieldAtIfLoaded(int) 
      		Member ConstantPool.getMethodAtIfLoaded0(Object,int) 
      		String ConstantPool.getStringAt0(Object,int) 
      		float ConstantPool.getFloatAt(int) 
      		int ConstantPool.getIntAt0(Object,int) 
      		int ConstantPool.getSize0(Object) 
      		Class ConstantPool.getClassAtIfLoaded(int) 
      		int ConstantPool.getIntAt(int) 
      		Field ConstantPool.getFieldAtIfLoaded0(Object,int) 
      		ConstantPool.<init>() 
      		String ConstantPool.getStringAt(int) 
      		float ConstantPool.getFloatAt0(Object,int) 
      		Class ConstantPool.getClassAtIfLoaded0(Object,int) 
      		Member ConstantPool.getMethodAtIfLoaded(int) 
      		String[] ConstantPool.getMemberRefInfoAt(int) 
      		Field ConstantPool.getFieldAt0(Object,int) 
      		String ConstantPool.getUTF8At0(Object,int) 
      		double ConstantPool.getDoubleAt(int) 
      		int ConstantPool.getSize() 
      		long ConstantPool.getLongAt0(Object,int) 
      		Class ConstantPool.getClassAt0(Object,int) 
      		Member ConstantPool.getMethodAt(int) 
      		long ConstantPool.getLongAt(int) 
      		String[] ConstantPool.getMemberRefInfoAt0(Object,int) 
      		Class ConstantPool.getClassAt(int) 
      		String ConstantPool.getUTF8At(int) 
      		double ConstantPool.getDoubleAt0(Object,int) 
      		Member ConstantPool.getMethodAt0(Object,int) 
      		Field ConstantPool.getFieldAt(int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.DoubleBinaryOperator
TYPE: class java.util.function.DoubleBinaryOperator 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		double DoubleBinaryOperator.applyAsDouble(double,double)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.util.HashMap
TYPE: class java.util.HashMap 
      	fields: {
      		java.lang.Object* lastKey2 <> 
      		java.lang.Object* lastKey1 <> 
      		float loadFactor <_final> 
      		int size <> 
      		java.util.Set* entrySet <> 
      		int threshold <> 
      		java.util.HashMap$Node*[_*_](*) table <> 
      		int modCount <> 
      		java.util.Set* keySet <> 
      		java.util.Collection* values <>
      	}
      	supers: {
      		class java.util.AbstractMap 
      		class java.util.Map 
      		class java.lang.Cloneable 
      		class java.io.Serializable
      	}
      	methods: {
      		HashMap.<init>(int) 
      		Object HashMap.computeIfAbsent(Object,Function) 
      		void HashMap.internalWriteEntries(ObjectOutputStream) 
      		boolean HashMap.containsValue(Object) 
      		Object HashMap.putVal(int,Object,Object,boolean,boolean) 
      		Object HashMap.put(Object,Object) 
      		int HashMap.tableSizeFor(int) 
      		Object HashMap.get(Object) 
      		void HashMap.putAll(Map) 
      		Object HashMap.clone() 
      		int HashMap.size() 
      		float HashMap.loadFactor() 
      		void HashMap.replaceAll(BiFunction) 
      		Set HashMap.keySet() 
      		void HashMap.writeObject(ObjectOutputStream) 
      		Object HashMap.putIfAbsent(Object,Object) 
      		Object HashMap.compute(Object,BiFunction) 
      		Class HashMap.comparableClassFor(Object) 
      		Object HashMap.getOrDefault(Object,Object) 
      		HashMap.<init>() 
      		HashMap$Node[] HashMap.resize() 
      		HashMap$TreeNode HashMap.newTreeNode(int,Object,Object,HashMap$Node) 
      		boolean HashMap.replace(Object,Object,Object) 
      		void HashMap.afterNodeAccess(HashMap$Node) 
      		void HashMap.readObject(ObjectInputStream) 
      		HashMap$TreeNode HashMap.replacementTreeNode(HashMap$Node,HashMap$Node) 
      		Set HashMap.entrySet() 
      		Object HashMap.computeIfPresent(Object,BiFunction) 
      		int HashMap.capacity() 
      		Collection HashMap.values() 
      		HashMap$Node HashMap.getNode(int,Object) 
      		Object HashMap.remove(Object) 
      		HashMap.<init>(int,float) 
      		void HashMap.afterNodeRemoval(HashMap$Node) 
      		void HashMap.putMapEntries(Map,boolean) 
      		HashMap$Node HashMap.replacementNode(HashMap$Node,HashMap$Node) 
      		boolean HashMap.remove(Object,Object) 
      		void HashMap.treeifyBin(HashMap$Node[],int) 
      		boolean HashMap.isEmpty() 
      		HashMap$Node HashMap.removeNode(int,Object,Object,boolean,boolean) 
      		Object HashMap.merge(Object,Object,BiFunction) 
      		int HashMap.compareComparables(Class,Object,Object) 
      		void HashMap.forEach(BiConsumer) 
      		HashMap$Node HashMap.newNode(int,Object,Object,HashMap$Node) 
      		void HashMap.clear() 
      		void HashMap.reinitialize() 
      		HashMap.<init>(Map) 
      		int HashMap.hash(Object) 
      		boolean HashMap.containsKey(Object) 
      		Object HashMap.replace(Object,Object) 
      		void HashMap.afterNodeInsertion(boolean)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.SerieProcess
TYPE: class com.stn.servlets.SerieProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void SerieProcess.doPost(HttpServletRequest,HttpServletResponse) 
      		SerieProcess.<init>() 
      		void SerieProcess.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/SerieProcess")>
      	}NAME: class java.util.function.UnaryOperator
TYPE: class java.util.function.UnaryOperator 
      	fields: {
      	}
      	supers: {
      		class java.util.function.Function
      	}
      	methods: {
      		UnaryOperator UnaryOperator.identity() 
      		Object UnaryOperator.access_java.util.function.UnaryOperator$Lambda$_1_0(Object) 
      		UnaryOperator UnaryOperator.callsite_java.util.function.UnaryOperator$Lambda$_1_0() 
      		Object UnaryOperator.lambda$identity$0(Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class javax.mail.Message$RecipientType
TYPE: class javax.mail.Message$RecipientType 
      	fields: {
      		java.lang.String* type <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable
      	}
      	methods: {
      		void Message$RecipientType.<clinit>() 
      		String Message$RecipientType.toString() 
      		Object Message$RecipientType.readResolve() 
      		Message$RecipientType.<init>(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.pojo.Serie
TYPE: class com.stn.pojo.Serie 
      	fields: {
      		int idSerie <> 
      		int idFacultate <> 
      		java.lang.String* nume <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Serie.setIdFacultate(int) 
      		void Serie.setNume(String) 
      		int Serie.getIdSerie() 
      		void Serie.setIdSerie(int) 
      		String Serie.getNume() 
      		int Serie.getIdFacultate() 
      		Serie.<init>(int,String,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.management.ThreadMXBean
TYPE: class java.lang.management.ThreadMXBean 
      	fields: {
      	}
      	supers: {
      		class java.lang.management.PlatformManagedObject
      	}
      	methods: {
      		long ThreadMXBean.getTotalStartedThreadCount() 
      		boolean ThreadMXBean.isThreadCpuTimeEnabled() 
      		boolean ThreadMXBean.isThreadContentionMonitoringEnabled() 
      		ThreadInfo[] ThreadMXBean.dumpAllThreads(boolean,boolean) 
      		ThreadInfo[] ThreadMXBean.getThreadInfo(long[]) 
      		long[] ThreadMXBean.findDeadlockedThreads() 
      		long ThreadMXBean.getThreadCpuTime(long) 
      		long[] ThreadMXBean.getAllThreadIds() 
      		long[] ThreadMXBean.findMonitorDeadlockedThreads() 
      		long ThreadMXBean.getCurrentThreadCpuTime() 
      		ThreadInfo[] ThreadMXBean.getThreadInfo(long[],int) 
      		boolean ThreadMXBean.isSynchronizerUsageSupported() 
      		boolean ThreadMXBean.isThreadCpuTimeSupported() 
      		int ThreadMXBean.getThreadCount() 
      		int ThreadMXBean.getDaemonThreadCount() 
      		void ThreadMXBean.setThreadCpuTimeEnabled(boolean) 
      		void ThreadMXBean.setThreadContentionMonitoringEnabled(boolean) 
      		ThreadInfo ThreadMXBean.getThreadInfo(long,int) 
      		boolean ThreadMXBean.isObjectMonitorUsageSupported() 
      		long ThreadMXBean.getThreadUserTime(long) 
      		ThreadInfo ThreadMXBean.getThreadInfo(long) 
      		void ThreadMXBean.resetPeakThreadCount() 
      		long ThreadMXBean.getCurrentThreadUserTime() 
      		boolean ThreadMXBean.isThreadContentionMonitoringSupported() 
      		ThreadInfo[] ThreadMXBean.getThreadInfo(long[],boolean,boolean) 
      		boolean ThreadMXBean.isCurrentThreadCpuTimeSupported() 
      		int ThreadMXBean.getPeakThreadCount()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.management.CompilationMXBean
TYPE: class java.lang.management.CompilationMXBean 
      	fields: {
      	}
      	supers: {
      		class java.lang.management.PlatformManagedObject
      	}
      	methods: {
      		long CompilationMXBean.getTotalCompilationTime() 
      		String CompilationMXBean.getName() 
      		boolean CompilationMXBean.isCompilationTimeMonitoringSupported()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.reflect.TypeVariable
TYPE: class java.lang.reflect.TypeVariable 
      	fields: {
      	}
      	supers: {
      		class java.lang.reflect.Type 
      		class java.lang.reflect.AnnotatedElement
      	}
      	methods: {
      		AnnotatedType[] TypeVariable.getAnnotatedBounds() 
      		String TypeVariable.getName() 
      		Type[] TypeVariable.getBounds() 
      		GenericDeclaration TypeVariable.getGenericDeclaration()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.security.Permission
TYPE: class java.security.Permission 
      	fields: {
      		java.lang.String* name <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.security.Guard 
      		class java.io.Serializable
      	}
      	methods: {
      		int Permission.hashCode() 
      		boolean Permission.equals(Object) 
      		String Permission.getActions() 
      		String Permission.getName() 
      		boolean Permission.implies(Permission) 
      		void Permission.checkGuard(Object) 
      		String Permission.toString() 
      		Permission.<init>(String) 
      		PermissionCollection Permission.newPermissionCollection()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.xml.transform.Source
TYPE: class javax.xml.transform.Source 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void Source.setSystemId(String) 
      		String Source.getSystemId()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.Timestamp
TYPE: class java.sql.Timestamp 
      	fields: {
      		int nanos <> 
      		sun.util.calendar.BaseCalendar$Date* cdate <> 
      		long fastTime <>
      	}
      	supers: {
      		class java.util.Date
      	}
      	methods: {
      		int Timestamp.hashCode() 
      		int Timestamp.compareTo(Date) 
      		boolean Timestamp.equals(Object) 
      		boolean Timestamp.equals(Timestamp) 
      		LocalDateTime Timestamp.toLocalDateTime() 
      		int Timestamp.compareTo(Object) 
      		int Timestamp.getNanos() 
      		boolean Timestamp.before(Timestamp) 
      		Timestamp.<init>(int,int,int,int,int,int,int) 
      		void Timestamp.setNanos(int) 
      		void Timestamp.setTime(long) 
      		boolean Timestamp.after(Timestamp) 
      		Instant Timestamp.toInstant() 
      		long Timestamp.getTime() 
      		Timestamp Timestamp.valueOf(String) 
      		int Timestamp.compareTo(Timestamp) 
      		Timestamp Timestamp.from(Instant) 
      		String Timestamp.toString() 
      		Timestamp Timestamp.valueOf(LocalDateTime) 
      		Timestamp.<init>(long)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.concurrent.Executor
TYPE: class java.util.concurrent.Executor 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void Executor.execute(Runnable)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.AbstractMap
TYPE: class java.util.AbstractMap 
      	fields: {
      		java.util.Set* keySet <> 
      		java.util.Collection* values <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.util.Map
      	}
      	methods: {
      		int AbstractMap.hashCode() 
      		boolean AbstractMap.equals(Object) 
      		boolean AbstractMap.containsValue(Object) 
      		Object AbstractMap.put(Object,Object) 
      		Object AbstractMap.get(Object) 
      		void AbstractMap.putAll(Map) 
      		Object AbstractMap.clone() 
      		int AbstractMap.size() 
      		Set AbstractMap.keySet() 
      		AbstractMap.<init>() 
      		Set AbstractMap.entrySet() 
      		boolean AbstractMap.access$000(Object,Object) 
      		Collection AbstractMap.values() 
      		Object AbstractMap.remove(Object) 
      		String AbstractMap.toString() 
      		boolean AbstractMap.isEmpty() 
      		void AbstractMap.clear() 
      		boolean AbstractMap.containsKey(Object) 
      		boolean AbstractMap.eq(Object,Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.reflect.Type
TYPE: class java.lang.reflect.Type 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		String Type.getTypeName()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.IntToLongFunction
TYPE: class java.util.function.IntToLongFunction 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		long IntToLongFunction.applyAsLong(int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class sun.reflect.generics.repository.ConstructorRepository
TYPE: class sun.reflect.generics.repository.ConstructorRepository 
      	fields: {
      		java.lang.reflect.Type*[_*_](*) exceptionTypes <> 
      		java.lang.reflect.Type*[_*_](*) paramTypes <> 
      		java.lang.reflect.TypeVariable*[_*_](*) typeParams <_volatile> 
      		sun.reflect.generics.factory.GenericsFactory* factory <_final> 
      		sun.reflect.generics.tree.Tree* tree <_final>
      	}
      	supers: {
      		class sun.reflect.generics.repository.GenericDeclRepository
      	}
      	methods: {
      		Type[] ConstructorRepository.getParameterTypes() 
      		ConstructorRepository.<init>(String,GenericsFactory) 
      		ConstructorRepository ConstructorRepository.make(String,GenericsFactory) 
      		Tree ConstructorRepository.parse(String) 
      		MethodTypeSignature ConstructorRepository.parse(String) 
      		Type[] ConstructorRepository.getExceptionTypes()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.pojo.Notes
TYPE: class com.stn.pojo.Notes 
      	fields: {
      		java.lang.String* examen <> 
      		int id <> 
      		int id_stud <> 
      		int nota <> 
      		int id_ora <> 
      		java.lang.String* tema <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		int Notes.getId_ora() 
      		int Notes.getId_stud() 
      		void Notes.setExamen(String) 
      		String Notes.getExamen() 
      		Notes.<init>() 
      		int Notes.getId() 
      		void Notes.setId_stud(int) 
      		String Notes.getTema() 
      		void Notes.setId(int) 
      		void Notes.setNota(int) 
      		void Notes.setId_ora(int) 
      		boolean Notes.isEmpty() 
      		int Notes.getNota() 
      		void Notes.setTema(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.security.ProtectionDomain
TYPE: class java.security.ProtectionDomain 
      	fields: {
      		java.security.ProtectionDomain$Key* key <_final> 
      		java.lang.ClassLoader* classloader <> 
      		java.security.PermissionCollection* permissions <> 
      		_Bool staticPermissions <> 
      		java.security.CodeSource* codesource <> 
      		java.security.Principal*[_*_](*) principals <> 
      		_Bool hasAllPerm <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void ProtectionDomain.<clinit>() 
      		boolean ProtectionDomain.seeAllp() 
      		CodeSource ProtectionDomain.getCodeSource() 
      		boolean ProtectionDomain.implies(Permission) 
      		PermissionCollection ProtectionDomain.getPermissions() 
      		boolean ProtectionDomain.impliesCreateAccessControlContext() 
      		ProtectionDomain.<init>(CodeSource,PermissionCollection) 
      		ClassLoader ProtectionDomain.getClassLoader() 
      		PermissionCollection ProtectionDomain.mergePermissions() 
      		String ProtectionDomain.toString() 
      		Principal[] ProtectionDomain.getPrincipals() 
      		ProtectionDomain.<init>(CodeSource,PermissionCollection,ClassLoader,Principal[]) 
      		boolean ProtectionDomain.access$100(ProtectionDomain)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Vector
TYPE: class java.util.Vector 
      	fields: {
      		java.lang.Object*[_*_](*) elementData <> 
      		int elementCount <> 
      		int capacityIncrement <> 
      		int mIsEmpty <> 
      		int modCount <>
      	}
      	supers: {
      		class java.util.AbstractList 
      		class java.util.List 
      		class java.util.RandomAccess 
      		class java.lang.Cloneable 
      		class java.io.Serializable
      	}
      	methods: {
      		void Vector.addElement(Object) 
      		Vector.<init>(int) 
      		int Vector.hashCode() 
      		int Vector.indexOf(Object) 
      		boolean Vector.removeAll(Collection) 
      		boolean Vector.equals(Object) 
      		void Vector.forEach(Consumer) 
      		void Vector.ensureCapacity(int) 
      		void Vector.insertElementAt(Object,int) 
      		void Vector.copyInto(Object[]) 
      		void Vector.add(int,Object) 
      		Object Vector.set(int,Object) 
      		boolean Vector.removeElement(Object) 
      		int Vector.indexOf(Object,int) 
      		List Vector.subList(int,int) 
      		Object Vector.clone() 
      		int Vector.size() 
      		boolean Vector.removeIf(Predicate) 
      		Object Vector.lastElement() 
      		Iterator Vector.iterator() 
      		void Vector.writeObject(ObjectOutputStream) 
      		Vector.<init>(Collection) 
      		Vector.<init>(int,int) 
      		boolean Vector.contains(Object) 
      		Enumeration Vector.elements() 
      		ListIterator Vector.listIterator(int) 
      		Object[] Vector.toArray() 
      		boolean Vector.containsAll(Collection) 
      		Object[] Vector.toArray(Object[]) 
      		Vector.<init>() 
      		boolean Vector.remove(Object) 
      		boolean Vector.addAll(int,Collection) 
      		void Vector.removeAllElements() 
      		void Vector.sort(Comparator) 
      		void Vector.readObject(ObjectInputStream) 
      		Object Vector.elementData(int) 
      		boolean Vector.retainAll(Collection) 
      		Spliterator Vector.spliterator() 
      		int Vector.capacity() 
      		Object Vector.remove(int) 
      		boolean Vector.addAll(Collection) 
      		int Vector.lastIndexOf(Object,int) 
      		String Vector.toString() 
      		void Vector.replaceAll(UnaryOperator) 
      		int Vector.hugeCapacity(int) 
      		boolean Vector.add(Object) 
      		void Vector.setElementAt(Object,int) 
      		boolean Vector.isEmpty() 
      		int Vector.lastIndexOf(Object) 
      		void Vector.ensureCapacityHelper(int) 
      		Object Vector.get(int) 
      		ListIterator Vector.listIterator() 
      		Object Vector.firstElement() 
      		void Vector.setSize(int) 
      		void Vector.clear() 
      		void Vector.removeRange(int,int) 
      		void Vector.trimToSize() 
      		void Vector.removeElementAt(int) 
      		void Vector.grow(int) 
      		Object Vector.elementAt(int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.DatabaseMetaData
TYPE: class java.sql.DatabaseMetaData 
      	fields: {
      	}
      	supers: {
      		class java.sql.Wrapper
      	}
      	methods: {
      		boolean DatabaseMetaData.allProceduresAreCallable() 
      		ResultSet DatabaseMetaData.getImportedKeys(String,String,String) 
      		boolean DatabaseMetaData.supportsSchemasInProcedureCalls() 
      		boolean DatabaseMetaData.supportsAlterTableWithDropColumn() 
      		boolean DatabaseMetaData.supportsStatementPooling() 
      		int DatabaseMetaData.getMaxConnections() 
      		boolean DatabaseMetaData.storesUpperCaseIdentifiers() 
      		boolean DatabaseMetaData.supportsBatchUpdates() 
      		boolean DatabaseMetaData.supportsSubqueriesInQuantifieds() 
      		boolean DatabaseMetaData.supportsMinimumSQLGrammar() 
      		boolean DatabaseMetaData.supportsDataDefinitionAndDataManipulationTransactions() 
      		String DatabaseMetaData.getDatabaseProductVersion() 
      		boolean DatabaseMetaData.ownDeletesAreVisible(int) 
      		boolean DatabaseMetaData.supportsCatalogsInPrivilegeDefinitions() 
      		boolean DatabaseMetaData.supportsOrderByUnrelated() 
      		ResultSet DatabaseMetaData.getPseudoColumns(String,String,String,String) 
      		int DatabaseMetaData.getMaxStatementLength() 
      		String DatabaseMetaData.getSQLKeywords() 
      		ResultSet DatabaseMetaData.getAttributes(String,String,String,String) 
      		int DatabaseMetaData.getMaxBinaryLiteralLength() 
      		boolean DatabaseMetaData.supportsFullOuterJoins() 
      		ResultSet DatabaseMetaData.getCatalogs() 
      		boolean DatabaseMetaData.nullsAreSortedLow() 
      		ResultSet DatabaseMetaData.getIndexInfo(String,String,String,boolean,boolean) 
      		boolean DatabaseMetaData.supportsCatalogsInDataManipulation() 
      		boolean DatabaseMetaData.supportsConvert(int,int) 
      		boolean DatabaseMetaData.autoCommitFailureClosesAllResultSets() 
      		int DatabaseMetaData.getMaxProcedureNameLength() 
      		boolean DatabaseMetaData.storesUpperCaseQuotedIdentifiers() 
      		boolean DatabaseMetaData.supportsMultipleOpenResults() 
      		boolean DatabaseMetaData.supportsOpenCursorsAcrossCommit() 
      		boolean DatabaseMetaData.supportsANSI92IntermediateSQL() 
      		ResultSet DatabaseMetaData.getProcedures(String,String,String) 
      		int DatabaseMetaData.getDriverMinorVersion() 
      		boolean DatabaseMetaData.othersInsertsAreVisible(int) 
      		boolean DatabaseMetaData.supportsStoredProcedures() 
      		boolean DatabaseMetaData.supportsLikeEscapeClause() 
      		int DatabaseMetaData.getMaxUserNameLength() 
      		String DatabaseMetaData.getTimeDateFunctions() 
      		int DatabaseMetaData.getJDBCMajorVersion() 
      		int DatabaseMetaData.getMaxColumnsInIndex() 
      		String DatabaseMetaData.getCatalogTerm() 
      		ResultSet DatabaseMetaData.getTablePrivileges(String,String,String) 
      		String DatabaseMetaData.getURL() 
      		ResultSet DatabaseMetaData.getCrossReference(String,String,String,String,String,String) 
      		boolean DatabaseMetaData.supportsSchemasInIndexDefinitions() 
      		boolean DatabaseMetaData.nullPlusNonNullIsNull() 
      		ResultSet DatabaseMetaData.getSchemas(String,String) 
      		int DatabaseMetaData.getMaxIndexLength() 
      		boolean DatabaseMetaData.storesMixedCaseIdentifiers() 
      		boolean DatabaseMetaData.supportsSavepoints() 
      		boolean DatabaseMetaData.supportsUnion() 
      		boolean DatabaseMetaData.supportsExtendedSQLGrammar() 
      		boolean DatabaseMetaData.dataDefinitionCausesTransactionCommit() 
      		String DatabaseMetaData.getDriverVersion() 
      		boolean DatabaseMetaData.othersUpdatesAreVisible(int) 
      		boolean DatabaseMetaData.supportsPositionedUpdate() 
      		boolean DatabaseMetaData.supportsGroupByUnrelated() 
      		long DatabaseMetaData.getMaxLogicalLobSize() 
      		int DatabaseMetaData.getMaxTableNameLength() 
      		String DatabaseMetaData.getStringFunctions() 
      		int DatabaseMetaData.getDatabaseMajorVersion() 
      		int DatabaseMetaData.getMaxColumnNameLength() 
      		String DatabaseMetaData.getSchemaTerm() 
      		ResultSet DatabaseMetaData.getColumns(String,String,String,String) 
      		boolean DatabaseMetaData.nullsAreSortedAtEnd() 
      		boolean DatabaseMetaData.supportsResultSetConcurrency(int,int) 
      		boolean DatabaseMetaData.supportsCatalogsInTableDefinitions() 
      		boolean DatabaseMetaData.supportsDifferentTableCorrelationNames() 
      		ResultSet DatabaseMetaData.getFunctions(String,String,String) 
      		int DatabaseMetaData.getMaxRowSize() 
      		boolean DatabaseMetaData.storesMixedCaseQuotedIdentifiers() 
      		ResultSet DatabaseMetaData.getSuperTypes(String,String,String) 
      		boolean DatabaseMetaData.supportsOpenStatementsAcrossCommit() 
      		int DatabaseMetaData.getResultSetHoldability() 
      		boolean DatabaseMetaData.supportsIntegrityEnhancementFacility() 
      		ResultSet DatabaseMetaData.getTables(String,String,String,String[]) 
      		boolean DatabaseMetaData.usesLocalFilePerTable() 
      		boolean DatabaseMetaData.deletesAreDetected(int) 
      		boolean DatabaseMetaData.supportsSubqueriesInExists() 
      		Connection DatabaseMetaData.getConnection() 
      		boolean DatabaseMetaData.supportsMultipleTransactions() 
      		boolean DatabaseMetaData.supportsTransactions() 
      		String DatabaseMetaData.getExtraNameCharacters() 
      		int DatabaseMetaData.getSQLStateType() 
      		int DatabaseMetaData.getMaxColumnsInSelect() 
      		String DatabaseMetaData.getCatalogSeparator() 
      		String DatabaseMetaData.getUserName() 
      		ResultSet DatabaseMetaData.getVersionColumns(String,String,String) 
      		boolean DatabaseMetaData.allTablesAreSelectable() 
      		ResultSet DatabaseMetaData.getExportedKeys(String,String,String) 
      		boolean DatabaseMetaData.supportsSchemasInTableDefinitions() 
      		boolean DatabaseMetaData.supportsColumnAliasing() 
      		RowIdLifetime DatabaseMetaData.getRowIdLifetime() 
      		int DatabaseMetaData.getMaxCursorNameLength() 
      		boolean DatabaseMetaData.storesLowerCaseIdentifiers() 
      		ResultSet DatabaseMetaData.getUDTs(String,String,String,int[]) 
      		boolean DatabaseMetaData.supportsCorrelatedSubqueries() 
      		boolean DatabaseMetaData.supportsCoreSQLGrammar() 
      		boolean DatabaseMetaData.supportsDataManipulationTransactionsOnly() 
      		String DatabaseMetaData.getDriverName() 
      		boolean DatabaseMetaData.ownInsertsAreVisible(int) 
      		boolean DatabaseMetaData.supportsPositionedDelete() 
      		boolean DatabaseMetaData.supportsGroupBy() 
      		boolean DatabaseMetaData.generatedKeyAlwaysReturned() 
      		int DatabaseMetaData.getMaxStatements() 
      		String DatabaseMetaData.getNumericFunctions() 
      		boolean DatabaseMetaData.supportsResultSetHoldability(int) 
      		int DatabaseMetaData.getMaxCharLiteralLength() 
      		boolean DatabaseMetaData.supportsLimitedOuterJoins() 
      		ResultSet DatabaseMetaData.getTableTypes() 
      		boolean DatabaseMetaData.nullsAreSortedAtStart() 
      		boolean DatabaseMetaData.supportsResultSetType(int) 
      		boolean DatabaseMetaData.supportsCatalogsInProcedureCalls() 
      		boolean DatabaseMetaData.supportsTableCorrelationNames() 
      		ResultSet DatabaseMetaData.getClientInfoProperties() 
      		int DatabaseMetaData.getMaxCatalogNameLength() 
      		boolean DatabaseMetaData.storesLowerCaseQuotedIdentifiers() 
      		boolean DatabaseMetaData.supportsGetGeneratedKeys() 
      		boolean DatabaseMetaData.supportsOpenCursorsAcrossRollback() 
      		boolean DatabaseMetaData.supportsANSI92FullSQL() 
      		ResultSet DatabaseMetaData.getProcedureColumns(String,String,String,String) 
      		boolean DatabaseMetaData.usesLocalFiles() 
      		boolean DatabaseMetaData.updatesAreDetected(int) 
      		boolean DatabaseMetaData.supportsSubqueriesInComparisons() 
      		boolean DatabaseMetaData.supportsMultipleResultSets() 
      		int DatabaseMetaData.getDefaultTransactionIsolation() 
      		String DatabaseMetaData.getSearchStringEscape() 
      		int DatabaseMetaData.getJDBCMinorVersion() 
      		int DatabaseMetaData.getMaxColumnsInOrderBy() 
      		boolean DatabaseMetaData.isCatalogAtStart() 
      		ResultSet DatabaseMetaData.getBestRowIdentifier(String,String,String,int,boolean) 
      		boolean DatabaseMetaData.nullsAreSortedHigh() 
      		ResultSet DatabaseMetaData.getTypeInfo() 
      		boolean DatabaseMetaData.supportsSchemasInPrivilegeDefinitions() 
      		boolean DatabaseMetaData.supportsConvert() 
      		boolean DatabaseMetaData.supportsStoredFunctionsUsingCallSyntax() 
      		int DatabaseMetaData.getMaxSchemaNameLength() 
      		boolean DatabaseMetaData.supportsMixedCaseQuotedIdentifiers() 
      		boolean DatabaseMetaData.supportsNamedParameters() 
      		boolean DatabaseMetaData.supportsUnionAll() 
      		boolean DatabaseMetaData.supportsANSI92EntryLevelSQL() 
      		boolean DatabaseMetaData.dataDefinitionIgnoredInTransactions() 
      		int DatabaseMetaData.getDriverMajorVersion() 
      		boolean DatabaseMetaData.othersDeletesAreVisible(int) 
      		boolean DatabaseMetaData.supportsSelectForUpdate() 
      		boolean DatabaseMetaData.supportsGroupByBeyondSelect() 
      		boolean DatabaseMetaData.supportsRefCursors() 
      		int DatabaseMetaData.getMaxTablesInSelect() 
      		String DatabaseMetaData.getSystemFunctions() 
      		int DatabaseMetaData.getDatabaseMinorVersion() 
      		int DatabaseMetaData.getMaxColumnsInGroupBy() 
      		boolean DatabaseMetaData.isReadOnly() 
      		String DatabaseMetaData.getProcedureTerm() 
      		ResultSet DatabaseMetaData.getColumnPrivileges(String,String,String,String) 
      		String DatabaseMetaData.getDatabaseProductName() 
      		boolean DatabaseMetaData.ownUpdatesAreVisible(int) 
      		boolean DatabaseMetaData.supportsCatalogsInIndexDefinitions() 
      		boolean DatabaseMetaData.supportsExpressionsInOrderBy() 
      		ResultSet DatabaseMetaData.getFunctionColumns(String,String,String,String) 
      		boolean DatabaseMetaData.doesMaxRowSizeIncludeBlobs() 
      		String DatabaseMetaData.getIdentifierQuoteString() 
      		ResultSet DatabaseMetaData.getSuperTables(String,String,String) 
      		boolean DatabaseMetaData.supportsOpenStatementsAcrossRollback() 
      		boolean DatabaseMetaData.supportsOuterJoins() 
      		ResultSet DatabaseMetaData.getSchemas() 
      		boolean DatabaseMetaData.supportsMixedCaseIdentifiers() 
      		boolean DatabaseMetaData.insertsAreDetected(int) 
      		boolean DatabaseMetaData.supportsSubqueriesInIns() 
      		boolean DatabaseMetaData.supportsNonNullableColumns() 
      		boolean DatabaseMetaData.supportsTransactionIsolationLevel(int) 
      		boolean DatabaseMetaData.supportsAlterTableWithAddColumn() 
      		boolean DatabaseMetaData.locatorsUpdateCopy() 
      		int DatabaseMetaData.getMaxColumnsInTable() 
      		boolean DatabaseMetaData.supportsSchemasInDataManipulation() 
      		ResultSet DatabaseMetaData.getPrimaryKeys(String,String,String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.util.calendar.Era
TYPE: class sun.util.calendar.Era 
      	fields: {
      		java.lang.String* abbr <_final> 
      		java.lang.String* name <_final> 
      		_Bool localTime <_final> 
      		long since <_final> 
      		sun.util.calendar.CalendarDate* sinceDate <_final> 
      		int hash <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		int Era.hashCode() 
      		boolean Era.isLocalTime() 
      		boolean Era.equals(Object) 
      		CalendarDate Era.getSinceDate() 
      		String Era.getDisplayName(Locale) 
      		String Era.getDiaplayAbbreviation(Locale) 
      		String Era.getName() 
      		Era.<init>(String,String,long,boolean) 
      		String Era.toString() 
      		String Era.getAbbreviation() 
      		long Era.getSince(TimeZone)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.event.StoreListener
TYPE: class javax.mail.event.StoreListener 
      	fields: {
      	}
      	supers: {
      		class java.util.EventListener
      	}
      	methods: {
      		void StoreListener.notification(StoreEvent)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.text.ParsePosition
TYPE: class java.text.ParsePosition 
      	fields: {
      		int index <> 
      		int errorIndex <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		ParsePosition.<init>(int) 
      		int ParsePosition.hashCode() 
      		boolean ParsePosition.equals(Object) 
      		int ParsePosition.getIndex() 
      		void ParsePosition.setErrorIndex(int) 
      		void ParsePosition.setIndex(int) 
      		String ParsePosition.toString() 
      		int ParsePosition.getErrorIndex()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Hashtable
TYPE: class java.util.Hashtable 
      	fields: {
      		float loadFactor <> 
      		java.util.Set* entrySet <_volatile> 
      		int count <> 
      		int threshold <> 
      		java.util.Set* keySet <_volatile> 
      		int modCount <> 
      		java.util.Collection* values <_volatile> 
      		java.util.Hashtable$Entry*[_*_](*) table <>
      	}
      	supers: {
      		class java.util.Dictionary 
      		class java.util.Map 
      		class java.lang.Cloneable 
      		class java.io.Serializable
      	}
      	methods: {
      		Hashtable.<init>(int) 
      		int Hashtable.hashCode() 
      		Object Hashtable.computeIfAbsent(Object,Function) 
      		boolean Hashtable.equals(Object) 
      		boolean Hashtable.containsValue(Object) 
      		Object Hashtable.put(Object,Object) 
      		Iterator Hashtable.getIterator(int) 
      		int Hashtable.access$210(Hashtable) 
      		Object Hashtable.get(Object) 
      		Iterator Hashtable.access$100(Hashtable,int) 
      		void Hashtable.putAll(Map) 
      		Object Hashtable.clone() 
      		int Hashtable.size() 
      		void Hashtable.replaceAll(BiFunction) 
      		Set Hashtable.keySet() 
      		void Hashtable.writeObject(ObjectOutputStream) 
      		Object Hashtable.putIfAbsent(Object,Object) 
      		Object Hashtable.compute(Object,BiFunction) 
      		boolean Hashtable.contains(Object) 
      		Enumeration Hashtable.elements() 
      		Object Hashtable.getOrDefault(Object,Object) 
      		Enumeration Hashtable.getEnumeration(int) 
      		Hashtable.<init>() 
      		void Hashtable.reconstitutionPut(Hashtable$Entry[],Object,Object) 
      		Hashtable$Entry[] Hashtable.access$400(Hashtable) 
      		boolean Hashtable.replace(Object,Object,Object) 
      		void Hashtable.readObject(ObjectInputStream) 
      		Set Hashtable.entrySet() 
      		Object Hashtable.computeIfPresent(Object,BiFunction) 
      		Collection Hashtable.values() 
      		Object Hashtable.remove(Object) 
      		Hashtable.<init>(int,float) 
      		int Hashtable.access$500(Hashtable) 
      		int Hashtable.access$200(Hashtable) 
      		String Hashtable.toString() 
      		Enumeration Hashtable.keys() 
      		boolean Hashtable.remove(Object,Object) 
      		void Hashtable.addEntry(int,Object,Object,int) 
      		boolean Hashtable.isEmpty() 
      		Object Hashtable.merge(Object,Object,BiFunction) 
      		void Hashtable.forEach(BiConsumer) 
      		void Hashtable.rehash() 
      		void Hashtable.clear() 
      		Hashtable.<init>(Map) 
      		boolean Hashtable.containsKey(Object) 
      		int Hashtable.access$508(Hashtable) 
      		Object Hashtable.replace(Object,Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.IntConsumer
TYPE: class java.util.function.IntConsumer 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void IntConsumer.accept(int) 
      		IntConsumer IntConsumer.callsite_java.util.function.IntConsumer$Lambda$_1_7(IntConsumer,IntConsumer) 
      		void IntConsumer.lambda$andThen$0(IntConsumer,int) 
      		void IntConsumer.access_java.util.function.IntConsumer$Lambda$_1_7(IntConsumer,IntConsumer,int) 
      		IntConsumer IntConsumer.andThen(IntConsumer)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class javax.mail.event.FolderListener
TYPE: class javax.mail.event.FolderListener 
      	fields: {
      	}
      	supers: {
      		class java.util.EventListener
      	}
      	methods: {
      		void FolderListener.folderDeleted(FolderEvent) 
      		void FolderListener.folderCreated(FolderEvent) 
      		void FolderListener.folderRenamed(FolderEvent)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.NClob
TYPE: class java.sql.NClob 
      	fields: {
      	}
      	supers: {
      		class java.sql.Clob
      	}
      	methods: {
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.internet.MimePart
TYPE: class javax.mail.internet.MimePart 
      	fields: {
      	}
      	supers: {
      		class javax.mail.Part
      	}
      	methods: {
      		void MimePart.setText(String,String,String) 
      		String MimePart.getContentID() 
      		String[] MimePart.getContentLanguage() 
      		Enumeration MimePart.getNonMatchingHeaderLines(String[]) 
      		String MimePart.getContentMD5() 
      		String MimePart.getHeader(String,String) 
      		Enumeration MimePart.getAllHeaderLines() 
      		void MimePart.setText(String) 
      		void MimePart.addHeaderLine(String) 
      		void MimePart.setContentLanguage(String[]) 
      		void MimePart.setContentMD5(String) 
      		Enumeration MimePart.getMatchingHeaderLines(String[]) 
      		void MimePart.setText(String,String) 
      		String MimePart.getEncoding()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.FilterRegistration$Dynamic
TYPE: class javax.servlet.FilterRegistration$Dynamic 
      	fields: {
      	}
      	supers: {
      		class javax.servlet.FilterRegistration 
      		class javax.servlet.Registration$Dynamic
      	}
      	methods: {
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Spliterator
TYPE: class java.util.Spliterator 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void Spliterator.forEachRemaining(Consumer) 
      		Spliterator Spliterator.trySplit() 
      		int Spliterator.characteristics() 
      		boolean Spliterator.hasCharacteristics(int) 
      		boolean Spliterator.tryAdvance(Consumer) 
      		long Spliterator.getExactSizeIfKnown() 
      		long Spliterator.estimateSize() 
      		Comparator Spliterator.getComparator()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.time.Instant
TYPE: class java.time.Instant 
      	fields: {
      		int nanos <_final> 
      		long seconds <_final>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.time.temporal.Temporal 
      		class java.time.temporal.TemporalAdjuster 
      		class java.lang.Comparable 
      		class java.io.Serializable
      	}
      	methods: {
      		void Instant.<clinit>() 
      		int Instant.hashCode() 
      		boolean Instant.isAfter(Instant) 
      		Instant Instant.create(long,int) 
      		Instant Instant.ofEpochMilli(long) 
      		Instant Instant.now() 
      		boolean Instant.equals(Object) 
      		void Instant.writeExternal(DataOutput) 
      		int Instant.get(TemporalField) 
      		Instant Instant.plus(long,long) 
      		Instant Instant.minus(TemporalAmount) 
      		Instant Instant.access_java.time.Instant$Lambda$_33_4(TemporalAccessor) 
      		Temporal Instant.plus(TemporalAmount) 
      		int Instant.compareTo(Object) 
      		Instant Instant.truncatedTo(TemporalUnit) 
      		Instant Instant.from(TemporalAccessor) 
      		int Instant.compareTo(Instant) 
      		Object Instant.query(TemporalQuery) 
      		Instant Instant.readExternal(DataInput) 
      		Temporal Instant.minus(TemporalAmount) 
      		Instant Instant.ofEpochSecond(long) 
      		Instant Instant.plusSeconds(long) 
      		Instant Instant.with(TemporalField,long) 
      		ValueRange Instant.range(TemporalField) 
      		Temporal Instant.with(TemporalAdjuster) 
      		long Instant.getEpochSecond() 
      		Instant Instant.minusMillis(long) 
      		OffsetDateTime Instant.atOffset(ZoneOffset) 
      		long Instant.secondsUntil(Instant) 
      		void Instant.readObject(ObjectInputStream) 
      		boolean Instant.isBefore(Instant) 
      		Temporal Instant.minus(long,TemporalUnit) 
      		Instant.<init>(long,int) 
      		ZonedDateTime Instant.atZone(ZoneId) 
      		Instant Instant.now(Clock) 
      		long Instant.getLong(TemporalField) 
      		Instant Instant.plusMillis(long) 
      		Instant Instant.plus(TemporalAmount) 
      		boolean Instant.isSupported(TemporalUnit) 
      		long Instant.until(Temporal,TemporalUnit) 
      		Temporal Instant.with(TemporalField,long) 
      		String Instant.toString() 
      		Instant Instant.minusSeconds(long) 
      		long Instant.nanosUntil(Instant) 
      		Instant Instant.minus(long,TemporalUnit) 
      		TemporalQuery Instant.callsite_java.time.Instant$Lambda$_33_4() 
      		Temporal Instant.plus(long,TemporalUnit) 
      		int Instant.getNano() 
      		Instant Instant.parse(CharSequence) 
      		Instant Instant.plus(long,TemporalUnit) 
      		boolean Instant.isSupported(TemporalField) 
      		long Instant.toEpochMilli() 
      		Instant Instant.with(TemporalAdjuster) 
      		Instant Instant.plusNanos(long) 
      		Instant Instant.ofEpochSecond(long,long) 
      		Instant Instant.minusNanos(long) 
      		Object Instant.writeReplace() 
      		Temporal Instant.adjustInto(Temporal)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.security.SecureRandom
TYPE: class java.security.SecureRandom 
      	fields: {
      		signed char[_*_](*) randomBytes <> 
      		java.security.MessageDigest* digest <> 
      		java.security.Provider* provider <> 
      		long counter <> 
      		int randomBytesUsed <> 
      		java.lang.String* algorithm <> 
      		java.security.SecureRandomSpi* secureRandomSpi <> 
      		signed char[_*_](*) state <> 
      		_Bool haveNextNextGaussian <> 
      		double nextNextGaussian <> 
      		java.util.concurrent.atomic.AtomicLong* seed <_final>
      	}
      	supers: {
      		class java.util.Random
      	}
      	methods: {
      		void SecureRandom.<clinit>() 
      		int SecureRandom.next(int) 
      		byte[] SecureRandom.longToByteArray(long) 
      		Provider SecureRandom.getProvider() 
      		String SecureRandom.getPrngAlgorithm() 
      		SecureRandom.<init>(SecureRandomSpi,Provider,String) 
      		SecureRandom.<init>(SecureRandomSpi,Provider) 
      		SecureRandom SecureRandom.getInstanceStrong() 
      		SecureRandom.<init>(byte[]) 
      		byte[] SecureRandom.generateSeed(int) 
      		SecureRandom.<init>() 
      		SecureRandom SecureRandom.getInstance(String) 
      		String SecureRandom.getAlgorithm() 
      		void SecureRandom.setSeed(byte[]) 
      		byte[] SecureRandom.getSeed(int) 
      		SecureRandom SecureRandom.getInstance(String,Provider) 
      		SecureRandomSpi SecureRandom.getSecureRandomSpi() 
      		SecureRandom SecureRandom.getInstance(String,String) 
      		void SecureRandom.getDefaultPRNG(boolean,byte[]) 
      		void SecureRandom.nextBytes(byte[]) 
      		void SecureRandom.setSeed(long)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.nio.CharBuffer
TYPE: class java.nio.CharBuffer 
      	fields: {
      		_Bool isReadOnly <> 
      		int offset <_final> 
      		unsigned short[_*_](*) hb <_final> 
      		int mark <> 
      		int capacity <> 
      		long address <> 
      		int position <> 
      		int limit <>
      	}
      	supers: {
      		class java.nio.Buffer 
      		class java.lang.Comparable 
      		class java.lang.Appendable 
      		class java.lang.CharSequence 
      		class java.lang.Readable
      	}
      	methods: {
      		int CharBuffer.arrayOffset() 
      		CharBuffer CharBuffer.subSequence(int,int) 
      		int CharBuffer.hashCode() 
      		ByteOrder CharBuffer.order() 
      		CharBuffer CharBuffer.put(CharBuffer) 
      		boolean CharBuffer.equals(Object) 
      		CharBuffer CharBuffer.get(char[]) 
      		boolean CharBuffer.equals(char,char) 
      		CharBuffer CharBuffer.put(char[],int,int) 
      		boolean CharBuffer.isDirect() 
      		CharBuffer CharBuffer.duplicate() 
      		CharBuffer CharBuffer.get(char[],int,int) 
      		int CharBuffer.compareTo(Object) 
      		char CharBuffer.charAt(int) 
      		Spliterator$OfInt CharBuffer.access_java.nio.CharBuffer$Lambda$_14_1(CharBuffer) 
      		int CharBuffer.compareTo(CharBuffer) 
      		IntStream CharBuffer.chars() 
      		CharBuffer CharBuffer.wrap(char[]) 
      		CharBuffer CharBuffer.wrap(CharSequence,int,int) 
      		CharBuffer CharBuffer.compact() 
      		Spliterator$OfInt CharBuffer.lambda$chars$0() 
      		char CharBuffer.getUnchecked(int) 
      		CharBuffer CharBuffer.put(String,int,int) 
      		CharBuffer.<init>(int,int,int,int,char[],int) 
      		CharBuffer CharBuffer.append(CharSequence,int,int) 
      		Appendable CharBuffer.append(CharSequence,int,int) 
      		boolean CharBuffer.hasArray() 
      		CharBuffer CharBuffer.allocate(int) 
      		String CharBuffer.toString(int,int) 
      		CharBuffer CharBuffer.put(char[]) 
      		CharBuffer CharBuffer.put(String) 
      		int CharBuffer.read(CharBuffer) 
      		CharBuffer CharBuffer.wrap(CharSequence) 
      		CharBuffer CharBuffer.asReadOnlyBuffer() 
      		CharBuffer CharBuffer.put(char) 
      		String CharBuffer.toString() 
      		Object CharBuffer.array() 
      		CharBuffer CharBuffer.append(char) 
      		Appendable CharBuffer.append(char) 
      		CharBuffer CharBuffer.slice() 
      		int CharBuffer.length() 
      		char CharBuffer.get() 
      		int CharBuffer.compare(char,char) 
      		Supplier CharBuffer.callsite_java.nio.CharBuffer$Lambda$_14_1(CharBuffer) 
      		char[] CharBuffer.array() 
      		CharBuffer.<init>(int,int,int,int) 
      		CharBuffer CharBuffer.put(int,char) 
      		char CharBuffer.get(int) 
      		CharBuffer CharBuffer.wrap(char[],int,int) 
      		CharSequence CharBuffer.subSequence(int,int) 
      		CharBuffer CharBuffer.append(CharSequence) 
      		Appendable CharBuffer.append(CharSequence)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Spliterator$OfPrimitive
TYPE: class java.util.Spliterator$OfPrimitive 
      	fields: {
      	}
      	supers: {
      		class java.util.Spliterator
      	}
      	methods: {
      		Spliterator Spliterator$OfPrimitive.trySplit() 
      		boolean Spliterator$OfPrimitive.tryAdvance(Object) 
      		void Spliterator$OfPrimitive.forEachRemaining(Object) 
      		Spliterator$OfPrimitive Spliterator$OfPrimitive.trySplit()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.IntSummaryStatistics
TYPE: class java.util.IntSummaryStatistics 
      	fields: {
      		int max <> 
      		long sum <> 
      		long count <> 
      		int min <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.util.function.IntConsumer
      	}
      	methods: {
      		void IntSummaryStatistics.combine(IntSummaryStatistics) 
      		void IntSummaryStatistics.accept(int) 
      		long IntSummaryStatistics.getSum() 
      		IntSummaryStatistics.<init>() 
      		double IntSummaryStatistics.getAverage() 
      		int IntSummaryStatistics.getMin() 
      		String IntSummaryStatistics.toString() 
      		long IntSummaryStatistics.getCount() 
      		int IntSummaryStatistics.getMax()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.security.GeneralSecurityException
TYPE: class java.security.GeneralSecurityException 
      	fields: {
      		java.lang.String* detailMessage <> 
      		java.lang.Object* backtrace <> 
      		java.lang.StackTraceElement*[_*_](*) stackTrace <> 
      		java.lang.Throwable* cause <> 
      		java.util.List* suppressedExceptions <>
      	}
      	supers: {
      		class java.lang.Exception
      	}
      	methods: {
      		GeneralSecurityException.<init>(String,Throwable) 
      		GeneralSecurityException.<init>() 
      		GeneralSecurityException.<init>(Throwable) 
      		GeneralSecurityException.<init>(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.annotation.Annotation
TYPE: class java.lang.annotation.Annotation 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		int Annotation.hashCode() 
      		Class Annotation.annotationType() 
      		boolean Annotation.equals(Object) 
      		String Annotation.toString()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.CharSequence
TYPE: class java.lang.CharSequence 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Spliterator$OfInt CharSequence.access_java.lang.CharSequence$Lambda$_1_1(CharSequence) 
      		char CharSequence.charAt(int) 
      		IntStream CharSequence.chars() 
      		Spliterator$OfInt CharSequence.access_java.lang.CharSequence$Lambda$_2_1(CharSequence) 
      		Spliterator$OfInt CharSequence.lambda$chars$0() 
      		Supplier CharSequence.callsite_java.lang.CharSequence$Lambda$_2_1(CharSequence) 
      		String CharSequence.toString() 
      		IntStream CharSequence.codePoints() 
      		int CharSequence.length() 
      		Spliterator$OfInt CharSequence.lambda$codePoints$1() 
      		CharSequence CharSequence.subSequence(int,int) 
      		Supplier CharSequence.callsite_java.lang.CharSequence$Lambda$_1_1(CharSequence)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.Registration
TYPE: class javax.servlet.Registration 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Map Registration.getInitParameters() 
      		boolean Registration.setInitParameter(String,String) 
      		String Registration.getName() 
      		String Registration.getInitParameter(String) 
      		Set Registration.setInitParameters(Map) 
      		String Registration.getClassName()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.ReflectiveOperationException
TYPE: class java.lang.ReflectiveOperationException 
      	fields: {
      		java.lang.String* detailMessage <> 
      		java.lang.Object* backtrace <> 
      		java.lang.StackTraceElement*[_*_](*) stackTrace <> 
      		java.lang.Throwable* cause <> 
      		java.util.List* suppressedExceptions <>
      	}
      	supers: {
      		class java.lang.Exception
      	}
      	methods: {
      		ReflectiveOperationException.<init>(String,Throwable) 
      		ReflectiveOperationException.<init>() 
      		ReflectiveOperationException.<init>(Throwable) 
      		ReflectiveOperationException.<init>(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.ClassNotFoundException
TYPE: class java.lang.ClassNotFoundException 
      	fields: {
      		java.lang.Throwable* ex <> 
      		java.lang.String* detailMessage <> 
      		java.lang.Object* backtrace <> 
      		java.lang.StackTraceElement*[_*_](*) stackTrace <> 
      		java.lang.Throwable* cause <> 
      		java.util.List* suppressedExceptions <>
      	}
      	supers: {
      		class java.lang.ReflectiveOperationException
      	}
      	methods: {
      		ClassNotFoundException.<init>(String,Throwable) 
      		Throwable ClassNotFoundException.getException() 
      		ClassNotFoundException.<init>() 
      		Throwable ClassNotFoundException.getCause() 
      		ClassNotFoundException.<init>(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.Clob
TYPE: class java.sql.Clob 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Writer Clob.setCharacterStream(long) 
      		long Clob.position(Clob,long) 
      		InputStream Clob.getAsciiStream() 
      		void Clob.truncate(long) 
      		int Clob.setString(long,String,int,int) 
      		Reader Clob.getCharacterStream(long,long) 
      		String Clob.getSubString(long,int) 
      		int Clob.setString(long,String) 
      		long Clob.position(String,long) 
      		void Clob.free() 
      		OutputStream Clob.setAsciiStream(long) 
      		long Clob.length() 
      		Reader Clob.getCharacterStream()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.text.DateFormat
TYPE: class java.text.DateFormat 
      	fields: {
      		java.util.Calendar* calendar <> 
      		java.text.NumberFormat* numberFormat <>
      	}
      	supers: {
      		class java.text.Format
      	}
      	methods: {
      		int DateFormat.hashCode() 
      		Date DateFormat.parse(String) 
      		boolean DateFormat.equals(Object) 
      		Calendar DateFormat.getCalendar() 
      		void DateFormat.setTimeZone(TimeZone) 
      		Locale[] DateFormat.getAvailableLocales() 
      		DateFormat DateFormat.getDateInstance() 
      		boolean DateFormat.isLenient() 
      		Object DateFormat.clone() 
      		DateFormat DateFormat.getDateInstance(int,Locale) 
      		DateFormat DateFormat.getDateTimeInstance(int,int) 
      		DateFormat DateFormat.getTimeInstance() 
      		NumberFormat DateFormat.getNumberFormat() 
      		DateFormat.<init>() 
      		DateFormat DateFormat.getInstance() 
      		DateFormat DateFormat.getDateTimeInstance(int,int,Locale) 
      		DateFormat DateFormat.get(int,int,int,Locale) 
      		Object DateFormat.parseObject(String,ParsePosition) 
      		TimeZone DateFormat.getTimeZone() 
      		DateFormat DateFormat.get(LocaleProviderAdapter,int,int,Locale) 
      		Date DateFormat.parse(String,ParsePosition) 
      		void DateFormat.setNumberFormat(NumberFormat) 
      		String DateFormat.format(Date) 
      		void DateFormat.setLenient(boolean) 
      		DateFormat DateFormat.getDateInstance(int) 
      		DateFormat DateFormat.getDateTimeInstance() 
      		DateFormat DateFormat.getTimeInstance(int,Locale) 
      		DateFormat DateFormat.getTimeInstance(int) 
      		StringBuffer DateFormat.format(Date,StringBuffer,FieldPosition) 
      		void DateFormat.setCalendar(Calendar) 
      		StringBuffer DateFormat.format(Object,StringBuffer,FieldPosition)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.ObjectOutput
TYPE: class java.io.ObjectOutput 
      	fields: {
      	}
      	supers: {
      		class java.io.DataOutput 
      		class java.lang.AutoCloseable
      	}
      	methods: {
      		void ObjectOutput.write(byte[]) 
      		void ObjectOutput.write(int) 
      		void ObjectOutput.close() 
      		void ObjectOutput.flush() 
      		void ObjectOutput.write(byte[],int,int) 
      		void ObjectOutput.writeObject(Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.IntUnaryOperator
TYPE: class java.util.function.IntUnaryOperator 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		IntUnaryOperator IntUnaryOperator.callsite_java.util.function.IntUnaryOperator$Lambda$_3_0() 
      		IntUnaryOperator IntUnaryOperator.compose(IntUnaryOperator) 
      		int IntUnaryOperator.applyAsInt(int) 
      		IntUnaryOperator IntUnaryOperator.identity() 
      		int IntUnaryOperator.lambda$andThen$1(IntUnaryOperator,int) 
      		IntUnaryOperator IntUnaryOperator.callsite_java.util.function.IntUnaryOperator$Lambda$_2_7(IntUnaryOperator,IntUnaryOperator) 
      		int IntUnaryOperator.access_java.util.function.IntUnaryOperator$Lambda$_3_0(int) 
      		IntUnaryOperator IntUnaryOperator.andThen(IntUnaryOperator) 
      		int IntUnaryOperator.lambda$compose$0(IntUnaryOperator,int) 
      		int IntUnaryOperator.access_java.util.function.IntUnaryOperator$Lambda$_1_7(IntUnaryOperator,IntUnaryOperator,int) 
      		IntUnaryOperator IntUnaryOperator.callsite_java.util.function.IntUnaryOperator$Lambda$_1_7(IntUnaryOperator,IntUnaryOperator) 
      		int IntUnaryOperator.lambda$identity$2(int) 
      		int IntUnaryOperator.access_java.util.function.IntUnaryOperator$Lambda$_2_7(IntUnaryOperator,IntUnaryOperator,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.util.stream.BaseStream
TYPE: class java.util.stream.BaseStream 
      	fields: {
      	}
      	supers: {
      		class java.lang.AutoCloseable
      	}
      	methods: {
      		BaseStream BaseStream.unordered() 
      		Iterator BaseStream.iterator() 
      		void BaseStream.close() 
      		BaseStream BaseStream.parallel() 
      		boolean BaseStream.isParallel() 
      		Spliterator BaseStream.spliterator() 
      		BaseStream BaseStream.onClose(Runnable) 
      		BaseStream BaseStream.sequential()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.PrintWriter
TYPE: class java.io.PrintWriter 
      	fields: {
      		java.io.OutputStream* mOutputStream <> 
      		java.util.Formatter* formatter <> 
      		java.io.Writer* out <> 
      		_Bool trouble <> 
      		java.lang.String* lineSeparator <_final> 
      		_Bool autoFlush <_final> 
      		java.io.PrintStream* psOut <> 
      		unsigned short[_*_](*) writeBuffer <> 
      		java.lang.Object* lock <>
      	}
      	supers: {
      		class java.io.Writer
      	}
      	methods: {
      		void PrintWriter.print(boolean) 
      		void PrintWriter.println(Object) 
      		void PrintWriter.setError() 
      		Writer PrintWriter.append(CharSequence,int,int) 
      		PrintWriter PrintWriter.format(String,Object[]) 
      		boolean PrintWriter.checkError() 
      		void PrintWriter.println(double) 
      		void PrintWriter.print(long) 
      		PrintWriter.<init>(OutputStream,boolean) 
      		void PrintWriter.println(char) 
      		void PrintWriter.write(String,int,int) 
      		PrintWriter PrintWriter.printf(Locale,String,Object[]) 
      		void PrintWriter.print(char) 
      		void PrintWriter.write(int) 
      		void PrintWriter.print(Object) 
      		void PrintWriter.write(char[],int,int) 
      		void PrintWriter.newLine() 
      		void PrintWriter.close() 
      		void PrintWriter.println(String) 
      		Writer PrintWriter.append(char) 
      		void PrintWriter.print(double) 
      		PrintWriter PrintWriter.append(CharSequence) 
      		PrintWriter.<init>(String,String) 
      		PrintWriter.<init>(Charset,File) 
      		void PrintWriter.println(long) 
      		Appendable PrintWriter.append(CharSequence,int,int) 
      		void PrintWriter.println() 
      		void PrintWriter.flush() 
      		PrintWriter.<init>(Writer,boolean) 
      		void PrintWriter.clearError() 
      		void PrintWriter.write(char[]) 
      		PrintWriter PrintWriter.format(Locale,String,Object[]) 
      		void PrintWriter.println(char[]) 
      		void PrintWriter.print(float) 
      		PrintWriter PrintWriter.append(char) 
      		Charset PrintWriter.toCharset(String) 
      		void PrintWriter.println(int) 
      		Appendable PrintWriter.append(char) 
      		void PrintWriter.print(int) 
      		PrintWriter.<init>(Writer) 
      		void PrintWriter.println(boolean) 
      		void PrintWriter.write(String) 
      		PrintWriter PrintWriter.printf(String,Object[]) 
      		PrintWriter.<init>(String) 
      		Writer PrintWriter.append(CharSequence) 
      		void PrintWriter.print(char[]) 
      		PrintWriter PrintWriter.append(CharSequence,int,int) 
      		PrintWriter.<init>(File,String) 
      		void PrintWriter.ensureOpen() 
      		void PrintWriter.println(float) 
      		PrintWriter.<init>(OutputStream) 
      		void PrintWriter.print(String) 
      		PrintWriter.<init>(File) 
      		Appendable PrintWriter.append(CharSequence)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.http.Part
TYPE: class javax.servlet.http.Part 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Collection Part.getHeaderNames() 
      		String Part.getHeader(String) 
      		InputStream Part.getInputStream() 
      		long Part.getSize() 
      		String Part.getContentType() 
      		String Part.getName() 
      		void Part.delete() 
      		String Part.getSubmittedFileName() 
      		void Part.write(String) 
      		Collection Part.getHeaders(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.BiFunction
TYPE: class java.util.function.BiFunction 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		BiFunction BiFunction.callsite_java.util.function.BiFunction$Lambda$_1_7(BiFunction,Function) 
      		Object BiFunction.lambda$andThen$0(Function,Object,Object) 
      		Object BiFunction.access_java.util.function.BiFunction$Lambda$_1_7(BiFunction,Function,Object,Object) 
      		Object BiFunction.apply(Object,Object) 
      		BiFunction BiFunction.andThen(Function)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class javax.mail.internet.MimeMessage
TYPE: class javax.mail.internet.MimeMessage 
      	fields: {
      		javax.activation.DataHandler* dh <> 
      		_Bool saved <> 
      		signed char[_*_](*) content <> 
      		javax.mail.internet.InternetHeaders* headers <> 
      		java.lang.Object* cachedContent <> 
      		_Bool strict <> 
      		java.io.InputStream* contentStream <> 
      		javax.mail.Flags* flags <> 
      		_Bool modified <> 
      		javax.mail.Session* session <> 
      		_Bool expunged <> 
      		int msgnum <> 
      		javax.mail.Folder* folder <>
      	}
      	supers: {
      		class javax.mail.Message 
      		class javax.mail.internet.MimePart
      	}
      	methods: {
      		void MimeMessage.<clinit>() 
      		void MimeMessage.setText(String,String,String) 
      		void MimeMessage.setFrom() 
      		void MimeMessage.writeTo(OutputStream,String[]) 
      		void MimeMessage.setDataHandler(DataHandler) 
      		MimeMessage.<init>(Folder,InputStream,int) 
      		Date MimeMessage.getSentDate() 
      		Enumeration MimeMessage.getNonMatchingHeaders(String[]) 
      		String MimeMessage.getDisposition() 
      		String MimeMessage.getContentID() 
      		Address[] MimeMessage.getFrom() 
      		InputStream MimeMessage.getInputStream() 
      		String[] MimeMessage.getHeader(String) 
      		void MimeMessage.setSender(Address) 
      		String MimeMessage.getContentType() 
      		String MimeMessage.getFileName() 
      		String[] MimeMessage.getContentLanguage() 
      		void MimeMessage.setFlags(Flags,boolean) 
      		String MimeMessage.getHeaderName(Message$RecipientType) 
      		void MimeMessage.setSubject(String,String) 
      		Address[] MimeMessage.getAllRecipients() 
      		Enumeration MimeMessage.getNonMatchingHeaderLines(String[]) 
      		void MimeMessage.setContent(Multipart) 
      		void MimeMessage.addHeader(String,String) 
      		Message MimeMessage.reply(boolean) 
      		void MimeMessage.setFrom(String) 
      		InternetHeaders MimeMessage.createInternetHeaders(InputStream) 
      		MimeMessage.<init>(Session) 
      		Date MimeMessage.getReceivedDate() 
      		void MimeMessage.updateHeaders() 
      		Message MimeMessage.reply(boolean,boolean) 
      		String MimeMessage.getDescription() 
      		String MimeMessage.getContentMD5() 
      		String MimeMessage.getHeader(String,String) 
      		void MimeMessage.setReplyTo(Address[]) 
      		Enumeration MimeMessage.getAllHeaderLines() 
      		Enumeration MimeMessage.getAllHeaders() 
      		int MimeMessage.getLineCount() 
      		void MimeMessage.addRecipients(Message$RecipientType,String) 
      		Address[] MimeMessage.getRecipients(Message$RecipientType) 
      		Address[] MimeMessage.getAddressHeader(String) 
      		void MimeMessage.setSubject(String) 
      		MimeMessage.<init>(Session,InputStream) 
      		void MimeMessage.initStrict() 
      		Address[] MimeMessage.eliminateDuplicates(Vector,Address[]) 
      		DataHandler MimeMessage.getDataHandler() 
      		String MimeMessage.getMessageID() 
      		MimeMessage.<init>(Folder,int) 
      		void MimeMessage.addFrom(Address[]) 
      		void MimeMessage.setText(String) 
      		InputStream MimeMessage.getContentStream() 
      		MimeMessage.<init>(Folder,InternetHeaders,byte[],int) 
      		void MimeMessage.setSentDate(Date) 
      		void MimeMessage.setDisposition(String) 
      		void MimeMessage.setContentID(String) 
      		Flags MimeMessage.getFlags() 
      		void MimeMessage.addAddressHeader(String,Address[]) 
      		Address[] MimeMessage.getReplyTo() 
      		void MimeMessage.addHeaderLine(String) 
      		void MimeMessage.removeHeader(String) 
      		int MimeMessage.getSize() 
      		void MimeMessage.setRecipients(Message$RecipientType,String) 
      		void MimeMessage.setRecipients(Message$RecipientType,Address[]) 
      		void MimeMessage.updateMessageID() 
      		void MimeMessage.setFileName(String) 
      		void MimeMessage.setContentLanguage(String[]) 
      		void MimeMessage.writeTo(OutputStream) 
      		void MimeMessage.saveChanges() 
      		Address MimeMessage.getSender() 
      		void MimeMessage.setDescription(String,String) 
      		void MimeMessage.setFrom(Address) 
      		boolean MimeMessage.isSet(Flags$Flag) 
      		void MimeMessage.setHeader(String,String) 
      		MimeMessage MimeMessage.createMimeMessage(Session) 
      		void MimeMessage.setDescription(String) 
      		void MimeMessage.setContentMD5(String) 
      		String MimeMessage.getSubject() 
      		Enumeration MimeMessage.getMatchingHeaderLines(String[]) 
      		Enumeration MimeMessage.getMatchingHeaders(String[]) 
      		void MimeMessage.setText(String,String) 
      		boolean MimeMessage.isMimeType(String) 
      		String MimeMessage.getEncoding() 
      		void MimeMessage.addRecipients(Message$RecipientType,Address[]) 
      		void MimeMessage.setAddressHeader(String,Address[]) 
      		void MimeMessage.setContent(Object,String) 
      		MimeMessage.<init>(MimeMessage) 
      		void MimeMessage.parse(InputStream) 
      		Object MimeMessage.getContent() 
      		InputStream MimeMessage.getRawInputStream()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.util.locale.provider.LocaleProviderAdapter
TYPE: class sun.util.locale.provider.LocaleProviderAdapter 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void LocaleProviderAdapter.<clinit>() 
      		LocaleServiceProvider LocaleProviderAdapter.getLocaleServiceProvider(Class) 
      		LocaleProviderAdapter LocaleProviderAdapter.getResourceBundleBased() 
      		LocaleProviderAdapter LocaleProviderAdapter.getAdapter(Class,Locale) 
      		CollatorProvider LocaleProviderAdapter.getCollatorProvider() 
      		Locale[] LocaleProviderAdapter.getAvailableLocales() 
      		boolean LocaleProviderAdapter.isSupportedLocale(Locale,LocaleProviderAdapter$Type,Set) 
      		TimeZoneNameProvider LocaleProviderAdapter.getTimeZoneNameProvider() 
      		LocaleProviderAdapter LocaleProviderAdapter.forType(LocaleProviderAdapter$Type) 
      		LocaleProviderAdapter LocaleProviderAdapter.forJRE() 
      		CurrencyNameProvider LocaleProviderAdapter.getCurrencyNameProvider() 
      		LocaleProviderAdapter.<init>() 
      		DateFormatSymbolsProvider LocaleProviderAdapter.getDateFormatSymbolsProvider() 
      		LocaleProviderAdapter$Type LocaleProviderAdapter.getAdapterType() 
      		CalendarNameProvider LocaleProviderAdapter.getCalendarNameProvider() 
      		LocaleResources LocaleProviderAdapter.getLocaleResources(Locale) 
      		DecimalFormatSymbolsProvider LocaleProviderAdapter.getDecimalFormatSymbolsProvider() 
      		Locale[] LocaleProviderAdapter.toLocaleArray(Set) 
      		NumberFormatProvider LocaleProviderAdapter.getNumberFormatProvider() 
      		CalendarDataProvider LocaleProviderAdapter.getCalendarDataProvider() 
      		LocaleProviderAdapter LocaleProviderAdapter.findAdapter(Class,Locale) 
      		DateFormatProvider LocaleProviderAdapter.getDateFormatProvider() 
      		LocaleNameProvider LocaleProviderAdapter.getLocaleNameProvider() 
      		List LocaleProviderAdapter.getAdapterPreference() 
      		CalendarProvider LocaleProviderAdapter.getCalendarProvider() 
      		BreakIteratorProvider LocaleProviderAdapter.getBreakIteratorProvider()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.net.URLStreamHandler
TYPE: class java.net.URLStreamHandler 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		boolean URLStreamHandler.equals(URL,URL) 
      		boolean URLStreamHandler.hostsEqual(URL,URL) 
      		String URLStreamHandler.toExternalForm(URL) 
      		void URLStreamHandler.setURL(URL,String,String,int,String,String,String,String,String) 
      		boolean URLStreamHandler.sameFile(URL,URL) 
      		URLStreamHandler.<init>() 
      		void URLStreamHandler.setURL(URL,String,String,int,String,String) 
      		URLConnection URLStreamHandler.openConnection(URL) 
      		void URLStreamHandler.parseURL(URL,String,int,int) 
      		URLConnection URLStreamHandler.openConnection(URL,Proxy) 
      		int URLStreamHandler.hashCode(URL) 
      		InetAddress URLStreamHandler.getHostAddress(URL) 
      		int URLStreamHandler.getDefaultPort()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.reflect.AnnotatedElement
TYPE: class java.lang.reflect.AnnotatedElement 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Annotation AnnotatedElement.lambda$getDeclaredAnnotationsByType$0(Annotation,Annotation) 
      		Annotation AnnotatedElement.getAnnotation(Class) 
      		BinaryOperator AnnotatedElement.callsite_java.lang.reflect.AnnotatedElement$Lambda$_3_22() 
      		Annotation[] AnnotatedElement.getDeclaredAnnotationsByType(Class) 
      		Class AnnotatedElement.access_java.lang.reflect.AnnotatedElement$Lambda$_3_14(AnnotatedElement) 
      		Annotation[] AnnotatedElement.getAnnotations() 
      		Supplier AnnotatedElement.callsite_java.lang.reflect.AnnotatedElement$Lambda$_3_27() 
      		Function AnnotatedElement.callsite_java.lang.reflect.AnnotatedElement$Lambda$_3_14() 
      		boolean AnnotatedElement.isAnnotationPresent(Class) 
      		Annotation[] AnnotatedElement.getAnnotationsByType(Class) 
      		Annotation AnnotatedElement.access_java.lang.reflect.AnnotatedElement$Lambda$_3_22(Annotation,Annotation) 
      		Annotation[] AnnotatedElement.getDeclaredAnnotations() 
      		Annotation AnnotatedElement.getDeclaredAnnotation(Class) 
      		LinkedHashMap AnnotatedElement.access_java.lang.reflect.AnnotatedElement$Lambda$_3_27()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.IntPredicate
TYPE: class java.util.function.IntPredicate 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		boolean IntPredicate.lambda$negate$1(int) 
      		IntPredicate IntPredicate.callsite_java.util.function.IntPredicate$Lambda$_5_1(IntPredicate) 
      		IntPredicate IntPredicate.or(IntPredicate) 
      		boolean IntPredicate.access_java.util.function.IntPredicate$Lambda$_6_7(IntPredicate,IntPredicate,int) 
      		IntPredicate IntPredicate.and(IntPredicate) 
      		boolean IntPredicate.access_java.util.function.IntPredicate$Lambda$_5_1(IntPredicate,int) 
      		boolean IntPredicate.test(int) 
      		boolean IntPredicate.lambda$or$2(IntPredicate,int) 
      		IntPredicate IntPredicate.callsite_java.util.function.IntPredicate$Lambda$_1_7(IntPredicate,IntPredicate) 
      		IntPredicate IntPredicate.negate() 
      		IntPredicate IntPredicate.callsite_java.util.function.IntPredicate$Lambda$_6_7(IntPredicate,IntPredicate) 
      		boolean IntPredicate.access_java.util.function.IntPredicate$Lambda$_1_7(IntPredicate,IntPredicate,int) 
      		boolean IntPredicate.lambda$and$0(IntPredicate,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class com.stn.helpers.NewsHelper
TYPE: class com.stn.helpers.NewsHelper 
      	fields: {
      		java.lang.String* dbUser <> 
      		java.sql.PreparedStatement* preparedStatement <> 
      		java.lang.String* query <> 
      		java.lang.String* dbPort <> 
      		java.lang.String* dbHost <> 
      		java.lang.String* dbPassword <> 
      		java.sql.ResultSet* resultSet <> 
      		java.sql.Connection* connection <> 
      		java.lang.String* dbName <>
      	}
      	supers: {
      		class com.stn.utils.DBConnection
      	}
      	methods: {
      		void NewsHelper.deleteNews(int) 
      		void NewsHelper.addNews(String,String,int,int) 
      		void NewsHelper.updateBody(int,String) 
      		NewsHelper.<init>() 
      		void NewsHelper.updateTitle(int,String) 
      		List NewsHelper.getNews(int,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.text.SimpleDateFormat
TYPE: class java.text.SimpleDateFormat 
      	fields: {
      		java.util.Date* defaultCenturyStart <> 
      		_Bool hasFollowingMinusSign <> 
      		unsigned short zeroDigit <> 
      		java.util.Locale* locale <> 
      		_Bool useDateFormatSymbols <> 
      		java.lang.String* pattern <> 
      		int serialVersionOnStream <> 
      		java.lang.String* originalNumberPattern <> 
      		int defaultCenturyStartYear <> 
      		_Bool forceStandaloneForm <> 
      		unsigned short[_*_](*) compiledPattern <> 
      		java.text.NumberFormat* originalNumberFormat <> 
      		java.text.DateFormatSymbols* formatData <> 
      		unsigned short minusSign <> 
      		java.util.Calendar* calendar <> 
      		java.text.NumberFormat* numberFormat <>
      	}
      	supers: {
      		class java.text.DateFormat
      	}
      	methods: {
      		void SimpleDateFormat.<clinit>() 
      		int SimpleDateFormat.hashCode() 
      		String SimpleDateFormat.translatePattern(String,String,String) 
      		int SimpleDateFormat.matchString(String,int,int,String[],CalendarBuilder) 
      		boolean SimpleDateFormat.equals(Object) 
      		AttributedCharacterIterator SimpleDateFormat.formatToCharacterIterator(Object) 
      		SimpleDateFormat.<init>(String,DateFormatSymbols) 
      		Object SimpleDateFormat.clone() 
      		void SimpleDateFormat.initializeCalendar(Locale) 
      		void SimpleDateFormat.applyPattern(String) 
      		void SimpleDateFormat.subFormat(int,int,Format$FieldDelegate,StringBuffer,boolean) 
      		String SimpleDateFormat.toPattern() 
      		int SimpleDateFormat.matchString(String,int,int,Map,CalendarBuilder) 
      		boolean SimpleDateFormat.matchDSTString(String,int,int,int,String[][]) 
      		void SimpleDateFormat.parseAmbiguousDatesAsAfter(Date) 
      		SimpleDateFormat.<init>() 
      		Date SimpleDateFormat.get2DigitYearStart() 
      		void SimpleDateFormat.encode(int,int,StringBuilder) 
      		int SimpleDateFormat.subParseZoneString(String,int,CalendarBuilder) 
      		void SimpleDateFormat.initialize(Locale) 
      		DateFormatSymbols SimpleDateFormat.getDateFormatSymbols() 
      		StringBuffer SimpleDateFormat.format(Date,StringBuffer,Format$FieldDelegate) 
      		int SimpleDateFormat.subParse(String,int,int,int,boolean,boolean[],ParsePosition,boolean,CalendarBuilder) 
      		void SimpleDateFormat.readObject(ObjectInputStream) 
      		Map SimpleDateFormat.getDisplayNamesMap(int,Locale) 
      		void SimpleDateFormat.zeroPaddingNumber(int,int,int,StringBuffer) 
      		Date SimpleDateFormat.parse(String,ParsePosition) 
      		void SimpleDateFormat.set2DigitYearStart(Date) 
      		int SimpleDateFormat.subParseNumericZone(String,int,int,int,boolean,CalendarBuilder) 
      		void SimpleDateFormat.applyLocalizedPattern(String) 
      		void SimpleDateFormat.checkNegativeNumberExpression() 
      		int SimpleDateFormat.matchZoneString(String,int,String[]) 
      		void SimpleDateFormat.initializeDefaultCentury() 
      		void SimpleDateFormat.applyPatternImpl(String) 
      		String SimpleDateFormat.toLocalizedPattern() 
      		boolean SimpleDateFormat.isDigit(char) 
      		SimpleDateFormat.<init>(String) 
      		SimpleDateFormat.<init>(String,Locale) 
      		StringBuffer SimpleDateFormat.format(Date,StringBuffer,FieldPosition) 
      		char[] SimpleDateFormat.compile(String) 
      		void SimpleDateFormat.setDateFormatSymbols(DateFormatSymbols) 
      		boolean SimpleDateFormat.useDateFormatSymbols()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Number
TYPE: class java.lang.Number 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable
      	}
      	methods: {
      		short Number.shortValue() 
      		Number.<init>() 
      		float Number.floatValue() 
      		int Number.intValue() 
      		double Number.doubleValue() 
      		long Number.longValue() 
      		byte Number.byteValue()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.management.MBeanServer
TYPE: class javax.management.MBeanServer 
      	fields: {
      	}
      	supers: {
      		class javax.management.MBeanServerConnection
      	}
      	methods: {
      		ObjectInstance MBeanServer.registerMBean(Object,ObjectName) 
      		String MBeanServer.getDefaultDomain() 
      		ClassLoader MBeanServer.getClassLoaderFor(ObjectName) 
      		MBeanInfo MBeanServer.getMBeanInfo(ObjectName) 
      		Set MBeanServer.queryMBeans(ObjectName,QueryExp) 
      		Object MBeanServer.instantiate(String,ObjectName,Object[],String[]) 
      		void MBeanServer.removeNotificationListener(ObjectName,ObjectName) 
      		ObjectInstance MBeanServer.createMBean(String,ObjectName,Object[],String[]) 
      		boolean MBeanServer.isRegistered(ObjectName) 
      		AttributeList MBeanServer.getAttributes(ObjectName,String[]) 
      		Object MBeanServer.instantiate(String,ObjectName) 
      		void MBeanServer.addNotificationListener(ObjectName,NotificationListener,NotificationFilter,Object) 
      		ObjectInstance MBeanServer.createMBean(String,ObjectName) 
      		ClassLoaderRepository MBeanServer.getClassLoaderRepository() 
      		Integer MBeanServer.getMBeanCount() 
      		ObjectInputStream MBeanServer.deserialize(String,byte[]) 
      		void MBeanServer.removeNotificationListener(ObjectName,NotificationListener) 
      		void MBeanServer.unregisterMBean(ObjectName) 
      		AttributeList MBeanServer.setAttributes(ObjectName,AttributeList) 
      		Object MBeanServer.instantiate(String) 
      		String[] MBeanServer.getDomains() 
      		boolean MBeanServer.isInstanceOf(ObjectName,String) 
      		ClassLoader MBeanServer.getClassLoader(ObjectName) 
      		Set MBeanServer.queryNames(ObjectName,QueryExp) 
      		ObjectInputStream MBeanServer.deserialize(ObjectName,byte[]) 
      		void MBeanServer.removeNotificationListener(ObjectName,ObjectName,NotificationFilter,Object) 
      		ObjectInstance MBeanServer.createMBean(String,ObjectName,ObjectName,Object[],String[]) 
      		void MBeanServer.setAttribute(ObjectName,Attribute) 
      		Object MBeanServer.instantiate(String,Object[],String[]) 
      		void MBeanServer.addNotificationListener(ObjectName,ObjectName,NotificationFilter,Object) 
      		ObjectInstance MBeanServer.createMBean(String,ObjectName,ObjectName) 
      		Object MBeanServer.getAttribute(ObjectName,String) 
      		ObjectInputStream MBeanServer.deserialize(String,ObjectName,byte[]) 
      		void MBeanServer.removeNotificationListener(ObjectName,NotificationListener,NotificationFilter,Object) 
      		ObjectInstance MBeanServer.getObjectInstance(ObjectName) 
      		Object MBeanServer.invoke(ObjectName,String,Object[],String[])
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.awt.datatransfer.Transferable
TYPE: class java.awt.datatransfer.Transferable 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		boolean Transferable.isDataFlavorSupported(DataFlavor) 
      		DataFlavor[] Transferable.getTransferDataFlavors() 
      		Object Transferable.getTransferData(DataFlavor)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.EventListener
TYPE: class java.util.EventListener 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.Connection
TYPE: class java.sql.Connection 
      	fields: {
      	}
      	supers: {
      		class java.sql.Wrapper 
      		class java.lang.AutoCloseable
      	}
      	methods: {
      		void Connection.setNetworkTimeout(Executor,int) 
      		SQLWarning Connection.getWarnings() 
      		PreparedStatement Connection.prepareStatement(String,int[]) 
      		int Connection.getHoldability() 
      		boolean Connection.isClosed() 
      		void Connection.setClientInfo(Properties) 
      		CallableStatement Connection.prepareCall(String,int,int) 
      		void Connection.setAutoCommit(boolean) 
      		NClob Connection.createNClob() 
      		void Connection.releaseSavepoint(Savepoint) 
      		void Connection.setCatalog(String) 
      		Struct Connection.createStruct(String,Object[]) 
      		Statement Connection.createStatement(int,int) 
      		CallableStatement Connection.prepareCall(String) 
      		Clob Connection.createClob() 
      		Savepoint Connection.setSavepoint(String) 
      		void Connection.close() 
      		void Connection.setReadOnly(boolean) 
      		Properties Connection.getClientInfo() 
      		void Connection.setTypeMap(Map) 
      		void Connection.commit() 
      		boolean Connection.isValid(int) 
      		PreparedStatement Connection.prepareStatement(String,int,int,int) 
      		void Connection.setTransactionIsolation(int) 
      		String Connection.getSchema() 
      		int Connection.getNetworkTimeout() 
      		void Connection.clearWarnings() 
      		Statement Connection.createStatement() 
      		PreparedStatement Connection.prepareStatement(String,String[]) 
      		Savepoint Connection.setSavepoint() 
      		DatabaseMetaData Connection.getMetaData() 
      		String Connection.getClientInfo(String) 
      		Map Connection.getTypeMap() 
      		boolean Connection.getAutoCommit() 
      		SQLXML Connection.createSQLXML() 
      		Statement Connection.createStatement(int,int,int) 
      		String Connection.getCatalog() 
      		void Connection.setSchema(String) 
      		PreparedStatement Connection.prepareStatement(String,int,int) 
      		String Connection.nativeSQL(String) 
      		PreparedStatement Connection.prepareStatement(String,int) 
      		Blob Connection.createBlob() 
      		void Connection.rollback(Savepoint) 
      		PreparedStatement Connection.prepareStatement(String) 
      		boolean Connection.isReadOnly() 
      		Array Connection.createArrayOf(String,Object[]) 
      		void Connection.setHoldability(int) 
      		void Connection.rollback() 
      		void Connection.setClientInfo(String,String) 
      		CallableStatement Connection.prepareCall(String,int,int,int) 
      		int Connection.getTransactionIsolation() 
      		void Connection.abort(Executor)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.DataInput
TYPE: class java.io.DataInput 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		boolean DataInput.readBoolean() 
      		float DataInput.readFloat() 
      		int DataInput.readUnsignedShort() 
      		void DataInput.readFully(byte[]) 
      		int DataInput.readUnsignedByte() 
      		String DataInput.readLine() 
      		int DataInput.readInt() 
      		byte DataInput.readByte() 
      		double DataInput.readDouble() 
      		int DataInput.skipBytes(int) 
      		char DataInput.readChar() 
      		void DataInput.readFully(byte[],int,int) 
      		short DataInput.readShort() 
      		String DataInput.readUTF() 
      		long DataInput.readLong()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.EditComment
TYPE: class com.stn.servlets.EditComment 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void EditComment.doPost(HttpServletRequest,HttpServletResponse) 
      		EditComment.<init>() 
      		void EditComment.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/EditComment")>
      	}NAME: class javax.mail.Message
TYPE: class javax.mail.Message 
      	fields: {
      		javax.mail.Session* session <> 
      		_Bool expunged <> 
      		int msgnum <> 
      		javax.mail.Folder* folder <>
      	}
      	supers: {
      		class java.lang.Object 
      		class javax.mail.Part
      	}
      	methods: {
      		void Message.setFrom() 
      		boolean Message.isExpunged() 
      		Date Message.getSentDate() 
      		Address[] Message.getFrom() 
      		void Message.addRecipient(Message$RecipientType,Address) 
      		boolean Message.match(SearchTerm) 
      		void Message.setFlag(Flags$Flag,boolean) 
      		void Message.setFlags(Flags,boolean) 
      		Address[] Message.getAllRecipients() 
      		Message Message.reply(boolean) 
      		Message.<init>(Session) 
      		Date Message.getReceivedDate() 
      		Message.<init>() 
      		void Message.setReplyTo(Address[]) 
      		Address[] Message.getRecipients(Message$RecipientType) 
      		void Message.setSubject(String) 
      		void Message.setMessageNumber(int) 
      		Message.<init>(Folder,int) 
      		void Message.addFrom(Address[]) 
      		void Message.setExpunged(boolean) 
      		void Message.setSentDate(Date) 
      		Flags Message.getFlags() 
      		Address[] Message.getReplyTo() 
      		void Message.setRecipients(Message$RecipientType,Address[]) 
      		int Message.getMessageNumber() 
      		void Message.setRecipient(Message$RecipientType,Address) 
      		void Message.saveChanges() 
      		void Message.setFrom(Address) 
      		boolean Message.isSet(Flags$Flag) 
      		String Message.getSubject() 
      		void Message.addRecipients(Message$RecipientType,Address[]) 
      		Folder Message.getFolder() 
      		Session Message.getSession()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Exception
TYPE: class java.lang.Exception 
      	fields: {
      		java.lang.String* detailMessage <> 
      		java.lang.Object* backtrace <> 
      		java.lang.StackTraceElement*[_*_](*) stackTrace <> 
      		java.lang.Throwable* cause <> 
      		java.util.List* suppressedExceptions <>
      	}
      	supers: {
      		class java.lang.Throwable
      	}
      	methods: {
      		Exception.<init>(String,Throwable,boolean,boolean) 
      		Exception.<init>(String,Throwable) 
      		Exception.<init>() 
      		Exception.<init>(Throwable) 
      		Exception.<init>(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Enumeration
TYPE: class java.util.Enumeration 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		boolean Enumeration.hasMoreElements() 
      		Object Enumeration.nextElement()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.text.AttributedCharacterIterator$Attribute
TYPE: class java.text.AttributedCharacterIterator$Attribute 
      	fields: {
      		java.lang.String* name <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable
      	}
      	methods: {
      		void AttributedCharacterIterator$Attribute.<clinit>() 
      		int AttributedCharacterIterator$Attribute.hashCode() 
      		boolean AttributedCharacterIterator$Attribute.equals(Object) 
      		String AttributedCharacterIterator$Attribute.getName() 
      		String AttributedCharacterIterator$Attribute.toString() 
      		Object AttributedCharacterIterator$Attribute.readResolve() 
      		AttributedCharacterIterator$Attribute.<init>(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.ReadListener
TYPE: class javax.servlet.ReadListener 
      	fields: {
      	}
      	supers: {
      		class java.util.EventListener
      	}
      	methods: {
      		void ReadListener.onAllDataRead() 
      		void ReadListener.onError(Throwable) 
      		void ReadListener.onDataAvailable()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.security.Guard
TYPE: class java.security.Guard 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void Guard.checkGuard(Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.helpers.UserHelper
TYPE: class com.stn.helpers.UserHelper 
      	fields: {
      		java.lang.String* dbUser <> 
      		java.sql.PreparedStatement* preparedStatement <> 
      		java.lang.String* query <> 
      		java.lang.String* dbPort <> 
      		java.lang.String* dbHost <> 
      		java.lang.String* dbPassword <> 
      		java.sql.ResultSet* resultSet <> 
      		java.sql.Connection* connection <> 
      		java.lang.String* dbName <>
      	}
      	supers: {
      		class com.stn.utils.DBConnection
      	}
      	methods: {
      		void UserHelper.<clinit>() 
      		void UserHelper.updateFacultate(int,int) 
      		boolean UserHelper.checkEmail(String) 
      		boolean UserHelper.checkAvailability(String,String) 
      		String UserHelper.classColor(int) 
      		void UserHelper.updatePassword(String,String,byte[]) 
      		void UserHelper.updateIp(int,String) 
      		List UserHelper.getUsers() 
      		User UserHelper.getUserInfo(int) 
      		void UserHelper.updateFacultateAdmin(int,int,int,int) 
      		String UserHelper.genderName(int) 
      		UserHelper.<init>() 
      		void UserHelper.updateUser(int,int,String,String,String,String,String,int,int) 
      		void UserHelper.verifyAcces(HttpServletRequest,HttpServletResponse) 
      		String UserHelper.className(int) 
      		void UserHelper.addUser(String,String,byte[],String,String,String,int,int,int,int) 
      		void UserHelper.updateLastSeen(int) 
      		void UserHelper.deleteToken(int) 
      		void UserHelper.updateProfile(int,int,int) 
      		User UserHelper.getPassword(int) 
      		int UserHelper.authenticateUser(String,String) 
      		void UserHelper.deleteGrupa(int) 
      		String UserHelper.genderImage(int) 
      		int UserHelper.checkLoginToken(String,String) 
      		void UserHelper.updateLoginToken(int,String,String) 
      		void UserHelper.verifyAuthentication(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.time.temporal.TemporalAdjuster
TYPE: class java.time.temporal.TemporalAdjuster 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Temporal TemporalAdjuster.adjustInto(Temporal)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class com.stn.servlets.LoginProcess
TYPE: class com.stn.servlets.LoginProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void LoginProcess.doPost(HttpServletRequest,HttpServletResponse) 
      		LoginProcess.<init>() 
      		void LoginProcess.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/LoginProcess")>
      	}NAME: class javax.management.NotificationListener
TYPE: class javax.management.NotificationListener 
      	fields: {
      	}
      	supers: {
      		class java.util.EventListener
      	}
      	methods: {
      		void NotificationListener.handleNotification(Notification,Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.HashMap$Node
TYPE: class java.util.HashMap$Node 
      	fields: {
      		java.util.HashMap$Node* next <> 
      		java.lang.Object* key <_final> 
      		java.lang.Object* value <> 
      		int hash <_final>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.util.Map$Entry
      	}
      	methods: {
      		int HashMap$Node.hashCode() 
      		boolean HashMap$Node.equals(Object) 
      		Object HashMap$Node.getKey() 
      		Object HashMap$Node.setValue(Object) 
      		HashMap$Node.<init>(int,Object,Object,HashMap$Node) 
      		String HashMap$Node.toString() 
      		Object HashMap$Node.getValue()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.util.calendar.BaseCalendar$Date
TYPE: class sun.util.calendar.BaseCalendar$Date 
      	fields: {
      		long cachedFixedDateJan1 <> 
      		long cachedFixedDateNextJan1 <> 
      		int cachedYear <> 
      		int daylightSaving <> 
      		int month <> 
      		sun.util.calendar.Era* era <> 
      		java.util.Locale* locale <> 
      		int seconds <> 
      		int dayOfWeek <> 
      		int hours <> 
      		int year <> 
      		long fraction <> 
      		int zoneOffset <> 
      		int dayOfMonth <> 
      		_Bool normalized <> 
      		int millis <> 
      		java.util.TimeZone* zoneinfo <> 
      		int minutes <> 
      		_Bool leapYear <> 
      		_Bool forceStandardTime <>
      	}
      	supers: {
      		class sun.util.calendar.CalendarDate
      	}
      	methods: {
      		BaseCalendar$Date.<init>(TimeZone) 
      		int BaseCalendar$Date.getCachedYear() 
      		BaseCalendar$Date BaseCalendar$Date.setNormalizedDate(int,int,int) 
      		boolean BaseCalendar$Date.hit(int) 
      		BaseCalendar$Date.<init>() 
      		void BaseCalendar$Date.setNormalizedYear(int) 
      		void BaseCalendar$Date.setCache(int,long,int) 
      		long BaseCalendar$Date.getCachedJan1() 
      		boolean BaseCalendar$Date.hit(long) 
      		int BaseCalendar$Date.getNormalizedYear()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.helpers.OrarHelper
TYPE: class com.stn.helpers.OrarHelper 
      	fields: {
      		java.lang.String* dbUser <> 
      		java.sql.PreparedStatement* preparedStatement <> 
      		java.lang.String* query <> 
      		java.lang.String* dbPort <> 
      		java.lang.String* dbHost <> 
      		java.lang.String* dbPassword <> 
      		java.sql.ResultSet* resultSet <> 
      		java.sql.Connection* connection <> 
      		java.lang.String* dbName <>
      	}
      	supers: {
      		class com.stn.utils.DBConnection
      	}
      	methods: {
      		void OrarHelper.updateNotes(Integer,Integer,String,String,Integer) 
      		void OrarHelper.addOra(Integer,String,String,String,Integer,String,String,String,Integer,String) 
      		Orar OrarHelper.getOra(Integer,ArrayList) 
      		void OrarHelper.deleteOra(Integer) 
      		ArrayList OrarHelper.getOrar(Integer) 
      		OrarHelper.<init>() 
      		Notes OrarHelper.getSchool(int,int) 
      		Integer OrarHelper.getGrupaOra(Integer) 
      		ArrayList OrarHelper.getSchools(Integer) 
      		void OrarHelper.addNotes(Integer,Integer,String,String,String,Integer,String,String,String,Integer,String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Comparable
TYPE: class java.lang.Comparable 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		int Comparable.compareTo(Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.ClassLoader
TYPE: class java.lang.ClassLoader 
      	fields: {
      		java.util.concurrent.ConcurrentHashMap* parallelLockMap <_final> 
      		java.lang.Object* assertionLock <_final> 
      		java.util.Vector* nativeLibraries <> 
      		java.security.ProtectionDomain* defaultDomain <_final> 
      		java.util.Map* packageAssertionStatus <> 
      		java.util.Map* package2certs <_final> 
      		java.util.Vector* classes <_final> 
      		java.util.Map* classAssertionStatus <> 
      		_Bool defaultAssertionStatus <> 
      		java.util.HashMap* packages <_final> 
      		java.lang.ClassLoader* parent <_final>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void ClassLoader.<clinit>() 
      		URL ClassLoader.getBootstrapResource(String) 
      		Class ClassLoader.defineClass0(String,byte[],int,int,ProtectionDomain) 
      		boolean ClassLoader.desiredAssertionStatus(String) 
      		Object ClassLoader.getClassLoadingLock(String) 
      		String ClassLoader.findLibrary(String) 
      		void ClassLoader.checkCerts(String,CodeSource) 
      		void ClassLoader.setDefaultAssertionStatus(boolean) 
      		Package ClassLoader.getPackage(String) 
      		Enumeration ClassLoader.findResources(String) 
      		ClassLoader ClassLoader.getParent() 
      		InputStream ClassLoader.getResourceAsStream(String) 
      		ProtectionDomain ClassLoader.preDefineClass(String,ProtectionDomain) 
      		boolean ClassLoader.isAncestor(ClassLoader) 
      		Vector ClassLoader.access$000() 
      		Class ClassLoader.loadClassInternal(String) 
      		boolean ClassLoader.compareCerts(Certificate[],Certificate[]) 
      		Enumeration ClassLoader.getResources(String) 
      		ClassLoader ClassLoader.getSystemClassLoader() 
      		boolean ClassLoader.registerAsParallelCapable() 
      		Class ClassLoader.findBootstrapClassOrNull(String) 
      		String ClassLoader.findBuiltinLib(String) 
      		void ClassLoader.initSystemClassLoader() 
      		void ClassLoader.setClassAssertionStatus(String,boolean) 
      		Package[] ClassLoader.getPackages() 
      		void ClassLoader.resolveClass(Class) 
      		AssertionStatusDirectives ClassLoader.retrieveDirectives() 
      		ClassLoader.<init>(ClassLoader) 
      		Class ClassLoader.defineClass2(String,ByteBuffer,int,int,ProtectionDomain,String) 
      		ClassLoader.<init>() 
      		void ClassLoader.loadLibrary(Class,String,boolean) 
      		URL ClassLoader.getResource(String) 
      		Class ClassLoader.defineClass1(String,byte[],int,int,ProtectionDomain,String) 
      		String[] ClassLoader.initializePath(String) 
      		Class ClassLoader.defineClass(String,byte[],int,int,ProtectionDomain) 
      		Class ClassLoader.defineClass(String,byte[],int,int) 
      		ClassLoader.<init>(Void,ClassLoader) 
      		Class ClassLoader.findBootstrapClass(String) 
      		URL ClassLoader.findResource(String) 
      		Class ClassLoader.loadClass(String) 
      		void ClassLoader.checkClassLoaderPermission(ClassLoader,Class) 
      		Class ClassLoader.findSystemClass(String) 
      		Class ClassLoader.findLoadedClass(String) 
      		ClassLoader ClassLoader.getClassLoader(Class) 
      		void ClassLoader.setPackageAssertionStatus(String,boolean) 
      		void ClassLoader.initializeJavaAssertionMaps() 
      		Package ClassLoader.definePackage(String,String,String,String,String,String,String,URL) 
      		URL ClassLoader.getSystemResource(String) 
      		String ClassLoader.defineClassSourceLocation(ProtectionDomain) 
      		boolean ClassLoader.needsClassLoaderPermissionCheck(ClassLoader,ClassLoader) 
      		Stack ClassLoader.access$100() 
      		Class ClassLoader.defineClass(byte[],int,int) 
      		Void ClassLoader.checkCreateClassLoader() 
      		void ClassLoader.resolveClass0(Class) 
      		Enumeration ClassLoader.getBootstrapResources(String) 
      		Enumeration ClassLoader.getSystemResources(String) 
      		Class ClassLoader.findClass(String) 
      		InputStream ClassLoader.getSystemResourceAsStream(String) 
      		void ClassLoader.setSigners(Class,Object[]) 
      		void ClassLoader.registerNatives() 
      		void ClassLoader.clearAssertionStatus() 
      		void ClassLoader.checkPackageAccess(Class,ProtectionDomain) 
      		void ClassLoader.addClass(Class) 
      		URLClassPath ClassLoader.getBootstrapClassPath() 
      		long ClassLoader.findNative(ClassLoader,String) 
      		void ClassLoader.postDefineClass(Class,ProtectionDomain) 
      		boolean ClassLoader.loadLibrary0(Class,File) 
      		boolean ClassLoader.checkName(String) 
      		Class ClassLoader.defineClass(String,ByteBuffer,ProtectionDomain) 
      		Class ClassLoader.loadClass(String,boolean) 
      		Class ClassLoader.findLoadedClass0(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.reflect.GenericDeclaration
TYPE: class java.lang.reflect.GenericDeclaration 
      	fields: {
      	}
      	supers: {
      		class java.lang.reflect.AnnotatedElement
      	}
      	methods: {
      		TypeVariable[] GenericDeclaration.getTypeParameters()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.StringBuilder
TYPE: class java.lang.StringBuilder 
      	fields: {
      		int count <> 
      		unsigned short[_*_](*) value <>
      	}
      	supers: {
      		class java.lang.AbstractStringBuilder 
      		class java.io.Serializable 
      		class java.lang.CharSequence
      	}
      	methods: {
      		AbstractStringBuilder StringBuilder.insert(int,Object) 
      		StringBuilder.<init>(int) 
      		void StringBuilder.getChars(int,int,char[],int) 
      		StringBuilder StringBuilder.append(boolean) 
      		StringBuilder StringBuilder.insert(int,int) 
      		AbstractStringBuilder StringBuilder.append(StringBuffer) 
      		AbstractStringBuilder StringBuilder.insert(int,long) 
      		void StringBuilder.ensureCapacity(int) 
      		String StringBuilder.substring(int,int) 
      		StringBuilder StringBuilder.insert(int,char[],int,int) 
      		AbstractStringBuilder StringBuilder.append(long) 
      		AbstractStringBuilder StringBuilder.insert(int,CharSequence,int,int) 
      		StringBuilder StringBuilder.append(StringBuffer) 
      		StringBuilder StringBuilder.insert(int,CharSequence) 
      		char StringBuilder.charAt(int) 
      		AbstractStringBuilder StringBuilder.append(char[],int,int) 
      		StringBuilder StringBuilder.reverse() 
      		StringBuilder StringBuilder.append(Object) 
      		int StringBuilder.indexOf(String) 
      		StringBuilder StringBuilder.delete(int,int) 
      		AbstractStringBuilder StringBuilder.delete(int,int) 
      		AbstractStringBuilder StringBuilder.insert(int,char[]) 
      		void StringBuilder.writeObject(ObjectOutputStream) 
      		StringBuilder StringBuilder.append(char[]) 
      		StringBuilder StringBuilder.insert(int,boolean) 
      		String StringBuilder.substring(int) 
      		AbstractStringBuilder StringBuilder.append(CharSequence,int,int) 
      		AbstractStringBuilder StringBuilder.insert(int,double) 
      		AbstractStringBuilder StringBuilder.append(Object) 
      		StringBuilder StringBuilder.deleteCharAt(int) 
      		AbstractStringBuilder StringBuilder.append(double) 
      		StringBuilder.<init>() 
      		AbstractStringBuilder StringBuilder.insert(int,char) 
      		void StringBuilder.setLength(int) 
      		int StringBuilder.codePointCount(int,int) 
      		StringBuilder StringBuilder.insert(int,String) 
      		AbstractStringBuilder StringBuilder.append(char) 
      		StringBuilder StringBuilder.insert(int,float) 
      		StringBuilder StringBuilder.append(CharSequence) 
      		StringBuilder StringBuilder.append(float) 
      		Appendable StringBuilder.append(CharSequence,int,int) 
      		AbstractStringBuilder StringBuilder.replace(int,int,String) 
      		AbstractStringBuilder StringBuilder.insert(int,String) 
      		void StringBuilder.readObject(ObjectInputStream) 
      		StringBuilder StringBuilder.append(char[],int,int) 
      		StringBuilder StringBuilder.insert(int,char) 
      		StringBuilder StringBuilder.append(int) 
      		AbstractStringBuilder StringBuilder.append(CharSequence) 
      		AbstractStringBuilder StringBuilder.insert(int,float) 
      		int StringBuilder.capacity() 
      		StringBuilder StringBuilder.replace(int,int,String) 
      		AbstractStringBuilder StringBuilder.append(float) 
      		int StringBuilder.codePointAt(int) 
      		AbstractStringBuilder StringBuilder.insert(int,boolean) 
      		void StringBuilder.setCharAt(int,char) 
      		int StringBuilder.lastIndexOf(String,int) 
      		int StringBuilder.codePointBefore(int) 
      		StringBuilder StringBuilder.insert(int,char[]) 
      		StringBuilder StringBuilder.append(char) 
      		AbstractStringBuilder StringBuilder.append(boolean) 
      		int StringBuilder.lastIndexOf(String) 
      		StringBuilder StringBuilder.insert(int,double) 
      		String StringBuilder.toString() 
      		StringBuilder StringBuilder.append(double) 
      		Appendable StringBuilder.append(char) 
      		AbstractStringBuilder StringBuilder.deleteCharAt(int) 
      		AbstractStringBuilder StringBuilder.insert(int,CharSequence) 
      		StringBuilder StringBuilder.append(CharSequence,int,int) 
      		int StringBuilder.indexOf(String,int) 
      		int StringBuilder.length() 
      		StringBuilder StringBuilder.insert(int,CharSequence,int,int) 
      		AbstractStringBuilder StringBuilder.append(char[]) 
      		AbstractStringBuilder StringBuilder.reverse() 
      		StringBuilder StringBuilder.append(String) 
      		StringBuilder StringBuilder.appendCodePoint(int) 
      		AbstractStringBuilder StringBuilder.appendCodePoint(int) 
      		StringBuilder.<init>(String) 
      		AbstractStringBuilder StringBuilder.insert(int,int) 
      		void StringBuilder.trimToSize() 
      		int StringBuilder.offsetByCodePoints(int,int) 
      		StringBuilder StringBuilder.insert(int,Object) 
      		AbstractStringBuilder StringBuilder.append(int) 
      		StringBuilder.<init>(CharSequence) 
      		StringBuilder StringBuilder.insert(int,long) 
      		CharSequence StringBuilder.subSequence(int,int) 
      		AbstractStringBuilder StringBuilder.append(String) 
      		StringBuilder StringBuilder.append(long) 
      		Appendable StringBuilder.append(CharSequence) 
      		AbstractStringBuilder StringBuilder.insert(int,char[],int,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Class
TYPE: class java.lang.Class 
      	fields: {
      		int classRedefinedCount <_volatile> 
      		java.lang.String* name <> 
      		java.lang.ref.SoftReference* reflectionData <_volatile> 
      		java.lang.ClassValue$ClassValueMap* classValueMap <> 
      		java.util.Map* enumConstantDirectory <_volatile> 
      		java.lang.Class* newInstanceCallerCache <_volatile> 
      		sun.reflect.generics.repository.ClassRepository* genericInfo <_volatile> 
      		sun.reflect.annotation.AnnotationType* annotationType <_volatile> 
      		java.lang.Object*[_*_](*) enumConstants <_volatile> 
      		java.lang.reflect.Constructor* cachedConstructor <_volatile> 
      		java.lang.Class$AnnotationData* annotationData <_volatile> 
      		java.lang.ClassLoader* classLoader <_final>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable 
      		class java.lang.reflect.GenericDeclaration 
      		class java.lang.reflect.Type 
      		class java.lang.reflect.AnnotatedElement
      	}
      	methods: {
      		void Class.<clinit>() 
      		Package Class.getPackage() 
      		ClassLoader Class.getClassLoader0() 
      		Map Class.getDeclaredAnnotationMap() 
      		boolean Class.isAsciiDigit(char) 
      		Field Class.getDeclaredField(String) 
      		Method[] Class.privateGetDeclaredMethods(boolean) 
      		ConstantPool Class.getConstantPool() 
      		Class[] Class.getClasses() 
      		Method[] Class.copyMethods(Method[]) 
      		boolean Class.isInterface() 
      		Class$AnnotationData Class.annotationData() 
      		Annotation Class.getAnnotation(Class) 
      		boolean Class.isAssignableFrom(Class) 
      		Method Class.getEnclosingMethod() 
      		Field Class.access$200(Field[],String) 
      		Object[] Class.getEnumConstants() 
      		Object[] Class.getEnclosingMethod0() 
      		InputStream Class.getResourceAsStream(String) 
      		Field Class.getField(String) 
      		GenericsFactory Class.getFactory() 
      		Method Class.getMethod0(String,Class[],boolean) 
      		boolean Class.isAnnotation() 
      		Annotation[] Class.getDeclaredAnnotationsByType(Class) 
      		Class Class.getDeclaringClass() 
      		Class Class.forName(String,boolean,ClassLoader) 
      		Object[] Class.getSigners() 
      		ClassRepository Class.getGenericInfo() 
      		AnnotatedType[] Class.getAnnotatedInterfaces() 
      		boolean Class.isLocalOrAnonymousClass() 
      		Method Class.getMethod(String,Class[]) 
      		Constructor Class.getDeclaredConstructor(Class[]) 
      		String Class.resolveName(String) 
      		Class Class.forName0(String,boolean,ClassLoader,Class) 
      		Method[] Class.getMethods() 
      		Constructor[] Class.getDeclaredConstructors0(boolean) 
      		Constructor[] Class.copyConstructors(Constructor[]) 
      		int Class.getModifiers() 
      		Annotation[] Class.getAnnotations() 
      		Class Class.getDeclaringClass0() 
      		Method Class.privateGetMethodRecursive(String,Class[],boolean,Class$MethodArray) 
      		Class.<init>(ClassLoader) 
      		boolean Class.isLocalClass() 
      		Class[] Class.getInterfaces0() 
      		byte[] Class.getExecutableTypeAnnotationBytes(Executable) 
      		boolean Class.access$402(boolean) 
      		Field[] Class.copyFields(Field[]) 
      		Field Class.searchFields(Field[],String) 
      		boolean Class.isInstance(Object) 
      		Object Class.cast(Object) 
      		String Class.getName() 
      		URL Class.getResource(String) 
      		void Class.checkMemberAccess(int,Class,boolean) 
      		Class[] Class.getDeclaredClasses() 
      		Class[] Class.getDeclaredClasses0() 
      		TypeVariable[] Class.getTypeParameters() 
      		boolean Class.casAnnotationType(AnnotationType,AnnotationType) 
      		String Class.getSimpleName() 
      		boolean Class.isSynthetic() 
      		Type[] Class.getGenericInterfaces() 
      		AnnotatedType Class.getAnnotatedSuperclass() 
      		String Class.getCanonicalName() 
      		Object[] Class.getEnumConstantsShared() 
      		Method Class.getDeclaredMethod(String,Class[]) 
      		Class Class.getEnclosingClass() 
      		Method Class.searchMethods(Method[],String,Class[]) 
      		Field[] Class.getFields() 
      		Class$EnclosingMethodInfo Class.getEnclosingMethodInfo() 
      		void Class.addAll(Collection,Field[]) 
      		Constructor[] Class.privateGetDeclaredConstructors(boolean) 
      		boolean Class.isPrimitive() 
      		Class Class.getSuperclass() 
      		boolean Class.isAnnotationPresent(Class) 
      		Annotation[] Class.getAnnotationsByType(Class) 
      		Class Class.getPrimitiveClass(String) 
      		Constructor[] Class.getDeclaredConstructors() 
      		Class Class.getComponentType() 
      		ClassLoader Class.getClassLoader() 
      		Constructor Class.getEnclosingConstructor() 
      		Class$ReflectionData Class.reflectionData() 
      		ReflectionFactory Class.getReflectionFactory() 
      		boolean Class.access$300(Object[],Object[]) 
      		Field[] Class.privateGetPublicFields(Set) 
      		boolean Class.arrayContentsEq(Object[],Object[]) 
      		Map Class.enumConstantDirectory() 
      		Constructor Class.getConstructor(Class[]) 
      		String Class.toString() 
      		String Class.argumentTypesToString(Class[]) 
      		boolean Class.isEnum() 
      		Class$AnnotationData Class.createAnnotationData(int) 
      		Annotation[] Class.getDeclaredAnnotations() 
      		boolean Class.isArray() 
      		Object Class.newInstance() 
      		void Class.setSigners(Object[]) 
      		String Class.getGenericSignature0() 
      		Field[] Class.access$100(Class,boolean) 
      		boolean Class.isAnonymousClass() 
      		ProtectionDomain Class.getProtectionDomain() 
      		Constructor[] Class.getConstructors() 
      		void Class.registerNatives() 
      		Method[] Class.getDeclaredMethods0(boolean) 
      		Field Class.getField0(String) 
      		Annotation Class.getDeclaredAnnotation(Class) 
      		void Class.checkPackageAccess(ClassLoader,boolean) 
      		boolean Class.desiredAssertionStatus() 
      		String Class.toGenericString() 
      		boolean Class.isMemberClass() 
      		Class[] Class.getInterfaces() 
      		void Class.checkInitted() 
      		boolean Class.access$502(boolean) 
      		Method[] Class.privateGetPublicMethods() 
      		Field[] Class.getDeclaredFields0(boolean) 
      		Method[] Class.getDeclaredMethods() 
      		String Class.cannotCastMsg(Object) 
      		Class Class.asSubclass(Class) 
      		Class Class.forName(String) 
      		ProtectionDomain Class.getProtectionDomain0() 
      		Constructor Class.getConstructor0(Class[],int) 
      		byte[] Class.getRawTypeAnnotations() 
      		Field[] Class.getDeclaredFields() 
      		Class Class.toClass(Type) 
      		Field[] Class.privateGetDeclaredFields(boolean) 
      		String Class.getTypeName() 
      		byte[] Class.getRawAnnotations() 
      		AnnotationType Class.getAnnotationType() 
      		String Class.getSimpleBinaryName() 
      		boolean Class.desiredAssertionStatus0(Class) 
      		Class$ReflectionData Class.newReflectionData(SoftReference,int) 
      		String Class.getName0() 
      		Type Class.getGenericSuperclass()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.DoubleToIntFunction
TYPE: class java.util.function.DoubleToIntFunction 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		int DoubleToIntFunction.applyAsInt(double)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.util.function.BiConsumer
TYPE: class java.util.function.BiConsumer 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		BiConsumer BiConsumer.callsite_java.util.function.BiConsumer$Lambda$_1_7(BiConsumer,BiConsumer) 
      		void BiConsumer.accept(Object,Object) 
      		void BiConsumer.access_java.util.function.BiConsumer$Lambda$_1_7(BiConsumer,BiConsumer,Object,Object) 
      		void BiConsumer.lambda$andThen$0(BiConsumer,Object,Object) 
      		BiConsumer BiConsumer.andThen(BiConsumer)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.lang.reflect.AccessibleObject
TYPE: class java.lang.reflect.AccessibleObject 
      	fields: {
      		java.lang.Object* securityCheckCache <_volatile> 
      		_Bool override <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.lang.reflect.AnnotatedElement
      	}
      	methods: {
      		void AccessibleObject.<clinit>() 
      		Annotation AccessibleObject.getAnnotation(Class) 
      		void AccessibleObject.setAccessible0(AccessibleObject,boolean) 
      		Annotation[] AccessibleObject.getDeclaredAnnotationsByType(Class) 
      		void AccessibleObject.setAccessible(boolean) 
      		void AccessibleObject.checkAccess(Class,Class,Object,int) 
      		Annotation[] AccessibleObject.getAnnotations() 
      		void AccessibleObject.slowCheckMemberAccess(Class,Class,Object,int,Class) 
      		AccessibleObject.<init>() 
      		boolean AccessibleObject.isAnnotationPresent(Class) 
      		Annotation[] AccessibleObject.getAnnotationsByType(Class) 
      		Annotation[] AccessibleObject.getDeclaredAnnotations() 
      		boolean AccessibleObject.isAccessible() 
      		Annotation AccessibleObject.getDeclaredAnnotation(Class) 
      		void AccessibleObject.setAccessible(AccessibleObject[],boolean)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.security.MessageDigestSpi
TYPE: class java.security.MessageDigestSpi 
      	fields: {
      		signed char[_*_](*) tempArray <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		int MessageDigestSpi.engineDigest(byte[],int,int) 
      		void MessageDigestSpi.engineUpdate(byte) 
      		Object MessageDigestSpi.clone() 
      		void MessageDigestSpi.engineReset() 
      		MessageDigestSpi.<init>() 
      		void MessageDigestSpi.engineUpdate(ByteBuffer) 
      		void MessageDigestSpi.engineUpdate(byte[],int,int) 
      		int MessageDigestSpi.engineGetDigestLength() 
      		byte[] MessageDigestSpi.engineDigest()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.net.Proxy
TYPE: class java.net.Proxy 
      	fields: {
      		java.net.Proxy$Type* type <> 
      		java.net.SocketAddress* sa <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Proxy.<clinit>() 
      		int Proxy.hashCode() 
      		boolean Proxy.equals(Object) 
      		Proxy$Type Proxy.type() 
      		Proxy.<init>(Proxy$Type,SocketAddress) 
      		Proxy.<init>() 
      		SocketAddress Proxy.address() 
      		String Proxy.toString()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.pojo.News
TYPE: class com.stn.pojo.News 
      	fields: {
      		int idSerie <> 
      		java.lang.String* title <> 
      		java.lang.String* username <> 
      		java.sql.Timestamp* date <> 
      		int userClass <> 
      		java.lang.String* body <> 
      		java.sql.Timestamp* lastEdit <> 
      		int idNews <> 
      		int idUser <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void News.setIdUser(int) 
      		int News.getIdUser() 
      		void News.setTitle(String) 
      		int News.getUserClass() 
      		Timestamp News.getDate() 
      		void News.setLastEdit(Timestamp) 
      		void News.setIdNews(int) 
      		int News.getIdSerie() 
      		void News.setUsername(String) 
      		News.<init>() 
      		String News.getTitle() 
      		void News.setIdSerie(int) 
      		Timestamp News.getLastEdit() 
      		void News.setBody(String) 
      		int News.getIdNews() 
      		void News.setUserClass(int) 
      		String News.getUsername() 
      		void News.setDate(Timestamp) 
      		String News.getBody()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.stream.Collector
TYPE: class java.util.stream.Collector 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Function Collector.finisher() 
      		BiConsumer Collector.accumulator() 
      		Collector Collector.of(Supplier,BiConsumer,BinaryOperator,Collector$Characteristics[]) 
      		Supplier Collector.supplier() 
      		Set Collector.characteristics() 
      		BinaryOperator Collector.combiner() 
      		Collector Collector.of(Supplier,BiConsumer,BinaryOperator,Function,Collector$Characteristics[])
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.time.LocalDateTime
TYPE: class java.time.LocalDateTime 
      	fields: {
      		java.time.LocalTime* time <_final> 
      		java.time.LocalDate* date <_final>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.time.temporal.Temporal 
      		class java.time.temporal.TemporalAdjuster 
      		class java.time.chrono.ChronoLocalDateTime 
      		class java.io.Serializable
      	}
      	methods: {
      		void LocalDateTime.<clinit>() 
      		LocalDateTime LocalDateTime.plusSeconds(long) 
      		LocalDateTime LocalDateTime.withHour(int) 
      		int LocalDateTime.compareTo(ChronoLocalDateTime) 
      		int LocalDateTime.hashCode() 
      		TemporalQuery LocalDateTime.callsite_java.time.LocalDateTime$Lambda$_58_9() 
      		LocalDateTime LocalDateTime.readExternal(DataInput) 
      		LocalDateTime LocalDateTime.with(TemporalAdjuster) 
      		int LocalDateTime.getHour() 
      		LocalDateTime LocalDateTime.minusDays(long) 
      		boolean LocalDateTime.equals(Object) 
      		void LocalDateTime.writeExternal(DataOutput) 
      		int LocalDateTime.get(TemporalField) 
      		ChronoLocalDateTime LocalDateTime.minus(long,TemporalUnit) 
      		LocalDateTime LocalDateTime.of(int,int,int,int,int,int) 
      		LocalDateTime LocalDateTime.truncatedTo(TemporalUnit) 
      		boolean LocalDateTime.isAfter(ChronoLocalDateTime) 
      		Temporal LocalDateTime.plus(TemporalAmount) 
      		int LocalDateTime.compareTo(Object) 
      		LocalDateTime LocalDateTime.of(int,Month,int,int,int) 
      		LocalDateTime LocalDateTime.plus(long,TemporalUnit) 
      		LocalDateTime LocalDateTime.minusNanos(long) 
      		LocalDateTime LocalDateTime.minus(long,TemporalUnit) 
      		int LocalDateTime.getDayOfYear() 
      		ChronoLocalDateTime LocalDateTime.with(TemporalField,long) 
      		LocalDateTime LocalDateTime.withYear(int) 
      		LocalDateTime LocalDateTime.plusHours(long) 
      		LocalDateTime LocalDateTime.withSecond(int) 
      		LocalTime LocalDateTime.toLocalTime() 
      		Object LocalDateTime.query(TemporalQuery) 
      		Temporal LocalDateTime.minus(TemporalAmount) 
      		LocalDateTime LocalDateTime.now() 
      		int LocalDateTime.getSecond() 
      		LocalDateTime LocalDateTime.minusMinutes(long) 
      		ChronoLocalDateTime LocalDateTime.plus(long,TemporalUnit) 
      		LocalDateTime LocalDateTime.parse(CharSequence) 
      		int LocalDateTime.getMonthValue() 
      		LocalDateTime LocalDateTime.minusMonths(long) 
      		boolean LocalDateTime.isEqual(ChronoLocalDateTime) 
      		ValueRange LocalDateTime.range(TemporalField) 
      		LocalDateTime.<init>(LocalDate,LocalTime) 
      		Temporal LocalDateTime.with(TemporalAdjuster) 
      		LocalDateTime LocalDateTime.of(int,Month,int,int,int,int,int) 
      		LocalDateTime LocalDateTime.plusMonths(long) 
      		OffsetDateTime LocalDateTime.atOffset(ZoneOffset) 
      		LocalDateTime LocalDateTime.plus(TemporalAmount) 
      		LocalDateTime LocalDateTime.with(LocalDate,LocalTime) 
      		ChronoLocalDate LocalDateTime.toLocalDate() 
      		LocalDateTime LocalDateTime.withDayOfMonth(int) 
      		LocalDateTime LocalDateTime.plusNanos(long) 
      		LocalDate LocalDateTime.toLocalDate() 
      		void LocalDateTime.readObject(ObjectInputStream) 
      		LocalDateTime LocalDateTime.plusMinutes(long) 
      		LocalDateTime LocalDateTime.withMinute(int) 
      		LocalDateTime LocalDateTime.access_java.time.LocalDateTime$Lambda$_58_9(TemporalAccessor) 
      		Temporal LocalDateTime.minus(long,TemporalUnit) 
      		ZonedDateTime LocalDateTime.atZone(ZoneId) 
      		LocalDateTime LocalDateTime.plusWithOverflow(LocalDate,long,long,long,long,int) 
      		int LocalDateTime.getMinute() 
      		LocalDateTime LocalDateTime.minusHours(long) 
      		long LocalDateTime.getLong(TemporalField) 
      		ChronoLocalDateTime LocalDateTime.minus(TemporalAmount) 
      		LocalDateTime LocalDateTime.ofInstant(Instant,ZoneId) 
      		LocalDateTime LocalDateTime.minusYears(long) 
      		boolean LocalDateTime.isBefore(ChronoLocalDateTime) 
      		boolean LocalDateTime.isSupported(TemporalUnit) 
      		long LocalDateTime.until(Temporal,TemporalUnit) 
      		Temporal LocalDateTime.with(TemporalField,long) 
      		LocalDateTime LocalDateTime.of(int,Month,int,int,int,int) 
      		String LocalDateTime.toString() 
      		LocalDateTime LocalDateTime.plusYears(long) 
      		LocalDateTime LocalDateTime.now(Clock) 
      		LocalDateTime LocalDateTime.of(int,int,int,int,int,int,int) 
      		String LocalDateTime.format(DateTimeFormatter) 
      		LocalDateTime LocalDateTime.minus(TemporalAmount) 
      		DayOfWeek LocalDateTime.getDayOfWeek() 
      		ChronoLocalDateTime LocalDateTime.with(TemporalAdjuster) 
      		int LocalDateTime.getYear() 
      		LocalDateTime LocalDateTime.withMonth(int) 
      		LocalDateTime LocalDateTime.withNano(int) 
      		LocalDateTime LocalDateTime.from(TemporalAccessor) 
      		LocalDateTime LocalDateTime.ofEpochSecond(long,int,ZoneOffset) 
      		Temporal LocalDateTime.plus(long,TemporalUnit) 
      		LocalDateTime LocalDateTime.now(ZoneId) 
      		int LocalDateTime.getNano() 
      		LocalDateTime LocalDateTime.minusSeconds(long) 
      		LocalDateTime LocalDateTime.of(LocalDate,LocalTime) 
      		Month LocalDateTime.getMonth() 
      		ChronoLocalDateTime LocalDateTime.plus(TemporalAmount) 
      		boolean LocalDateTime.isSupported(TemporalField) 
      		int LocalDateTime.getDayOfMonth() 
      		LocalDateTime LocalDateTime.minusWeeks(long) 
      		ChronoZonedDateTime LocalDateTime.atZone(ZoneId) 
      		LocalDateTime LocalDateTime.of(int,int,int,int,int) 
      		LocalDateTime LocalDateTime.plusWeeks(long) 
      		Object LocalDateTime.writeReplace() 
      		LocalDateTime LocalDateTime.with(TemporalField,long) 
      		Temporal LocalDateTime.adjustInto(Temporal) 
      		int LocalDateTime.compareTo0(LocalDateTime) 
      		LocalDateTime LocalDateTime.parse(CharSequence,DateTimeFormatter) 
      		LocalDateTime LocalDateTime.withDayOfYear(int) 
      		LocalDateTime LocalDateTime.plusDays(long)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Optional
TYPE: class java.util.Optional 
      	fields: {
      		java.lang.Object* value <_final>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Optional.<clinit>() 
      		int Optional.hashCode() 
      		Object Optional.orElse(Object) 
      		boolean Optional.equals(Object) 
      		Optional.<init>(Object) 
      		void Optional.ifPresent(Consumer) 
      		boolean Optional.isPresent() 
      		Object Optional.orElseThrow(Supplier) 
      		Optional Optional.of(Object) 
      		Optional.<init>() 
      		Optional Optional.map(Function) 
      		Object Optional.get() 
      		Object Optional.orElseGet(Supplier) 
      		Optional Optional.empty() 
      		String Optional.toString() 
      		Optional Optional.filter(Predicate) 
      		Optional Optional.ofNullable(Object) 
      		Optional Optional.flatMap(Function)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.Address
TYPE: class javax.mail.Address 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable
      	}
      	methods: {
      		boolean Address.equals(Object) 
      		Address.<init>() 
      		String Address.toString() 
      		String Address.getType()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.InputStream
TYPE: class java.io.InputStream 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Closeable
      	}
      	methods: {
      		void InputStream.mark(int) 
      		int InputStream.available() 
      		long InputStream.skip(long) 
      		void InputStream.close() 
      		int InputStream.read(byte[],int,int) 
      		InputStream.<init>() 
      		int InputStream.read() 
      		int InputStream.read(byte[]) 
      		void InputStream.reset() 
      		boolean InputStream.markSupported()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.ResultSetMetaData
TYPE: class java.sql.ResultSetMetaData 
      	fields: {
      	}
      	supers: {
      		class java.sql.Wrapper
      	}
      	methods: {
      		int ResultSetMetaData.getColumnDisplaySize(int) 
      		int ResultSetMetaData.getColumnType(int) 
      		int ResultSetMetaData.getPrecision(int) 
      		boolean ResultSetMetaData.isSearchable(int) 
      		boolean ResultSetMetaData.isDefinitelyWritable(int) 
      		String ResultSetMetaData.getColumnName(int) 
      		boolean ResultSetMetaData.isAutoIncrement(int) 
      		boolean ResultSetMetaData.isReadOnly(int) 
      		String ResultSetMetaData.getTableName(int) 
      		int ResultSetMetaData.isNullable(int) 
      		String ResultSetMetaData.getColumnLabel(int) 
      		int ResultSetMetaData.getColumnCount() 
      		String ResultSetMetaData.getColumnTypeName(int) 
      		int ResultSetMetaData.getScale(int) 
      		boolean ResultSetMetaData.isCurrency(int) 
      		String ResultSetMetaData.getColumnClassName(int) 
      		String ResultSetMetaData.getSchemaName(int) 
      		boolean ResultSetMetaData.isCaseSensitive(int) 
      		boolean ResultSetMetaData.isWritable(int) 
      		String ResultSetMetaData.getCatalogName(int) 
      		boolean ResultSetMetaData.isSigned(int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.http.HttpSessionContext
TYPE: class javax.servlet.http.HttpSessionContext 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		HttpSession HttpSessionContext.getSession(String) 
      		Enumeration HttpSessionContext.getIds()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.Deprecated>
      	}NAME: class java.lang.management.PlatformManagedObject
TYPE: class java.lang.management.PlatformManagedObject 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		ObjectName PlatformManagedObject.getObjectName()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.helpers.RecoverHelper
TYPE: class com.stn.helpers.RecoverHelper 
      	fields: {
      		java.lang.String* dbUser <> 
      		java.sql.PreparedStatement* preparedStatement <> 
      		java.lang.String* query <> 
      		java.lang.String* dbPort <> 
      		java.lang.String* dbHost <> 
      		java.lang.String* dbPassword <> 
      		java.sql.ResultSet* resultSet <> 
      		java.sql.Connection* connection <> 
      		java.lang.String* dbName <>
      	}
      	supers: {
      		class com.stn.utils.DBConnection
      	}
      	methods: {
      		void RecoverHelper.insertToken(String,String) 
      		void RecoverHelper.deleteToken(String) 
      		RecoverHelper.<init>() 
      		String RecoverHelper.checkToken(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.pojo.Comments
TYPE: class com.stn.pojo.Comments 
      	fields: {
      		java.lang.Integer* idPost <> 
      		java.sql.Timestamp* dop <> 
      		java.lang.String* cont <> 
      		java.lang.String* username <> 
      		java.lang.Integer* idUser <> 
      		java.lang.Integer* userClass <> 
      		java.sql.Timestamp* lastEdit <> 
      		java.lang.Integer* id <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		Integer Comments.getIdPost() 
      		void Comments.setLastEdit(Timestamp) 
      		void Comments.setDop(Timestamp) 
      		Timestamp Comments.getDop() 
      		void Comments.setUsername(String) 
      		void Comments.setId(Integer) 
      		String Comments.getCont() 
      		Comments.<init>() 
      		Integer Comments.getUserClass() 
      		void Comments.setIdUser(Integer) 
      		Integer Comments.getIdUser() 
      		Timestamp Comments.getLastEdit() 
      		void Comments.setIdPost(Integer) 
      		void Comments.setCont(String) 
      		String Comments.getUsername() 
      		Integer Comments.getId() 
      		void Comments.setUserClass(Integer)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.reflect.generics.factory.GenericsFactory
TYPE: class sun.reflect.generics.factory.GenericsFactory 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Type GenericsFactory.makeInt() 
      		TypeVariable GenericsFactory.findTypeVariable(String) 
      		Type GenericsFactory.makeVoid() 
      		Type GenericsFactory.makeByte() 
      		Type GenericsFactory.makeFloat() 
      		Type GenericsFactory.makeNamedType(String) 
      		TypeVariable GenericsFactory.makeTypeVariable(String,FieldTypeSignature[]) 
      		Type GenericsFactory.makeShort() 
      		Type GenericsFactory.makeLong() 
      		WildcardType GenericsFactory.makeWildcard(FieldTypeSignature[],FieldTypeSignature[]) 
      		Type GenericsFactory.makeBool() 
      		Type GenericsFactory.makeDouble() 
      		Type GenericsFactory.makeArrayType(Type) 
      		ParameterizedType GenericsFactory.makeParameterizedType(Type,Type[],Type) 
      		Type GenericsFactory.makeChar()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.ObjectInputStream$BlockDataInputStream
TYPE: class java.io.ObjectInputStream$BlockDataInputStream 
      	fields: {
      		int unread <> 
      		unsigned short[_*_](*) cbuf <_final> 
      		java.io.DataInputStream* din <_final> 
      		signed char[_*_](*) buf <_final> 
      		int pos <> 
      		java.io.ObjectInputStream$PeekInputStream* in <_final> 
      		java.io.ObjectInputStream* this$0 <_final> 
      		_Bool blkmode <> 
      		signed char[_*_](*) hbuf <_final> 
      		int end <>
      	}
      	supers: {
      		class java.io.InputStream 
      		class java.io.DataInput
      	}
      	methods: {
      		void ObjectInputStream$BlockDataInputStream.readFloats(float[],int,int) 
      		boolean ObjectInputStream$BlockDataInputStream.readBoolean() 
      		int ObjectInputStream$BlockDataInputStream.currentBlockRemaining() 
      		float ObjectInputStream$BlockDataInputStream.readFloat() 
      		ObjectInputStream$BlockDataInputStream.<init>(ObjectInputStream,InputStream) 
      		void ObjectInputStream$BlockDataInputStream.readBooleans(boolean[],int,int) 
      		int ObjectInputStream$BlockDataInputStream.readUnsignedShort() 
      		int ObjectInputStream$BlockDataInputStream.read(byte[],int,int,boolean) 
      		int ObjectInputStream$BlockDataInputStream.available() 
      		void ObjectInputStream$BlockDataInputStream.skipBlockData() 
      		int ObjectInputStream$BlockDataInputStream.peek() 
      		void ObjectInputStream$BlockDataInputStream.readFully(byte[]) 
      		long ObjectInputStream$BlockDataInputStream.skip(long) 
      		void ObjectInputStream$BlockDataInputStream.readShorts(short[],int,int) 
      		int ObjectInputStream$BlockDataInputStream.readUnsignedByte() 
      		String ObjectInputStream$BlockDataInputStream.readLine() 
      		void ObjectInputStream$BlockDataInputStream.close() 
      		int ObjectInputStream$BlockDataInputStream.read(byte[],int,int) 
      		int ObjectInputStream$BlockDataInputStream.readUTFChar(StringBuilder,long) 
      		int ObjectInputStream$BlockDataInputStream.readInt() 
      		long ObjectInputStream$BlockDataInputStream.getBytesRead() 
      		boolean ObjectInputStream$BlockDataInputStream.setBlockDataMode(boolean) 
      		void ObjectInputStream$BlockDataInputStream.readInts(int[],int,int) 
      		void ObjectInputStream$BlockDataInputStream.readDoubles(double[],int,int) 
      		byte ObjectInputStream$BlockDataInputStream.readByte() 
      		byte ObjectInputStream$BlockDataInputStream.peekByte() 
      		int ObjectInputStream$BlockDataInputStream.readBlockHeader(boolean) 
      		double ObjectInputStream$BlockDataInputStream.readDouble() 
      		int ObjectInputStream$BlockDataInputStream.read() 
      		int ObjectInputStream$BlockDataInputStream.skipBytes(int) 
      		long ObjectInputStream$BlockDataInputStream.readUTFSpan(StringBuilder,long) 
      		char ObjectInputStream$BlockDataInputStream.readChar() 
      		void ObjectInputStream$BlockDataInputStream.readFully(byte[],int,int,boolean) 
      		void ObjectInputStream$BlockDataInputStream.readFully(byte[],int,int) 
      		String ObjectInputStream$BlockDataInputStream.readLongUTF() 
      		void ObjectInputStream$BlockDataInputStream.readChars(char[],int,int) 
      		short ObjectInputStream$BlockDataInputStream.readShort() 
      		String ObjectInputStream$BlockDataInputStream.readUTF() 
      		long ObjectInputStream$BlockDataInputStream.readLong() 
      		String ObjectInputStream$BlockDataInputStream.readUTFBody(long) 
      		void ObjectInputStream$BlockDataInputStream.refill() 
      		boolean ObjectInputStream$BlockDataInputStream.getBlockDataMode() 
      		void ObjectInputStream$BlockDataInputStream.readLongs(long[],int,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.BufferedWriter
TYPE: class java.io.BufferedWriter 
      	fields: {
      		unsigned short[_*_](*) cb <> 
      		java.io.Writer* out <> 
      		int nextChar <> 
      		java.lang.String* lineSeparator <> 
      		int nChars <> 
      		unsigned short[_*_](*) writeBuffer <> 
      		java.lang.Object* lock <>
      	}
      	supers: {
      		class java.io.Writer
      	}
      	methods: {
      		void BufferedWriter.<clinit>() 
      		int BufferedWriter.min(int,int) 
      		void BufferedWriter.write(String,int,int) 
      		BufferedWriter.<init>(Writer,int) 
      		void BufferedWriter.write(int) 
      		void BufferedWriter.write(char[],int,int) 
      		void BufferedWriter.newLine() 
      		void BufferedWriter.close() 
      		void BufferedWriter.flushBuffer() 
      		void BufferedWriter.flush() 
      		BufferedWriter.<init>(Writer) 
      		void BufferedWriter.ensureOpen()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.ObjectOutputStream$PutField
TYPE: class java.io.ObjectOutputStream$PutField 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void ObjectOutputStream$PutField.put(String,float) 
      		void ObjectOutputStream$PutField.put(String,double) 
      		void ObjectOutputStream$PutField.put(String,int) 
      		void ObjectOutputStream$PutField.put(String,char) 
      		ObjectOutputStream$PutField.<init>() 
      		void ObjectOutputStream$PutField.put(String,Object) 
      		void ObjectOutputStream$PutField.put(String,byte) 
      		void ObjectOutputStream$PutField.write(ObjectOutput) 
      		void ObjectOutputStream$PutField.put(String,boolean) 
      		void ObjectOutputStream$PutField.put(String,short) 
      		void ObjectOutputStream$PutField.put(String,long)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.PrintStream
TYPE: class java.io.PrintStream 
      	fields: {
      		java.util.Formatter* formatter <> 
      		_Bool closing <> 
      		_Bool trouble <> 
      		java.io.BufferedWriter* textOut <> 
      		java.io.OutputStreamWriter* charOut <> 
      		_Bool autoFlush <_final> 
      		java.io.OutputStream* out <>
      	}
      	supers: {
      		class java.io.FilterOutputStream 
      		class java.lang.Appendable 
      		class java.io.Closeable
      	}
      	methods: {
      		void PrintStream.print(boolean) 
      		void PrintStream.println(Object) 
      		void PrintStream.setError() 
      		boolean PrintStream.checkError() 
      		PrintStream.<init>(boolean,Charset,OutputStream) 
      		void PrintStream.println(double) 
      		void PrintStream.print(long) 
      		PrintStream.<init>(OutputStream,boolean) 
      		void PrintStream.println(char) 
      		PrintStream PrintStream.append(CharSequence,int,int) 
      		void PrintStream.print(char) 
      		void PrintStream.write(int) 
      		void PrintStream.print(Object) 
      		void PrintStream.newLine() 
      		void PrintStream.close() 
      		PrintStream PrintStream.format(Locale,String,Object[]) 
      		void PrintStream.println(String) 
      		void PrintStream.print(double) 
      		PrintStream.<init>(String,String) 
      		PrintStream.<init>(boolean,OutputStream,Charset) 
      		void PrintStream.println(long) 
      		PrintStream PrintStream.printf(String,Object[]) 
      		Appendable PrintStream.append(CharSequence,int,int) 
      		void PrintStream.println() 
      		void PrintStream.flush() 
      		void PrintStream.clearError() 
      		void PrintStream.write(char[]) 
      		PrintStream PrintStream.format(String,Object[]) 
      		void PrintStream.println(char[]) 
      		void PrintStream.print(float) 
      		Charset PrintStream.toCharset(String) 
      		void PrintStream.println(int) 
      		PrintStream PrintStream.append(CharSequence) 
      		Appendable PrintStream.append(char) 
      		void PrintStream.print(int) 
      		void PrintStream.write(byte[],int,int) 
      		void PrintStream.println(boolean) 
      		void PrintStream.write(String) 
      		PrintStream PrintStream.append(char) 
      		PrintStream.<init>(String) 
      		PrintStream.<init>(OutputStream,boolean,String) 
      		void PrintStream.print(char[]) 
      		PrintStream.<init>(File,String) 
      		void PrintStream.ensureOpen() 
      		PrintStream.<init>(boolean,OutputStream) 
      		void PrintStream.println(float) 
      		PrintStream.<init>(OutputStream) 
      		Object PrintStream.requireNonNull(Object,String) 
      		void PrintStream.print(String) 
      		PrintStream PrintStream.printf(Locale,String,Object[]) 
      		PrintStream.<init>(File) 
      		Appendable PrintStream.append(CharSequence)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.AddComment
TYPE: class com.stn.servlets.AddComment 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void AddComment.doPost(HttpServletRequest,HttpServletResponse) 
      		AddComment.<init>()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/AddComment")>
      	}NAME: class javax.mail.event.MailEvent
TYPE: class javax.mail.event.MailEvent 
      	fields: {
      		java.lang.Object* source <>
      	}
      	supers: {
      		class java.util.EventObject
      	}
      	methods: {
      		void MailEvent.dispatch(Object) 
      		MailEvent.<init>(Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.Reader
TYPE: class java.io.Reader 
      	fields: {
      		java.lang.Object* lock <> 
      		unsigned short[_*_](*) skipBuffer <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.lang.Readable 
      		class java.io.Closeable
      	}
      	methods: {
      		int Reader.read(char[],int,int) 
      		void Reader.mark(int) 
      		Reader.<init>(Object) 
      		long Reader.skip(long) 
      		void Reader.close() 
      		boolean Reader.ready() 
      		Reader.<init>() 
      		int Reader.read() 
      		int Reader.read(CharBuffer) 
      		void Reader.reset() 
      		int Reader.read(char[]) 
      		boolean Reader.markSupported()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.ref.SoftReference
TYPE: class java.lang.ref.SoftReference 
      	fields: {
      		long timestamp <> 
      		java.lang.ref.Reference* next <_volatile> 
      		java.lang.ref.ReferenceQueue* queue <_volatile> 
      		java.lang.Object* referent <> 
      		java.lang.ref.Reference* discovered <>
      	}
      	supers: {
      		class java.lang.ref.Reference
      	}
      	methods: {
      		SoftReference.<init>(Object) 
      		Object SoftReference.get() 
      		SoftReference.<init>(Object,ReferenceQueue)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.ObjectOutputStream$BlockDataOutputStream
TYPE: class java.io.ObjectOutputStream$BlockDataOutputStream 
      	fields: {
      		unsigned short[_*_](*) cbuf <_final> 
      		signed char[_*_](*) buf <_final> 
      		java.io.OutputStream* out <_final> 
      		int pos <> 
      		_Bool blkmode <> 
      		signed char[_*_](*) hbuf <_final> 
      		java.io.DataOutputStream* dout <_final>
      	}
      	supers: {
      		class java.io.OutputStream 
      		class java.io.DataOutput
      	}
      	methods: {
      		void ObjectOutputStream$BlockDataOutputStream.writeInts(int[],int,int) 
      		void ObjectOutputStream$BlockDataOutputStream.writeInt(int) 
      		void ObjectOutputStream$BlockDataOutputStream.writeLongUTF(String) 
      		void ObjectOutputStream$BlockDataOutputStream.writeShorts(short[],int,int) 
      		void ObjectOutputStream$BlockDataOutputStream.write(byte[]) 
      		void ObjectOutputStream$BlockDataOutputStream.writeBytes(String) 
      		void ObjectOutputStream$BlockDataOutputStream.writeBoolean(boolean) 
      		void ObjectOutputStream$BlockDataOutputStream.writeFloats(float[],int,int) 
      		void ObjectOutputStream$BlockDataOutputStream.write(int) 
      		void ObjectOutputStream$BlockDataOutputStream.writeFloat(float) 
      		void ObjectOutputStream$BlockDataOutputStream.close() 
      		void ObjectOutputStream$BlockDataOutputStream.writeBooleans(boolean[],int,int) 
      		boolean ObjectOutputStream$BlockDataOutputStream.setBlockDataMode(boolean) 
      		void ObjectOutputStream$BlockDataOutputStream.writeUTF(String) 
      		void ObjectOutputStream$BlockDataOutputStream.writeShort(int) 
      		void ObjectOutputStream$BlockDataOutputStream.write(byte[],int,int,boolean) 
      		void ObjectOutputStream$BlockDataOutputStream.writeUTF(String,long) 
      		void ObjectOutputStream$BlockDataOutputStream.writeLongs(long[],int,int) 
      		void ObjectOutputStream$BlockDataOutputStream.flush() 
      		void ObjectOutputStream$BlockDataOutputStream.writeLong(long) 
      		void ObjectOutputStream$BlockDataOutputStream.writeChars(char[],int,int) 
      		void ObjectOutputStream$BlockDataOutputStream.writeChars(String) 
      		void ObjectOutputStream$BlockDataOutputStream.writeByte(int) 
      		long ObjectOutputStream$BlockDataOutputStream.getUTFLength(String) 
      		void ObjectOutputStream$BlockDataOutputStream.writeDoubles(double[],int,int) 
      		void ObjectOutputStream$BlockDataOutputStream.write(byte[],int,int) 
      		void ObjectOutputStream$BlockDataOutputStream.writeDouble(double) 
      		void ObjectOutputStream$BlockDataOutputStream.writeUTFBody(String) 
      		ObjectOutputStream$BlockDataOutputStream.<init>(OutputStream) 
      		void ObjectOutputStream$BlockDataOutputStream.writeChar(int) 
      		void ObjectOutputStream$BlockDataOutputStream.writeBlockHeader(int) 
      		boolean ObjectOutputStream$BlockDataOutputStream.getBlockDataMode() 
      		void ObjectOutputStream$BlockDataOutputStream.drain() 
      		void ObjectOutputStream$BlockDataOutputStream.writeLongUTF(String,long)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.util.locale.BaseLocale
TYPE: class sun.util.locale.BaseLocale 
      	fields: {
      		java.lang.String* region <_final> 
      		java.lang.String* language <_final> 
      		java.lang.String* variant <_final> 
      		java.lang.String* script <_final> 
      		int hash <_volatile>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void BaseLocale.<clinit>() 
      		BaseLocale.<init>(String,String,String,String,BaseLocale$1) 
      		int BaseLocale.hashCode() 
      		boolean BaseLocale.equals(Object) 
      		BaseLocale.<init>(String,String,String,String) 
      		String BaseLocale.getLanguage() 
      		BaseLocale.<init>(String,String) 
      		BaseLocale BaseLocale.getInstance(String,String,String,String) 
      		String BaseLocale.getScript() 
      		String BaseLocale.toString() 
      		String BaseLocale.getRegion() 
      		String BaseLocale.getVariant() 
      		BaseLocale BaseLocale.createInstance(String,String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.reflect.Member
TYPE: class java.lang.reflect.Member 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Class Member.getDeclaringClass() 
      		int Member.getModifiers() 
      		String Member.getName() 
      		boolean Member.isSynthetic()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.UpdateFacProcess
TYPE: class com.stn.servlets.UpdateFacProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void UpdateFacProcess.doPost(HttpServletRequest,HttpServletResponse) 
      		UpdateFacProcess.<init>()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/UpdateFacProcess")>
      	}NAME: class sun.reflect.ConstructorAccessor
TYPE: class sun.reflect.ConstructorAccessor 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Object ConstructorAccessor.newInstance(Object[])
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.mail.Folder
TYPE: class javax.mail.Folder 
      	fields: {
      		java.util.Vector* connectionListeners <_volatile> 
      		java.util.Vector* folderListeners <_volatile> 
      		java.util.Vector* messageChangedListeners <_volatile> 
      		javax.mail.EventQueue* q <> 
      		java.util.Vector* messageCountListeners <_volatile> 
      		java.lang.Object* qLock <> 
      		javax.mail.Store* store <> 
      		int mode <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		boolean Folder.delete(boolean) 
      		boolean Folder.exists() 
      		Message[] Folder.expunge() 
      		int Folder.getDeletedMessageCount() 
      		Folder Folder.getParent() 
      		void Folder.addMessageChangedListener(MessageChangedListener) 
      		Folder Folder.getFolder(String) 
      		int Folder.getMode() 
      		Message[] Folder.search(SearchTerm,Message[]) 
      		void Folder.addMessageCountListener(MessageCountListener) 
      		Folder[] Folder.listSubscribed(String) 
      		void Folder.removeFolderListener(FolderListener) 
      		Store Folder.getStore() 
      		void Folder.setFlags(Message[],Flags,boolean) 
      		boolean Folder.create(int) 
      		void Folder.addConnectionListener(ConnectionListener) 
      		void Folder.open(int) 
      		void Folder.appendMessages(Message[]) 
      		void Folder.notifyFolderListeners(int) 
      		String Folder.getFullName() 
      		Message[] Folder.getMessages(int[]) 
      		Folder[] Folder.listSubscribed() 
      		void Folder.notifyMessageChangedListeners(int,Message) 
      		void Folder.finalize() 
      		void Folder.queueEvent(MailEvent,Vector) 
      		int Folder.getNewMessageCount() 
      		String Folder.getName() 
      		void Folder.notifyMessageAddedListeners(Message[]) 
      		int Folder.getMessageCount() 
      		void Folder.setFlags(int[],Flags,boolean) 
      		void Folder.setSubscribed(boolean) 
      		boolean Folder.renameTo(Folder) 
      		Message[] Folder.search(SearchTerm) 
      		Message[] Folder.getMessages(int,int) 
      		Folder[] Folder.list() 
      		void Folder.terminateQueue() 
      		void Folder.removeMessageChangedListener(MessageChangedListener) 
      		Flags Folder.getPermanentFlags() 
      		void Folder.removeMessageCountListener(MessageCountListener) 
      		String Folder.toString() 
      		boolean Folder.isOpen() 
      		int Folder.getType() 
      		void Folder.setFlags(int,int,Flags,boolean) 
      		boolean Folder.isSubscribed() 
      		void Folder.removeConnectionListener(ConnectionListener) 
      		void Folder.close(boolean) 
      		Message[] Folder.getMessages() 
      		URLName Folder.getURLName() 
      		void Folder.notifyFolderRenamedListeners(Folder) 
      		Folder[] Folder.list(String) 
      		void Folder.addFolderListener(FolderListener) 
      		void Folder.fetch(Message[],FetchProfile) 
      		char Folder.getSeparator() 
      		int Folder.getUnreadMessageCount() 
      		Folder.<init>(Store) 
      		void Folder.notifyConnectionListeners(int) 
      		void Folder.notifyMessageRemovedListeners(boolean,Message[]) 
      		Message Folder.getMessage(int) 
      		void Folder.copyMessages(Message[],Folder) 
      		boolean Folder.hasNewMessages()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.utils.Tools
TYPE: class com.stn.utils.Tools 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		double Tools.getSystemLoad() 
      		Timestamp Tools.getDate() 
      		Boolean Tools.userIsOnline(Timestamp) 
      		Tools.<init>() 
      		String Tools.formatDate(Timestamp,int) 
      		void Tools.sendEmail(String,String,String) 
      		String Tools.formatText(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class sun.util.calendar.CalendarDate
TYPE: class sun.util.calendar.CalendarDate 
      	fields: {
      		int daylightSaving <> 
      		int month <> 
      		sun.util.calendar.Era* era <> 
      		java.util.Locale* locale <> 
      		int seconds <> 
      		int dayOfWeek <> 
      		int hours <> 
      		int year <> 
      		long fraction <> 
      		int zoneOffset <> 
      		int dayOfMonth <> 
      		_Bool normalized <> 
      		int millis <> 
      		java.util.TimeZone* zoneinfo <> 
      		int minutes <> 
      		_Bool leapYear <> 
      		_Bool forceStandardTime <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.lang.Cloneable
      	}
      	methods: {
      		CalendarDate.<init>(TimeZone) 
      		int CalendarDate.getHours() 
      		int CalendarDate.hashCode() 
      		void CalendarDate.setStandardTime(boolean) 
      		CalendarDate CalendarDate.addYear(int) 
      		boolean CalendarDate.equals(Object) 
      		CalendarDate CalendarDate.setMonth(int) 
      		boolean CalendarDate.isStandardTime() 
      		void CalendarDate.setZoneOffset(int) 
      		CalendarDate CalendarDate.addHours(int) 
      		Object CalendarDate.clone() 
      		CalendarDate CalendarDate.setMinutes(int) 
      		long CalendarDate.getTimeOfDay() 
      		int CalendarDate.getSeconds() 
      		CalendarDate CalendarDate.setDate(int,int,int) 
      		void CalendarDate.setDayOfWeek(int) 
      		CalendarDate CalendarDate.addDayOfMonth(int) 
      		TimeZone CalendarDate.getZone() 
      		int CalendarDate.getDayOfWeek() 
      		boolean CalendarDate.isLeapYear() 
      		int CalendarDate.getZoneOffset() 
      		CalendarDate.<init>() 
      		void CalendarDate.setDaylightSaving(int) 
      		CalendarDate CalendarDate.addSeconds(int) 
      		boolean CalendarDate.isNormalized() 
      		CalendarDate CalendarDate.addTimeOfDay(int,int,int,int) 
      		int CalendarDate.getMonth() 
      		int CalendarDate.getMillis() 
      		int CalendarDate.getMinutes() 
      		void CalendarDate.setLocale(Locale) 
      		boolean CalendarDate.isSameDate(CalendarDate) 
      		CalendarDate CalendarDate.addMonth(int) 
      		CalendarDate CalendarDate.setDayOfMonth(int) 
      		CalendarDate CalendarDate.setEra(Era) 
      		Era CalendarDate.getEra() 
      		int CalendarDate.getDaylightSaving() 
      		CalendarDate CalendarDate.addMinutes(int) 
      		String CalendarDate.toString() 
      		CalendarDate CalendarDate.setSeconds(int) 
      		CalendarDate CalendarDate.setTimeOfDay(int,int,int,int) 
      		CalendarDate CalendarDate.addDate(int,int,int) 
      		int CalendarDate.getYear() 
      		void CalendarDate.setNormalized(boolean) 
      		CalendarDate CalendarDate.setMillis(int) 
      		boolean CalendarDate.isDaylightTime() 
      		CalendarDate CalendarDate.setHours(int) 
      		void CalendarDate.setLeapYear(boolean) 
      		CalendarDate CalendarDate.setZone(TimeZone) 
      		int CalendarDate.getDayOfMonth() 
      		CalendarDate CalendarDate.addMillis(int) 
      		CalendarDate CalendarDate.setYear(int) 
      		void CalendarDate.setTimeOfDay(long)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.AddNotes
TYPE: class com.stn.servlets.AddNotes 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		void AddNotes.doPost(HttpServletRequest,HttpServletResponse) 
      		AddNotes.<init>() 
      		void AddNotes.setTempFields(HttpServletRequest,Integer,Integer,String,String,Integer) 
      		void AddNotes.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/AddNotes")>
      	}NAME: class com.stn.helpers.FacultateHelper
TYPE: class com.stn.helpers.FacultateHelper 
      	fields: {
      		java.lang.String* dbUser <> 
      		java.sql.PreparedStatement* preparedStatement <> 
      		java.lang.String* query <> 
      		java.lang.String* dbPort <> 
      		java.lang.String* dbHost <> 
      		java.lang.String* dbPassword <> 
      		java.sql.ResultSet* resultSet <> 
      		java.sql.Connection* connection <> 
      		java.lang.String* dbName <>
      	}
      	supers: {
      		class com.stn.utils.DBConnection
      	}
      	methods: {
      		void FacultateHelper.addSerie(String,int) 
      		List FacultateHelper.getGrupe() 
      		List FacultateHelper.getFacultati() 
      		List FacultateHelper.findFacultate(String) 
      		FacultateHelper.<init>() 
      		String FacultateHelper.generateOptions2(List) 
      		void FacultateHelper.addFacultate(String) 
      		void FacultateHelper.addGrupa(String,int) 
      		String FacultateHelper.generateOptions(List) 
      		List FacultateHelper.getSerii() 
      		String FacultateHelper.getTokenGrupa(int) 
      		int FacultateHelper.checkToken(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.ArrayList
TYPE: class java.util.ArrayList 
      	fields: {
      		int size <> 
      		java.lang.Object*[_*_](*) elementData <> 
      		int mIsEmpty <> 
      		int modCount <>
      	}
      	supers: {
      		class java.util.AbstractList 
      		class java.util.List 
      		class java.util.RandomAccess 
      		class java.lang.Cloneable 
      		class java.io.Serializable
      	}
      	methods: {
      		void ArrayList.<clinit>() 
      		ArrayList.<init>(int) 
      		int ArrayList.indexOf(Object) 
      		boolean ArrayList.removeAll(Collection) 
      		void ArrayList.forEach(Consumer) 
      		void ArrayList.ensureCapacity(int) 
      		void ArrayList.add(int,Object) 
      		Object ArrayList.set(int,Object) 
      		String ArrayList.outOfBoundsMsg(int) 
      		List ArrayList.subList(int,int) 
      		Object ArrayList.clone() 
      		int ArrayList.size() 
      		boolean ArrayList.removeIf(Predicate) 
      		Iterator ArrayList.iterator() 
      		void ArrayList.writeObject(ObjectOutputStream) 
      		ArrayList.<init>(Collection) 
      		void ArrayList.rangeCheckForAdd(int) 
      		boolean ArrayList.contains(Object) 
      		ListIterator ArrayList.listIterator(int) 
      		Object[] ArrayList.toArray() 
      		void ArrayList.subListRangeCheck(int,int,int) 
      		Object[] ArrayList.toArray(Object[]) 
      		ArrayList.<init>() 
      		boolean ArrayList.remove(Object) 
      		boolean ArrayList.addAll(int,Collection) 
      		void ArrayList.sort(Comparator) 
      		int ArrayList.calculateCapacity(Object[],int) 
      		void ArrayList.readObject(ObjectInputStream) 
      		void ArrayList.rangeCheck(int) 
      		Object ArrayList.elementData(int) 
      		boolean ArrayList.retainAll(Collection) 
      		Spliterator ArrayList.spliterator() 
      		Object ArrayList.remove(int) 
      		boolean ArrayList.addAll(Collection) 
      		boolean ArrayList.batchRemove(Collection,boolean) 
      		void ArrayList.replaceAll(UnaryOperator) 
      		void ArrayList.ensureExplicitCapacity(int) 
      		int ArrayList.hugeCapacity(int) 
      		boolean ArrayList.add(Object) 
      		boolean ArrayList.isEmpty() 
      		int ArrayList.lastIndexOf(Object) 
      		void ArrayList.fastRemove(int) 
      		Object ArrayList.get(int) 
      		ListIterator ArrayList.listIterator() 
      		void ArrayList.ensureCapacityInternal(int) 
      		void ArrayList.clear() 
      		void ArrayList.removeRange(int,int) 
      		void ArrayList.trimToSize() 
      		int ArrayList.access$000(ArrayList) 
      		void ArrayList.grow(int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.time.LocalDate
TYPE: class java.time.LocalDate 
      	fields: {
      		short day <_final> 
      		int year <_final> 
      		short month <_final>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.time.temporal.Temporal 
      		class java.time.temporal.TemporalAdjuster 
      		class java.time.chrono.ChronoLocalDate 
      		class java.io.Serializable
      	}
      	methods: {
      		void LocalDate.<clinit>() 
      		LocalDate LocalDate.create(int,int,int) 
      		LocalDate LocalDate.now(ZoneId) 
      		int LocalDate.hashCode() 
      		ChronoLocalDate LocalDate.with(TemporalField,long) 
      		LocalDate LocalDate.plusDays(long) 
      		boolean LocalDate.equals(Object) 
      		LocalDateTime LocalDate.atStartOfDay() 
      		void LocalDate.writeExternal(DataOutput) 
      		int LocalDate.get(TemporalField) 
      		LocalDate LocalDate.minusDays(long) 
      		LocalDateTime LocalDate.atTime(int,int) 
      		long LocalDate.daysUntil(LocalDate) 
      		LocalDate LocalDate.of(int,Month,int) 
      		Temporal LocalDate.plus(TemporalAmount) 
      		int LocalDate.compareTo(Object) 
      		LocalDate LocalDate.withMonth(int) 
      		Era LocalDate.getEra() 
      		ChronoLocalDate LocalDate.minus(long,TemporalUnit) 
      		int LocalDate.getDayOfYear() 
      		LocalDate LocalDate.with(TemporalAdjuster) 
      		LocalDate LocalDate.plus(TemporalAmount) 
      		LocalDate LocalDate.minusYears(long) 
      		LocalDate LocalDate.minusMonths(long) 
      		Object LocalDate.query(TemporalQuery) 
      		Temporal LocalDate.minus(TemporalAmount) 
      		TemporalQuery LocalDate.callsite_java.time.LocalDate$Lambda$_61_9() 
      		int LocalDate.compareTo(ChronoLocalDate) 
      		LocalDate.<init>(int,int,int) 
      		int LocalDate.get0(TemporalField) 
      		LocalDate LocalDate.minus(TemporalAmount) 
      		ChronoLocalDateTime LocalDate.atTime(LocalTime) 
      		boolean LocalDate.isEqual(ChronoLocalDate) 
      		boolean LocalDate.isLeapYear() 
      		LocalDate LocalDate.parse(CharSequence,DateTimeFormatter) 
      		LocalDate LocalDate.plusMonths(long) 
      		int LocalDate.getMonthValue() 
      		LocalDateTime LocalDate.atTime(int,int,int,int) 
      		ValueRange LocalDate.range(TemporalField) 
      		boolean LocalDate.isAfter(ChronoLocalDate) 
      		Temporal LocalDate.with(TemporalAdjuster) 
      		LocalDate LocalDate.withDayOfYear(int) 
      		LocalDate LocalDate.resolvePreviousValid(int,int,int) 
      		ChronoLocalDate LocalDate.plus(long,TemporalUnit) 
      		IsoChronology LocalDate.getChronology() 
      		LocalDate LocalDate.now(Clock) 
      		void LocalDate.readObject(ObjectInputStream) 
      		LocalDate LocalDate.parse(CharSequence) 
      		int LocalDate.compareTo0(LocalDate) 
      		Temporal LocalDate.minus(long,TemporalUnit) 
      		ChronoLocalDate LocalDate.with(TemporalAdjuster) 
      		LocalDate LocalDate.with(TemporalField,long) 
      		int LocalDate.lengthOfYear() 
      		ZonedDateTime LocalDate.atStartOfDay(ZoneId) 
      		LocalDate LocalDate.readExternal(DataInput) 
      		long LocalDate.getLong(TemporalField) 
      		Chronology LocalDate.getChronology() 
      		boolean LocalDate.isBefore(ChronoLocalDate) 
      		LocalDate LocalDate.plusYears(long) 
      		LocalDateTime LocalDate.atTime(int,int,int) 
      		boolean LocalDate.isSupported(TemporalUnit) 
      		LocalDateTime LocalDate.atTime(LocalTime) 
      		long LocalDate.until(Temporal,TemporalUnit) 
      		Temporal LocalDate.with(TemporalField,long) 
      		LocalDate LocalDate.withDayOfMonth(int) 
      		String LocalDate.toString() 
      		String LocalDate.format(DateTimeFormatter) 
      		ChronoLocalDate LocalDate.minus(TemporalAmount) 
      		DayOfWeek LocalDate.getDayOfWeek() 
      		Period LocalDate.until(ChronoLocalDate) 
      		LocalDate LocalDate.from(TemporalAccessor) 
      		int LocalDate.getYear() 
      		LocalDate LocalDate.plus(long,TemporalUnit) 
      		LocalDate LocalDate.minusWeeks(long) 
      		long LocalDate.monthsUntil(LocalDate) 
      		Temporal LocalDate.plus(long,TemporalUnit) 
      		LocalDate LocalDate.access_java.time.LocalDate$Lambda$_61_9(TemporalAccessor) 
      		LocalDate LocalDate.withYear(int) 
      		long LocalDate.getProlepticMonth() 
      		ChronoPeriod LocalDate.until(ChronoLocalDate) 
      		Month LocalDate.getMonth() 
      		LocalDate LocalDate.minus(long,TemporalUnit) 
      		LocalDate LocalDate.ofEpochDay(long) 
      		boolean LocalDate.isSupported(TemporalField) 
      		LocalDate LocalDate.of(int,int,int) 
      		int LocalDate.lengthOfMonth() 
      		LocalDate LocalDate.plusWeeks(long) 
      		int LocalDate.getDayOfMonth() 
      		OffsetDateTime LocalDate.atTime(OffsetTime) 
      		LocalDate LocalDate.ofYearDay(int,int) 
      		Object LocalDate.writeReplace() 
      		ChronoLocalDate LocalDate.plus(TemporalAmount) 
      		Temporal LocalDate.adjustInto(Temporal) 
      		long LocalDate.toEpochDay() 
      		LocalDate LocalDate.now()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.stream.DoubleStream
TYPE: class java.util.stream.DoubleStream 
      	fields: {
      	}
      	supers: {
      		class java.util.stream.BaseStream
      	}
      	methods: {
      		DoubleStream DoubleStream.distinct() 
      		boolean DoubleStream.allMatch(DoublePredicate) 
      		double DoubleStream.reduce(double,DoubleBinaryOperator) 
      		DoubleStream DoubleStream.iterate(double,DoubleUnaryOperator) 
      		DoubleStream DoubleStream.sequential() 
      		DoubleStream DoubleStream.skip(long) 
      		DoubleStream$Builder DoubleStream.builder() 
      		OptionalDouble DoubleStream.average() 
      		OptionalDouble DoubleStream.min() 
      		Stream DoubleStream.mapToObj(DoubleFunction) 
      		Iterator DoubleStream.iterator() 
      		DoubleStream DoubleStream.peek(DoubleConsumer) 
      		OptionalDouble DoubleStream.findFirst() 
      		Object DoubleStream.collect(Supplier,ObjDoubleConsumer,BiConsumer) 
      		DoubleStream DoubleStream.concat(DoubleStream,DoubleStream) 
      		DoubleStream DoubleStream.filter(DoublePredicate) 
      		void DoubleStream.forEachOrdered(DoubleConsumer) 
      		DoubleStream DoubleStream.of(double) 
      		DoubleSummaryStatistics DoubleStream.summaryStatistics() 
      		BaseStream DoubleStream.parallel() 
      		LongStream DoubleStream.mapToLong(DoubleToLongFunction) 
      		DoubleStream DoubleStream.sorted() 
      		boolean DoubleStream.noneMatch(DoublePredicate) 
      		OptionalDouble DoubleStream.reduce(DoubleBinaryOperator) 
      		Spliterator DoubleStream.spliterator() 
      		DoubleStream DoubleStream.generate(DoubleSupplier) 
      		PrimitiveIterator$OfDouble DoubleStream.iterator() 
      		void DoubleStream.forEach(DoubleConsumer) 
      		Stream DoubleStream.boxed() 
      		DoubleStream DoubleStream.empty() 
      		Spliterator$OfDouble DoubleStream.spliterator() 
      		OptionalDouble DoubleStream.max() 
      		IntStream DoubleStream.mapToInt(DoubleToIntFunction) 
      		DoubleStream DoubleStream.limit(long) 
      		OptionalDouble DoubleStream.findAny() 
      		long DoubleStream.count() 
      		double DoubleStream.sum() 
      		DoubleStream DoubleStream.map(DoubleUnaryOperator) 
      		double[] DoubleStream.toArray() 
      		DoubleStream DoubleStream.of(double[]) 
      		DoubleStream DoubleStream.parallel() 
      		boolean DoubleStream.anyMatch(DoublePredicate) 
      		BaseStream DoubleStream.sequential() 
      		DoubleStream DoubleStream.flatMap(DoubleFunction)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.security.Provider
TYPE: class java.security.Provider 
      	fields: {
      		java.util.Map* serviceMap <> 
      		java.lang.String* name <> 
      		_Bool initialized <> 
      		java.util.Set* serviceSet <> 
      		double version <> 
      		java.util.Set* entrySet <> 
      		java.util.Map* legacyStrings <> 
      		_Bool servicesChanged <> 
      		int entrySetCallCount <> 
      		_Bool legacyChanged <> 
      		java.lang.String* info <> 
      		java.util.Map* legacyMap <> 
      		java.util.Properties* defaults <> 
      		float loadFactor <> 
      		java.util.Set* entrySet <_volatile> 
      		int count <> 
      		int threshold <> 
      		java.util.Set* keySet <_volatile> 
      		int modCount <> 
      		java.util.Collection* values <_volatile> 
      		java.util.Hashtable$Entry*[_*_](*) table <>
      	}
      	supers: {
      		class java.util.Properties
      	}
      	methods: {
      		void Provider.<clinit>() 
      		Object Provider.implComputeIfAbsent(Object,Function) 
      		void Provider.ensureLegacyParsed() 
      		String Provider.getEngineName(String) 
      		Object Provider.computeIfAbsent(Object,Function) 
      		Provider.<init>(String,double,String) 
      		Object Provider.put(Object,Object) 
      		Object Provider.implPut(Object,Object) 
      		void Provider.parseLegacyPut(String,String) 
      		Object Provider.get(Object) 
      		void Provider.implPutAll(Map) 
      		void Provider.putAll(Map) 
      		void Provider.replaceAll(BiFunction) 
      		void Provider.putService(Provider$Service) 
      		boolean Provider.implReplace(Object,Object,Object) 
      		Set Provider.keySet() 
      		Object Provider.implMerge(Object,Object,BiFunction) 
      		Object Provider.putIfAbsent(Object,Object) 
      		String Provider.getProperty(String) 
      		void Provider.check(String) 
      		Object Provider.compute(Object,BiFunction) 
      		Enumeration Provider.elements() 
      		Object Provider.getOrDefault(Object,Object) 
      		String Provider.getInfo() 
      		Object Provider.implRemove(Object) 
      		String Provider.getName() 
      		Set Provider.getServices() 
      		void Provider.load(InputStream) 
      		boolean Provider.replace(Object,Object,Object) 
      		String Provider.access$900(String) 
      		void Provider.implReplaceAll(BiFunction) 
      		Object Provider.implComputeIfPresent(Object,BiFunction) 
      		void Provider.readObject(ObjectInputStream) 
      		void Provider.implRemoveService(Provider$Service) 
      		Set Provider.entrySet() 
      		void Provider.putId() 
      		Object Provider.computeIfPresent(Object,BiFunction) 
      		Collection Provider.values() 
      		double Provider.getVersion() 
      		Object Provider.remove(Object) 
      		Object Provider.implPutIfAbsent(Object,Object) 
      		void Provider.removeInvalidServices(Map) 
      		void Provider.removePropertyStrings(Provider$Service) 
      		void Provider.checkInitialized() 
      		String Provider.toString() 
      		Enumeration Provider.keys() 
      		boolean Provider.remove(Object,Object) 
      		void Provider.removeService(Provider$Service) 
      		Object Provider.implReplace(Object,Object) 
      		boolean Provider.checkLegacy(Object) 
      		void Provider.putPropertyStrings(Provider$Service) 
      		void Provider.implClear() 
      		Object Provider.merge(Object,Object,BiFunction) 
      		void Provider.forEach(BiConsumer) 
      		Provider$Service Provider.getService(String,String) 
      		boolean Provider.implRemove(Object,Object) 
      		String[] Provider.getTypeAndAlgorithm(String) 
      		void Provider.clear() 
      		void Provider.addEngine(String,boolean,String) 
      		Object Provider.replace(Object,Object) 
      		Map Provider.access$1000() 
      		Object Provider.implCompute(Object,BiFunction)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Thread$UncaughtExceptionHandler
TYPE: class java.lang.Thread$UncaughtExceptionHandler 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void Thread$UncaughtExceptionHandler.uncaughtException(Thread,Throwable)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.util.function.ToDoubleFunction
TYPE: class java.util.function.ToDoubleFunction 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		double ToDoubleFunction.applyAsDouble(Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class com.stn.helpers.TopicHelper
TYPE: class com.stn.helpers.TopicHelper 
      	fields: {
      		java.lang.String* dbUser <> 
      		java.sql.PreparedStatement* preparedStatement <> 
      		java.lang.String* query <> 
      		java.lang.String* dbPort <> 
      		java.lang.String* dbHost <> 
      		java.lang.String* dbPassword <> 
      		java.sql.ResultSet* resultSet <> 
      		java.sql.Connection* connection <> 
      		java.lang.String* dbName <>
      	}
      	supers: {
      		class com.stn.utils.DBConnection
      	}
      	methods: {
      		List TopicHelper.getTopics(int) 
      		void TopicHelper.addTopic(String,String,int,int) 
      		TopicHelper.<init>()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.helpers.CountryHelper
TYPE: class com.stn.helpers.CountryHelper 
      	fields: {
      		java.lang.String* dbUser <> 
      		java.sql.PreparedStatement* preparedStatement <> 
      		java.lang.String* query <> 
      		java.lang.String* dbPort <> 
      		java.lang.String* dbHost <> 
      		java.lang.String* dbPassword <> 
      		java.sql.ResultSet* resultSet <> 
      		java.sql.Connection* connection <> 
      		java.lang.String* dbName <>
      	}
      	supers: {
      		class com.stn.utils.DBConnection
      	}
      	methods: {
      		List CountryHelper.getCountries() 
      		CountryHelper.<init>()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.management.MBeanInfo
TYPE: class javax.management.MBeanInfo 
      	fields: {
      		javax.management.MBeanConstructorInfo*[_*_](*) constructors <_final> 
      		javax.management.Descriptor* descriptor <> 
      		javax.management.MBeanAttributeInfo*[_*_](*) attributes <_final> 
      		javax.management.MBeanNotificationInfo*[_*_](*) notifications <_final> 
      		javax.management.MBeanOperationInfo*[_*_](*) operations <_final> 
      		int hashCode <> 
      		_Bool arrayGettersSafe <_final> 
      		java.lang.String* className <_final> 
      		java.lang.String* description <_final>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.lang.Cloneable 
      		class java.io.Serializable 
      		class javax.management.DescriptorRead
      	}
      	methods: {
      		void MBeanInfo.<clinit>() 
      		int MBeanInfo.hashCode() 
      		MBeanOperationInfo[] MBeanInfo.nonNullOperations() 
      		boolean MBeanInfo.equals(Object) 
      		MBeanConstructorInfo[] MBeanInfo.fastGetConstructors() 
      		MBeanNotificationInfo[] MBeanInfo.nonNullNotifications() 
      		Object MBeanInfo.clone() 
      		MBeanInfo.<init>(String,String,MBeanAttributeInfo[],MBeanConstructorInfo[],MBeanOperationInfo[],MBeanNotificationInfo[],Descriptor) 
      		boolean MBeanInfo.isEqual(String,String) 
      		void MBeanInfo.writeObject(ObjectOutputStream) 
      		MBeanInfo.<init>(String,String,MBeanAttributeInfo[],MBeanConstructorInfo[],MBeanOperationInfo[],MBeanNotificationInfo[]) 
      		MBeanConstructorInfo[] MBeanInfo.nonNullConstructors() 
      		MBeanNotificationInfo[] MBeanInfo.fastGetNotifications() 
      		String MBeanInfo.getDescription() 
      		MBeanAttributeInfo[] MBeanInfo.nonNullAttributes() 
      		void MBeanInfo.readObject(ObjectInputStream) 
      		MBeanOperationInfo[] MBeanInfo.getOperations() 
      		MBeanOperationInfo[] MBeanInfo.fastGetOperations() 
      		MBeanNotificationInfo[] MBeanInfo.getNotifications() 
      		String MBeanInfo.toString() 
      		boolean MBeanInfo.arrayGettersSafe(Class,Class) 
      		MBeanConstructorInfo[] MBeanInfo.getConstructors() 
      		Descriptor MBeanInfo.getDescriptor() 
      		String MBeanInfo.getClassName() 
      		MBeanAttributeInfo[] MBeanInfo.fastGetAttributes() 
      		MBeanAttributeInfo[] MBeanInfo.getAttributes()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.Writer
TYPE: class java.io.Writer 
      	fields: {
      		unsigned short[_*_](*) writeBuffer <> 
      		java.lang.Object* lock <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.lang.Appendable 
      		class java.io.Closeable 
      		class java.io.Flushable
      	}
      	methods: {
      		Writer Writer.append(CharSequence,int,int) 
      		Writer.<init>(Object) 
      		void Writer.write(String,int,int) 
      		void Writer.write(int) 
      		void Writer.write(char[],int,int) 
      		void Writer.close() 
      		Writer.<init>() 
      		Writer Writer.append(char) 
      		Appendable Writer.append(CharSequence,int,int) 
      		void Writer.flush() 
      		void Writer.write(char[]) 
      		Appendable Writer.append(char) 
      		void Writer.write(String) 
      		Writer Writer.append(CharSequence) 
      		Appendable Writer.append(CharSequence)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.AutoCloseable
TYPE: class java.lang.AutoCloseable 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void AutoCloseable.close()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.activation.DataHandler
TYPE: class javax.activation.DataHandler 
      	fields: {
      		javax.activation.DataContentHandlerFactory* oldFactory <> 
      		java.lang.Object* object <> 
      		javax.activation.DataSource* objDataSource <> 
      		javax.activation.DataContentHandler* dataContentHandler <> 
      		java.lang.String* shortType <> 
      		javax.activation.DataSource* dataSource <> 
      		java.awt.datatransfer.DataFlavor*[_*_](*) transferFlavors <> 
      		javax.activation.CommandMap* currentCommandMap <> 
      		java.lang.String* objectMimeType <> 
      		javax.activation.DataContentHandler* factoryDCH <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.awt.datatransfer.Transferable
      	}
      	methods: {
      		void DataHandler.<clinit>() 
      		DataSource DataHandler.getDataSource() 
      		Object DataHandler.access$000(DataHandler) 
      		String DataHandler.getBaseType() 
      		boolean DataHandler.isDataFlavorSupported(DataFlavor) 
      		InputStream DataHandler.getInputStream() 
      		String DataHandler.getContentType() 
      		CommandInfo[] DataHandler.getAllCommands() 
      		void DataHandler.setCommandMap(CommandMap) 
      		DataHandler.<init>(Object,String) 
      		String DataHandler.getName() 
      		DataFlavor[] DataHandler.getTransferDataFlavors() 
      		Object DataHandler.getBean(CommandInfo) 
      		String DataHandler.access$100(DataHandler) 
      		DataHandler.<init>(URL) 
      		Object DataHandler.getTransferData(DataFlavor) 
      		CommandMap DataHandler.getCommandMap() 
      		OutputStream DataHandler.getOutputStream() 
      		CommandInfo DataHandler.getCommand(String) 
      		void DataHandler.writeTo(OutputStream) 
      		CommandInfo[] DataHandler.getPreferredCommands() 
      		DataHandler.<init>(DataSource) 
      		void DataHandler.setDataContentHandlerFactory(DataContentHandlerFactory) 
      		DataContentHandler DataHandler.getDataContentHandler() 
      		Object DataHandler.getContent()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.security.Provider$Service
TYPE: class java.security.Provider$Service 
      	fields: {
      		java.lang.Boolean* hasKeyAttributes <_volatile> 
      		_Bool registered <> 
      		java.lang.String* type <> 
      		java.security.Provider* provider <_final> 
      		java.util.Map* attributes <> 
      		java.lang.ref.Reference* classRef <_volatile> 
      		java.lang.String*[_*_](*) supportedFormats <> 
      		java.lang.String* algorithm <> 
      		java.lang.String* className <> 
      		java.util.List* aliases <> 
      		java.lang.Class*[_*_](*) supportedClasses <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Provider$Service.<clinit>() 
      		Provider Provider$Service.getProvider() 
      		Object Provider$Service.newInstanceGeneric(Object) 
      		Map Provider$Service.access$800(Provider$Service) 
      		void Provider$Service.addAlias(String) 
      		void Provider$Service.access$500(Provider$Service,String) 
      		boolean Provider$Service.supportsKeyFormat(Key) 
      		Object Provider$Service.newInstance(Object) 
      		List Provider$Service.access$700(Provider$Service) 
      		String Provider$Service.access$302(Provider$Service,String) 
      		boolean Provider$Service.access$000(Provider$Service) 
      		boolean Provider$Service.isValid() 
      		String Provider$Service.getAlgorithm() 
      		void Provider$Service.addAttribute(String,String) 
      		String Provider$Service.getAttribute(String) 
      		Provider$Service.<init>(Provider,String,String,String,List,Map) 
      		Provider$Service.<init>(Provider,Provider$1) 
      		Class Provider$Service.getImplClass() 
      		Provider$Service.<init>(Provider) 
      		String Provider$Service.access$602(Provider$Service,String) 
      		String Provider$Service.toString() 
      		boolean Provider$Service.supportsKeyClass(Key) 
      		boolean Provider$Service.supportsParameter(Object) 
      		List Provider$Service.getAliases() 
      		String Provider$Service.access$402(Provider$Service,String) 
      		boolean Provider$Service.hasKeyAttributes() 
      		String Provider$Service.getClassName() 
      		String Provider$Service.getType() 
      		Class Provider$Service.getKeyClass(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.System
TYPE: class java.lang.System 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void System.<clinit>() 
      		Map System.getenv() 
      		void System.checkIO() 
      		void System.arraycopy(Object,int,Object,int,int) 
      		void System.setSecurityManager0(SecurityManager) 
      		String System.lineSeparator() 
      		long System.currentTimeMillis() 
      		void System.runFinalizersOnExit(boolean) 
      		long System.nanoTime() 
      		void System.setErr(PrintStream) 
      		void System.checkKey(String) 
      		void System.load(String) 
      		void System.gc() 
      		void System.setOut0(PrintStream) 
      		String System.getProperty(String,String) 
      		String System.getProperty(String) 
      		void System.setIn(InputStream) 
      		void System.loadLibrary(String) 
      		String System.setProperty(String,String) 
      		System.<init>() 
      		int System.identityHashCode(Object) 
      		void System.setIn0(InputStream) 
      		void System.exit(int) 
      		PrintStream System.newPrintStream(FileOutputStream,String) 
      		void System.setProperties(Properties) 
      		void System.initializeSystemClass() 
      		Console System.console() 
      		void System.setSecurityManager(SecurityManager) 
      		String System.mapLibraryName(String) 
      		void System.runFinalization() 
      		void System.setErr0(PrintStream) 
      		void System.setOut(PrintStream) 
      		SecurityManager System.getSecurityManager() 
      		void System.registerNatives() 
      		Properties System.initProperties(Properties) 
      		String System.clearProperty(String) 
      		Channel System.inheritedChannel() 
      		Properties System.getProperties() 
      		void System.setJavaLangAccess() 
      		String System.getenv(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Hashtable$Entry
TYPE: class java.util.Hashtable$Entry 
      	fields: {
      		java.lang.Object* key <_final> 
      		java.lang.Object* value <> 
      		java.util.Hashtable$Entry* next <> 
      		int hash <_final>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.util.Map$Entry
      	}
      	methods: {
      		int Hashtable$Entry.hashCode() 
      		boolean Hashtable$Entry.equals(Object) 
      		Object Hashtable$Entry.clone() 
      		Hashtable$Entry.<init>(int,Object,Object,Hashtable$Entry) 
      		Object Hashtable$Entry.getKey() 
      		Object Hashtable$Entry.setValue(Object) 
      		String Hashtable$Entry.toString() 
      		Object Hashtable$Entry.getValue()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Boolean
TYPE: class java.lang.Boolean 
      	fields: {
      		_Bool value <_final>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Serializable 
      		class java.lang.Comparable
      	}
      	methods: {
      		void Boolean.<clinit>() 
      		int Boolean.compare(boolean,boolean) 
      		int Boolean.hashCode() 
      		boolean Boolean.getBoolean(String) 
      		boolean Boolean.equals(Object) 
      		boolean Boolean.logicalOr(boolean,boolean) 
      		int Boolean.compareTo(Object) 
      		String Boolean.toString(boolean) 
      		Boolean.<init>(boolean) 
      		boolean Boolean.parseBoolean(String) 
      		int Boolean.compareTo(Boolean) 
      		boolean Boolean.logicalXor(boolean,boolean) 
      		String Boolean.toString() 
      		boolean Boolean.logicalAnd(boolean,boolean) 
      		boolean Boolean.booleanValue() 
      		Boolean Boolean.valueOf(String) 
      		Boolean.<init>(String) 
      		Boolean Boolean.valueOf(boolean) 
      		int Boolean.hashCode(boolean)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.nio.channels.Channel
TYPE: class java.nio.channels.Channel 
      	fields: {
      	}
      	supers: {
      		class java.io.Closeable
      	}
      	methods: {
      		void Channel.close() 
      		boolean Channel.isOpen()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.stn.servlets.LogoutProcess
TYPE: class com.stn.servlets.LogoutProcess 
      	fields: {
      		javax.servlet.ServletConfig* config <>
      	}
      	supers: {
      		class javax.servlet.http.HttpServlet
      	}
      	methods: {
      		LogoutProcess.<init>() 
      		void LogoutProcess.doGet(HttpServletRequest,HttpServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_javax.servlet.annotation.WebServlet(value="/LogoutProcess")>
      	}NAME: class java.net.URLStreamHandlerFactory
TYPE: class java.net.URLStreamHandlerFactory 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		URLStreamHandler URLStreamHandlerFactory.createURLStreamHandler(String)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.management.MemoryMXBean
TYPE: class java.lang.management.MemoryMXBean 
      	fields: {
      	}
      	supers: {
      		class java.lang.management.PlatformManagedObject
      	}
      	methods: {
      		MemoryUsage MemoryMXBean.getNonHeapMemoryUsage() 
      		boolean MemoryMXBean.isVerbose() 
      		void MemoryMXBean.gc() 
      		int MemoryMXBean.getObjectPendingFinalizationCount() 
      		void MemoryMXBean.setVerbose(boolean) 
      		MemoryUsage MemoryMXBean.getHeapMemoryUsage()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.Console
TYPE: class java.io.Console 
      	fields: {
      		java.io.PrintWriter* pw <> 
      		java.util.Formatter* formatter <> 
      		java.nio.charset.Charset* cs <> 
      		java.io.Writer* out <> 
      		unsigned short[_*_](*) rcb <> 
      		java.io.Reader* reader <> 
      		java.lang.Object* writeLock <> 
      		java.lang.Object* readLock <>
      	}
      	supers: {
      		class java.lang.Object 
      		class java.io.Flushable
      	}
      	methods: {
      		void Console.<clinit>() 
      		char[] Console.access$200(Console) 
      		char[] Console.readline(boolean) 
      		Console Console.access$600() 
      		boolean Console.istty() 
      		Console Console.printf(String,Object[]) 
      		boolean Console.access$400(boolean) 
      		char[] Console.readPassword(String,Object[]) 
      		String Console.readLine() 
      		PrintWriter Console.writer() 
      		Console.<init>() 
      		Console.<init>(Console$1) 
      		char[] Console.grow() 
      		Object Console.access$000(Console) 
      		boolean Console.access$300() 
      		void Console.flush() 
      		String Console.readLine(String,Object[]) 
      		Console Console.access$602(Console) 
      		boolean Console.echo(boolean) 
      		char[] Console.readPassword() 
      		boolean Console.access$500() 
      		String Console.encoding() 
      		Reader Console.reader() 
      		Charset Console.access$800(Console) 
      		Console Console.format(String,Object[]) 
      		char[] Console.access$100(Console)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.Statement
TYPE: class java.sql.Statement 
      	fields: {
      	}
      	supers: {
      		class java.sql.Wrapper 
      		class java.lang.AutoCloseable
      	}
      	methods: {
      		void Statement.setCursorName(String) 
      		SQLWarning Statement.getWarnings() 
      		long Statement.executeLargeUpdate(String,int) 
      		int Statement.executeUpdate(String,int) 
      		int Statement.getFetchSize() 
      		boolean Statement.isClosed() 
      		boolean Statement.isPoolable() 
      		int Statement.executeUpdate(String) 
      		boolean Statement.getMoreResults() 
      		boolean Statement.execute(String,int[]) 
      		ResultSet Statement.getGeneratedKeys() 
      		void Statement.clearBatch() 
      		void Statement.setLargeMaxRows(long) 
      		void Statement.setMaxRows(int) 
      		ResultSet Statement.getResultSet() 
      		long Statement.executeLargeUpdate(String,String[]) 
      		int Statement.executeUpdate(String,String[]) 
      		int Statement.getResultSetType() 
      		void Statement.close() 
      		boolean Statement.isCloseOnCompletion() 
      		void Statement.setMaxFieldSize(int) 
      		int Statement.getFetchDirection() 
      		int Statement.getResultSetHoldability() 
      		void Statement.cancel() 
      		Connection Statement.getConnection() 
      		long[] Statement.executeLargeBatch() 
      		int Statement.getQueryTimeout() 
      		boolean Statement.execute(String) 
      		void Statement.clearWarnings() 
      		long Statement.executeLargeUpdate(String,int[]) 
      		int Statement.executeUpdate(String,int[]) 
      		int Statement.getResultSetConcurrency() 
      		void Statement.closeOnCompletion() 
      		int Statement.getMaxFieldSize() 
      		void Statement.setFetchDirection(int) 
      		boolean Statement.execute(String,String[]) 
      		int[] Statement.executeBatch() 
      		long Statement.getLargeMaxRows() 
      		void Statement.setEscapeProcessing(boolean) 
      		int Statement.getUpdateCount() 
      		boolean Statement.execute(String,int) 
      		void Statement.addBatch(String) 
      		long Statement.getLargeUpdateCount() 
      		int Statement.getMaxRows() 
      		void Statement.setFetchSize(int) 
      		void Statement.setPoolable(boolean) 
      		ResultSet Statement.executeQuery(String) 
      		boolean Statement.getMoreResults(int) 
      		long Statement.executeLargeUpdate(String) 
      		void Statement.setQueryTimeout(int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.Consumer
TYPE: class java.util.function.Consumer 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void Consumer.access_java.util.function.Consumer$Lambda$_1_7(Consumer,Consumer,Object) 
      		void Consumer.lambda$andThen$0(Consumer,Object) 
      		Consumer Consumer.callsite_java.util.function.Consumer$Lambda$_1_7(Consumer,Consumer) 
      		void Consumer.accept(Object) 
      		Consumer Consumer.andThen(Consumer)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.sql.DriverManager
TYPE: class java.sql.DriverManager 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void DriverManager.<clinit>() 
      		PrintStream DriverManager.getLogStream() 
      		Connection DriverManager.getConnection(String) 
      		Connection DriverManager.getConnection(String,Properties,Class) 
      		Enumeration DriverManager.getDrivers() 
      		void DriverManager.registerDriver(Driver) 
      		Connection DriverManager.getConnection(String,String,String) 
      		void DriverManager.println(String) 
      		DriverManager.<init>() 
      		void DriverManager.setLogWriter(PrintWriter) 
      		int DriverManager.getLoginTimeout() 
      		boolean DriverManager.isDriverAllowed(Driver,ClassLoader) 
      		Driver DriverManager.getDriver(String) 
      		boolean DriverManager.isDriverAllowed(Driver,Class) 
      		void DriverManager.loadInitialDrivers() 
      		void DriverManager.setLoginTimeout(int) 
      		void DriverManager.deregisterDriver(Driver) 
      		PrintWriter DriverManager.getLogWriter() 
      		void DriverManager.registerDriver(Driver,DriverAction) 
      		Connection DriverManager.getConnection(String,Properties) 
      		void DriverManager.setLogStream(PrintStream)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.ServletRegistration
TYPE: class javax.servlet.ServletRegistration 
      	fields: {
      	}
      	supers: {
      		class javax.servlet.Registration
      	}
      	methods: {
      		Collection ServletRegistration.getMappings() 
      		Set ServletRegistration.addMapping(String[]) 
      		String ServletRegistration.getRunAsRole()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Comparator
TYPE: class java.util.Comparator 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Comparator Comparator.reversed() 
      		Comparator Comparator.nullsLast(Comparator) 
      		boolean Comparator.equals(Object) 
      		Comparator Comparator.thenComparingLong(ToLongFunction) 
      		Comparator Comparator.comparingInt(ToIntFunction) 
      		int Comparator.lambda$comparing$77a9974f$1(Function,Object,Object) 
      		Comparator Comparator.thenComparing(Function) 
      		Comparator Comparator.thenComparing(Comparator) 
      		int Comparator.lambda$thenComparing$36697e65$1(Comparator,Object,Object) 
      		Comparator Comparator.naturalOrder() 
      		Comparator Comparator.comparingDouble(ToDoubleFunction) 
      		int Comparator.lambda$comparingLong$6043328a$1(ToLongFunction,Object,Object) 
      		Comparator Comparator.thenComparing(Function,Comparator) 
      		Object Comparator.$deserializeLambda$(SerializedLambda) 
      		Comparator Comparator.comparing(Function,Comparator) 
      		int Comparator.compare(Object,Object) 
      		Comparator Comparator.thenComparingDouble(ToDoubleFunction) 
      		Comparator Comparator.comparingLong(ToLongFunction) 
      		int Comparator.lambda$comparingInt$7b0bb60$1(ToIntFunction,Object,Object) 
      		Comparator Comparator.thenComparingInt(ToIntFunction) 
      		Comparator Comparator.comparing(Function) 
      		int Comparator.lambda$comparing$ea9a8b3a$1(Comparator,Function,Object,Object) 
      		Comparator Comparator.nullsFirst(Comparator) 
      		Comparator Comparator.reverseOrder() 
      		int Comparator.lambda$comparingDouble$8dcf42ea$1(ToDoubleFunction,Object,Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class javax.servlet.RequestDispatcher
TYPE: class javax.servlet.RequestDispatcher 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void RequestDispatcher.forward(ServletRequest,ServletResponse) 
      		void RequestDispatcher.include(ServletRequest,ServletResponse)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.RandomAccess
TYPE: class java.util.RandomAccess 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Object
TYPE: class java.lang.Object 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void Object.<clinit>() 
      		int Object.hashCode() 
      		void Object.wait() 
      		Class Object.getClass() 
      		boolean Object.equals(Object) 
      		Object Object.clone() 
      		void Object.wait(long) 
      		void Object.finalize() 
      		Object.<init>() 
      		void Object.notifyAll() 
      		void Object.notify() 
      		String Object.toString() 
      		void Object.registerNatives() 
      		void Object.wait(long,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Class$ReflectionData
TYPE: class java.lang.Class$ReflectionData 
      	fields: {
      		java.lang.reflect.Field*[_*_](*) declaredPublicFields <_volatile> 
      		java.lang.reflect.Constructor*[_*_](*) declaredConstructors <_volatile> 
      		java.lang.reflect.Field*[_*_](*) publicFields <_volatile> 
      		java.lang.reflect.Method*[_*_](*) declaredMethods <_volatile> 
      		java.lang.reflect.Field*[_*_](*) declaredFields <_volatile> 
      		java.lang.reflect.Method*[_*_](*) declaredPublicMethods <_volatile> 
      		int redefinedCount <_final> 
      		java.lang.reflect.Constructor*[_*_](*) publicConstructors <_volatile> 
      		java.lang.Class*[_*_](*) interfaces <_volatile> 
      		java.lang.reflect.Method*[_*_](*) publicMethods <_volatile>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		Class$ReflectionData.<init>(int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.reflect.Method
TYPE: class java.lang.reflect.Method 
      	fields: {
      		java.lang.Class* clazz <> 
      		java.lang.Class* returnType <> 
      		java.lang.String* name <> 
      		int slot <> 
      		java.lang.Class*[_*_](*) exceptionTypes <> 
      		java.lang.reflect.Method* root <> 
      		signed char[_*_](*) annotations <> 
      		java.lang.Class*[_*_](*) parameterTypes <> 
      		signed char[_*_](*) annotationDefault <> 
      		java.lang.String* signature <> 
      		int modifiers <> 
      		sun.reflect.MethodAccessor* methodAccessor <_volatile> 
      		signed char[_*_](*) parameterAnnotations <> 
      		sun.reflect.generics.repository.MethodRepository* genericInfo <> 
      		_Bool hasRealParameterData <_volatile> 
      		java.util.Map* declaredAnnotations <> 
      		java.lang.reflect.Parameter*[_*_](*) parameters <_volatile> 
      		java.lang.Object* securityCheckCache <_volatile> 
      		_Bool override <>
      	}
      	supers: {
      		class java.lang.reflect.Executable
      	}
      	methods: {
      		Annotation[][] Method.getParameterAnnotations() 
      		int Method.hashCode() 
      		MethodRepository Method.getGenericInfo() 
      		boolean Method.equals(Object) 
      		Annotation Method.getAnnotation(Class) 
      		Type[] Method.getGenericExceptionTypes() 
      		Object Method.invoke(Object,Object[]) 
      		MethodAccessor Method.getMethodAccessor() 
      		boolean Method.isVarArgs() 
      		GenericsFactory Method.getFactory() 
      		Class[] Method.getExceptionTypes() 
      		Class Method.getDeclaringClass() 
      		ConstructorRepository Method.getGenericInfo() 
      		AnnotatedType Method.getAnnotatedReturnType() 
      		Class[] Method.getParameterTypes() 
      		Type Method.getGenericReturnType() 
      		int Method.getModifiers() 
      		byte[] Method.getAnnotationBytes() 
      		boolean Method.isBridge() 
      		String Method.getName() 
      		void Method.setMethodAccessor(MethodAccessor) 
      		TypeVariable[] Method.getTypeParameters() 
      		boolean Method.isSynthetic() 
      		void Method.handleParameterNumberMismatch(int,int) 
      		boolean Method.isDefault() 
      		void Method.specificToStringHeader(StringBuilder) 
      		boolean Method.hasGenericInformation() 
      		Method Method.copy() 
      		Object Method.getDefaultValue() 
      		String Method.getGenericSignature() 
      		String Method.toString() 
      		Annotation[] Method.getDeclaredAnnotations() 
      		void Method.specificToGenericStringHeader(StringBuilder) 
      		Type[] Method.getGenericParameterTypes() 
      		Class Method.getReturnType() 
      		MethodAccessor Method.acquireMethodAccessor() 
      		int Method.getParameterCount() 
      		String Method.toGenericString() 
      		Executable Method.getRoot() 
      		Method.<init>(Class,String,Class[],Class,Class[],int,int,String,byte[],byte[],byte[])
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.Throwable$PrintStreamOrWriter
TYPE: class java.lang.Throwable$PrintStreamOrWriter 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void Throwable$PrintStreamOrWriter.println(Object) 
      		Throwable$PrintStreamOrWriter.<init>() 
      		Throwable$PrintStreamOrWriter.<init>(Throwable$1) 
      		Object Throwable$PrintStreamOrWriter.lock()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.BinaryOperator
TYPE: class java.util.function.BinaryOperator 
      	fields: {
      	}
      	supers: {
      		class java.util.function.BiFunction
      	}
      	methods: {
      		Object BinaryOperator.access_java.util.function.BinaryOperator$Lambda$_3_6(Comparator,Object,Object) 
      		BinaryOperator BinaryOperator.minBy(Comparator) 
      		Object BinaryOperator.lambda$minBy$0(Comparator,Object,Object) 
      		Object BinaryOperator.access_java.util.function.BinaryOperator$Lambda$_4_6(Comparator,Object,Object) 
      		BinaryOperator BinaryOperator.callsite_java.util.function.BinaryOperator$Lambda$_3_6(Comparator) 
      		BinaryOperator BinaryOperator.callsite_java.util.function.BinaryOperator$Lambda$_4_6(Comparator) 
      		BinaryOperator BinaryOperator.maxBy(Comparator) 
      		Object BinaryOperator.lambda$maxBy$1(Comparator,Object,Object)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.lang.reflect.AnnotatedType
TYPE: class java.lang.reflect.AnnotatedType 
      	fields: {
      	}
      	supers: {
      		class java.lang.reflect.AnnotatedElement
      	}
      	methods: {
      		Type AnnotatedType.getType()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.http.HttpServletMapping
TYPE: class javax.servlet.http.HttpServletMapping 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		MappingMatch HttpServletMapping.getMappingMatch() 
      		String HttpServletMapping.getServletName() 
      		String HttpServletMapping.getMatchValue() 
      		String HttpServletMapping.getPattern()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.ObjectInput
TYPE: class java.io.ObjectInput 
      	fields: {
      	}
      	supers: {
      		class java.io.DataInput 
      		class java.lang.AutoCloseable
      	}
      	methods: {
      		int ObjectInput.available() 
      		long ObjectInput.skip(long) 
      		void ObjectInput.close() 
      		int ObjectInput.read(byte[],int,int) 
      		int ObjectInput.read() 
      		int ObjectInput.read(byte[]) 
      		Object ObjectInput.readObject()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.Spliterator$OfDouble
TYPE: class java.util.Spliterator$OfDouble 
      	fields: {
      	}
      	supers: {
      		class java.util.Spliterator$OfPrimitive
      	}
      	methods: {
      		void Spliterator$OfDouble.forEachRemaining(Consumer) 
      		DoubleConsumer Spliterator$OfDouble.callsite_java.util.Spliterator$OfDouble$Lambda$_5_40(Consumer) 
      		Spliterator Spliterator$OfDouble.trySplit() 
      		void Spliterator$OfDouble.forEachRemaining(DoubleConsumer) 
      		boolean Spliterator$OfDouble.tryAdvance(DoubleConsumer) 
      		DoubleConsumer Spliterator$OfDouble.callsite_java.util.Spliterator$OfDouble$Lambda$_2_42(Consumer) 
      		boolean Spliterator$OfDouble.tryAdvance(Object) 
      		boolean Spliterator$OfDouble.tryAdvance(Consumer) 
      		void Spliterator$OfDouble.access_java.util.Spliterator$OfDouble$Lambda$_5_40(Spliterator$OfDouble,Object) 
      		Spliterator$OfDouble Spliterator$OfDouble.trySplit() 
      		void Spliterator$OfDouble.forEachRemaining(Object) 
      		void Spliterator$OfDouble.access_java.util.Spliterator$OfDouble$Lambda$_2_42(Spliterator$OfDouble,Object) 
      		Spliterator$OfPrimitive Spliterator$OfDouble.trySplit()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.Array
TYPE: class java.sql.Array 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		Object Array.getArray(long,int,Map) 
      		int Array.getBaseType() 
      		ResultSet Array.getResultSet() 
      		ResultSet Array.getResultSet(long,int) 
      		Object Array.getArray(Map) 
      		ResultSet Array.getResultSet(Map) 
      		String Array.getBaseTypeName() 
      		Object Array.getArray() 
      		ResultSet Array.getResultSet(long,int,Map) 
      		void Array.free() 
      		Object Array.getArray(long,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class com.sun.management.OperatingSystemMXBean
TYPE: class com.sun.management.OperatingSystemMXBean 
      	fields: {
      	}
      	supers: {
      		class java.lang.management.OperatingSystemMXBean
      	}
      	methods: {
      		long OperatingSystemMXBean.getTotalPhysicalMemorySize() 
      		long OperatingSystemMXBean.getTotalSwapSpaceSize() 
      		long OperatingSystemMXBean.getProcessCpuTime() 
      		double OperatingSystemMXBean.getSystemCpuLoad() 
      		double OperatingSystemMXBean.getProcessCpuLoad() 
      		long OperatingSystemMXBean.getFreeSwapSpaceSize() 
      		long OperatingSystemMXBean.getCommittedVirtualMemorySize() 
      		long OperatingSystemMXBean.getFreePhysicalMemorySize()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_jdk.Exported>
      	}NAME: class java.util.PrimitiveIterator$OfDouble
TYPE: class java.util.PrimitiveIterator$OfDouble 
      	fields: {
      	}
      	supers: {
      		class java.util.PrimitiveIterator
      	}
      	methods: {
      		void PrimitiveIterator$OfDouble.forEachRemaining(Consumer) 
      		void PrimitiveIterator$OfDouble.access_java.util.PrimitiveIterator$OfDouble$Lambda$_2_47(PrimitiveIterator$OfDouble,Object) 
      		void PrimitiveIterator$OfDouble.forEachRemaining(DoubleConsumer) 
      		Double PrimitiveIterator$OfDouble.next() 
      		void PrimitiveIterator$OfDouble.forEachRemaining(Object) 
      		double PrimitiveIterator$OfDouble.nextDouble() 
      		Object PrimitiveIterator$OfDouble.next() 
      		DoubleConsumer PrimitiveIterator$OfDouble.callsite_java.util.PrimitiveIterator$OfDouble$Lambda$_2_47(Consumer)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.DoubleUnaryOperator
TYPE: class java.util.function.DoubleUnaryOperator 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		double DoubleUnaryOperator.lambda$compose$0(DoubleUnaryOperator,double) 
      		double DoubleUnaryOperator.access_java.util.function.DoubleUnaryOperator$Lambda$_1_7(DoubleUnaryOperator,DoubleUnaryOperator,double) 
      		DoubleUnaryOperator DoubleUnaryOperator.andThen(DoubleUnaryOperator) 
      		double DoubleUnaryOperator.access_java.util.function.DoubleUnaryOperator$Lambda$_3_0(double) 
      		double DoubleUnaryOperator.lambda$identity$2(double) 
      		double DoubleUnaryOperator.access_java.util.function.DoubleUnaryOperator$Lambda$_2_7(DoubleUnaryOperator,DoubleUnaryOperator,double) 
      		DoubleUnaryOperator DoubleUnaryOperator.callsite_java.util.function.DoubleUnaryOperator$Lambda$_1_7(DoubleUnaryOperator,DoubleUnaryOperator) 
      		double DoubleUnaryOperator.lambda$andThen$1(DoubleUnaryOperator,double) 
      		DoubleUnaryOperator DoubleUnaryOperator.callsite_java.util.function.DoubleUnaryOperator$Lambda$_2_7(DoubleUnaryOperator,DoubleUnaryOperator) 
      		DoubleUnaryOperator DoubleUnaryOperator.identity() 
      		DoubleUnaryOperator DoubleUnaryOperator.compose(DoubleUnaryOperator) 
      		DoubleUnaryOperator DoubleUnaryOperator.callsite_java.util.function.DoubleUnaryOperator$Lambda$_3_0() 
      		double DoubleUnaryOperator.applyAsDouble(double)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.lang.reflect.Constructor
TYPE: class java.lang.reflect.Constructor 
      	fields: {
      		java.lang.Class* clazz <> 
      		sun.reflect.ConstructorAccessor* constructorAccessor <_volatile> 
      		int slot <> 
      		java.lang.Class*[_*_](*) exceptionTypes <> 
      		signed char[_*_](*) annotations <> 
      		sun.reflect.generics.repository.ConstructorRepository* genericInfo <> 
      		java.lang.Class*[_*_](*) parameterTypes <> 
      		java.lang.String* signature <> 
      		int modifiers <> 
      		signed char[_*_](*) parameterAnnotations <> 
      		java.lang.reflect.Constructor* root <> 
      		_Bool hasRealParameterData <_volatile> 
      		java.util.Map* declaredAnnotations <> 
      		java.lang.reflect.Parameter*[_*_](*) parameters <_volatile> 
      		java.lang.Object* securityCheckCache <_volatile> 
      		_Bool override <>
      	}
      	supers: {
      		class java.lang.reflect.Executable
      	}
      	methods: {
      		String Constructor.getSignature() 
      		Annotation[][] Constructor.getParameterAnnotations() 
      		int Constructor.hashCode() 
      		boolean Constructor.equals(Object) 
      		Annotation Constructor.getAnnotation(Class) 
      		Constructor Constructor.copy() 
      		Type[] Constructor.getGenericExceptionTypes() 
      		boolean Constructor.isVarArgs() 
      		GenericsFactory Constructor.getFactory() 
      		Class[] Constructor.getExceptionTypes() 
      		Class Constructor.getDeclaringClass() 
      		ConstructorRepository Constructor.getGenericInfo() 
      		AnnotatedType Constructor.getAnnotatedReturnType() 
      		AnnotatedType Constructor.getAnnotatedReceiverType() 
      		Class[] Constructor.getParameterTypes() 
      		int Constructor.getModifiers() 
      		byte[] Constructor.getAnnotationBytes() 
      		String Constructor.getName() 
      		TypeVariable[] Constructor.getTypeParameters() 
      		int Constructor.getSlot() 
      		boolean Constructor.isSynthetic() 
      		Constructor.<init>(Class,Class[],Class[],int,int,String,byte[],byte[]) 
      		void Constructor.handleParameterNumberMismatch(int,int) 
      		void Constructor.specificToStringHeader(StringBuilder) 
      		boolean Constructor.hasGenericInformation() 
      		ConstructorAccessor Constructor.getConstructorAccessor() 
      		String Constructor.toString() 
      		Annotation[] Constructor.getDeclaredAnnotations() 
      		void Constructor.specificToGenericStringHeader(StringBuilder) 
      		Type[] Constructor.getGenericParameterTypes() 
      		ConstructorAccessor Constructor.acquireConstructorAccessor() 
      		int Constructor.getParameterCount() 
      		Object Constructor.newInstance(Object[]) 
      		String Constructor.toGenericString() 
      		Executable Constructor.getRoot() 
      		void Constructor.setConstructorAccessor(ConstructorAccessor) 
      		byte[] Constructor.getRawAnnotations() 
      		byte[] Constructor.getRawParameterAnnotations()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.sql.PreparedStatement
TYPE: class java.sql.PreparedStatement 
      	fields: {
      	}
      	supers: {
      		class java.sql.Statement
      	}
      	methods: {
      		ParameterMetaData PreparedStatement.getParameterMetaData() 
      		void PreparedStatement.clearParameters() 
      		void PreparedStatement.setNCharacterStream(int,Reader) 
      		void PreparedStatement.setTimestamp(int,Timestamp) 
      		void PreparedStatement.setFloat(int,float) 
      		void PreparedStatement.setSQLXML(int,SQLXML) 
      		void PreparedStatement.setClob(int,Clob) 
      		void PreparedStatement.setBoolean(int,boolean) 
      		void PreparedStatement.setNClob(int,NClob) 
      		void PreparedStatement.setNull(int,int) 
      		void PreparedStatement.addBatch() 
      		void PreparedStatement.setObject(int,Object,SQLType,int) 
      		void PreparedStatement.setTime(int,Time) 
      		void PreparedStatement.setCharacterStream(int,Reader,long) 
      		void PreparedStatement.setTime(int,Time,Calendar) 
      		void PreparedStatement.setString(int,String) 
      		void PreparedStatement.setNString(int,String) 
      		void PreparedStatement.setObject(int,Object) 
      		void PreparedStatement.setBlob(int,InputStream) 
      		void PreparedStatement.setBigDecimal(int,BigDecimal) 
      		void PreparedStatement.setAsciiStream(int,InputStream,long) 
      		ResultSetMetaData PreparedStatement.getMetaData() 
      		void PreparedStatement.setShort(int,short) 
      		void PreparedStatement.setBlob(int,InputStream,long) 
      		void PreparedStatement.setRef(int,Ref) 
      		long PreparedStatement.executeLargeUpdate() 
      		void PreparedStatement.setUnicodeStream(int,InputStream,int) 
      		void PreparedStatement.setBinaryStream(int,InputStream) 
      		void PreparedStatement.setNull(int,int,String) 
      		int PreparedStatement.executeUpdate() 
      		void PreparedStatement.setRowId(int,RowId) 
      		void PreparedStatement.setBytes(int,byte[]) 
      		void PreparedStatement.setObject(int,Object,int) 
      		void PreparedStatement.setClob(int,Reader) 
      		void PreparedStatement.setDouble(int,double) 
      		void PreparedStatement.setObject(int,Object,int,int) 
      		void PreparedStatement.setArray(int,Array) 
      		void PreparedStatement.setByte(int,byte) 
      		void PreparedStatement.setClob(int,Reader,long) 
      		void PreparedStatement.setCharacterStream(int,Reader,int) 
      		void PreparedStatement.setObject(int,Object,SQLType) 
      		void PreparedStatement.setAsciiStream(int,InputStream,int) 
      		void PreparedStatement.setAsciiStream(int,InputStream) 
      		void PreparedStatement.setTimestamp(int,Timestamp,Calendar) 
      		void PreparedStatement.setInt(int,int) 
      		void PreparedStatement.setNCharacterStream(int,Reader,long) 
      		boolean PreparedStatement.execute() 
      		void PreparedStatement.setNClob(int,Reader) 
      		void PreparedStatement.setDate(int,Date) 
      		void PreparedStatement.setBinaryStream(int,InputStream,long) 
      		void PreparedStatement.setDate(int,Date,Calendar) 
      		void PreparedStatement.setLong(int,long) 
      		void PreparedStatement.setNClob(int,Reader,long) 
      		void PreparedStatement.setBlob(int,Blob) 
      		void PreparedStatement.setBinaryStream(int,InputStream,int) 
      		void PreparedStatement.setCharacterStream(int,Reader) 
      		void PreparedStatement.setURL(int,URL) 
      		ResultSet PreparedStatement.executeQuery()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.nio.Buffer
TYPE: class java.nio.Buffer 
      	fields: {
      		int mark <> 
      		int capacity <> 
      		long address <> 
      		int position <> 
      		int limit <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		int Buffer.arrayOffset() 
      		Buffer Buffer.reset() 
      		int Buffer.checkIndex(int) 
      		boolean Buffer.isDirect() 
      		int Buffer.remaining() 
      		int Buffer.nextGetIndex() 
      		void Buffer.discardMark() 
      		int Buffer.limit() 
      		Buffer Buffer.flip() 
      		int Buffer.markValue() 
      		int Buffer.nextPutIndex() 
      		Buffer Buffer.limit(int) 
      		boolean Buffer.hasArray() 
      		int Buffer.position() 
      		Buffer Buffer.clear() 
      		int Buffer.capacity() 
      		int Buffer.checkIndex(int,int) 
      		int Buffer.nextGetIndex(int) 
      		Object Buffer.array() 
      		boolean Buffer.hasRemaining() 
      		Buffer Buffer.position(int) 
      		Buffer Buffer.rewind() 
      		boolean Buffer.isReadOnly() 
      		void Buffer.truncate() 
      		Buffer.<init>(int,int,int,int) 
      		int Buffer.nextPutIndex(int) 
      		Buffer Buffer.mark() 
      		void Buffer.checkBounds(int,int,int)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class javax.servlet.ServletResponse
TYPE: class javax.servlet.ServletResponse 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		boolean ServletResponse.isCommitted() 
      		String ServletResponse.getCharacterEncoding() 
      		PrintWriter ServletResponse.getWriter() 
      		String ServletResponse.getContentType() 
      		void ServletResponse.setBufferSize(int) 
      		void ServletResponse.setContentType(String) 
      		ServletOutputStream ServletResponse.getOutputStream() 
      		void ServletResponse.flushBuffer() 
      		void ServletResponse.setLocale(Locale) 
      		void ServletResponse.setCharacterEncoding(String) 
      		void ServletResponse.setContentLength(int) 
      		int ServletResponse.getBufferSize() 
      		Locale ServletResponse.getLocale() 
      		void ServletResponse.setContentLengthLong(long) 
      		void ServletResponse.reset() 
      		void ServletResponse.resetBuffer()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.io.ObjectStreamConstants
TYPE: class java.io.ObjectStreamConstants 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void ObjectStreamConstants.<clinit>()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.util.function.DoubleConsumer
TYPE: class java.util.function.DoubleConsumer 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      		void DoubleConsumer.access_java.util.function.DoubleConsumer$Lambda$_1_7(DoubleConsumer,DoubleConsumer,double) 
      		void DoubleConsumer.accept(double) 
      		void DoubleConsumer.lambda$andThen$0(DoubleConsumer,double) 
      		DoubleConsumer DoubleConsumer.callsite_java.util.function.DoubleConsumer$Lambda$_1_7(DoubleConsumer,DoubleConsumer) 
      		DoubleConsumer DoubleConsumer.andThen(DoubleConsumer)
      	}
      	exported_obj_methods: {
      	}
      	annots: {<_java.lang.FunctionalInterface>
      	}NAME: class java.io.Serializable
TYPE: class java.io.Serializable 
      	fields: {
      	}
      	supers: {
      	}
      	methods: {
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.lang.management.ManagementFactory
TYPE: class java.lang.management.ManagementFactory 
      	fields: {
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		MBeanServer ManagementFactory.getPlatformMBeanServer() 
      		MemoryMXBean ManagementFactory.getMemoryMXBean() 
      		Object ManagementFactory.newPlatformMXBeanProxy(MBeanServerConnection,String,Class) 
      		Set ManagementFactory.getPlatformManagementInterfaces() 
      		OperatingSystemMXBean ManagementFactory.getOperatingSystemMXBean() 
      		PlatformManagedObject ManagementFactory.getPlatformMXBean(MBeanServerConnection,Class) 
      		RuntimeMXBean ManagementFactory.getRuntimeMXBean() 
      		ManagementFactory.<init>() 
      		List ManagementFactory.getMemoryManagerMXBeans() 
      		List ManagementFactory.getPlatformMXBeans(Class) 
      		ThreadMXBean ManagementFactory.getThreadMXBean() 
      		List ManagementFactory.getMemoryPoolMXBeans() 
      		PlatformManagedObject ManagementFactory.getPlatformMXBean(Class) 
      		void ManagementFactory.addMXBean(MBeanServer,PlatformManagedObject) 
      		List ManagementFactory.getPlatformMXBeans(MBeanServerConnection,Class) 
      		CompilationMXBean ManagementFactory.getCompilationMXBean() 
      		List ManagementFactory.getGarbageCollectorMXBeans() 
      		void ManagementFactory.addDynamicMBean(MBeanServer,DynamicMBean,ObjectName) 
      		ClassLoadingMXBean ManagementFactory.getClassLoadingMXBean()
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}NAME: class java.net.URLConnection
TYPE: class java.net.URLConnection 
      	fields: {
      		sun.net.www.MessageHeader* requests <> 
      		int connectTimeout <> 
      		_Bool doInput <> 
      		_Bool allowUserInteraction <> 
      		java.net.URL* url <> 
      		int readTimeout <> 
      		long ifModifiedSince <> 
      		_Bool connected <> 
      		_Bool useCaches <> 
      		_Bool doOutput <>
      	}
      	supers: {
      		class java.lang.Object
      	}
      	methods: {
      		void URLConnection.<clinit>() 
      		Map URLConnection.getRequestProperties() 
      		int URLConnection.readBytes(int[],int,InputStream) 
      		ContentHandler URLConnection.getContentHandler() 
      		boolean URLConnection.getDoInput() 
      		long URLConnection.getDate() 
      		boolean URLConnection.getUseCaches() 
      		InputStream URLConnection.getInputStream() 
      		String URLConnection.guessContentTypeFromName(String) 
      		void URLConnection.setReadTimeout(int) 
      		String URLConnection.getContentType() 
      		boolean URLConnection.getAllowUserInteraction() 
      		long URLConnection.getHeaderFieldLong(String,long) 
      		String URLConnection.getHeaderFieldKey(int) 
      		FileNameMap URLConnection.getFileNameMap() 
      		void URLConnection.setDefaultUseCaches(boolean) 
      		String URLConnection.getDefaultRequestProperty(String) 
      		void URLConnection.setConnectTimeout(int) 
      		int URLConnection.getContentLength() 
      		boolean URLConnection.getDoOutput() 
      		Map URLConnection.getHeaderFields() 
      		String URLConnection.typeToPackageName(String) 
      		long URLConnection.getIfModifiedSince() 
      		FileNameMap URLConnection.access$000() 
      		String URLConnection.getContentEncoding() 
      		boolean URLConnection.getDefaultAllowUserInteraction() 
      		long URLConnection.getHeaderFieldDate(String,long) 
      		Permission URLConnection.getPermission() 
      		boolean URLConnection.checkfpx(InputStream) 
      		void URLConnection.addRequestProperty(String,String) 
      		void URLConnection.setDefaultRequestProperty(String,String) 
      		void URLConnection.setFileNameMap(FileNameMap) 
      		void URLConnection.setDoOutput(boolean) 
      		URLConnection.<init>(URL) 
      		long URLConnection.getLastModified() 
      		ContentHandler URLConnection.lookupContentHandlerClassFor(String) 
      		void URLConnection.setIfModifiedSince(long) 
      		OutputStream URLConnection.getOutputStream() 
      		String URLConnection.guessContentTypeFromStream(InputStream) 
      		int URLConnection.getReadTimeout() 
      		void URLConnection.setDefaultAllowUserInteraction(boolean) 
      		String URLConnection.toString() 
      		String URLConnection.getHeaderField(String) 
      		String URLConnection.getHeaderField(int) 
      		void URLConnection.setRequestProperty(String,String) 
      		void URLConnection.setContentHandlerFactory(ContentHandlerFactory) 
      		int URLConnection.getConnectTimeout() 
      		URL URLConnection.getURL() 
      		long URLConnection.getContentLengthLong() 
      		void URLConnection.setAllowUserInteraction(boolean) 
      		int URLConnection.getHeaderFieldInt(String,int) 
      		String URLConnection.getContentHandlerPkgPrefixes() 
      		boolean URLConnection.getDefaultUseCaches() 
      		long URLConnection.getExpiration() 
      		String URLConnection.stripOffParameters(String) 
      		void URLConnection.setUseCaches(boolean) 
      		void URLConnection.connect() 
      		void URLConnection.setDoInput(boolean) 
      		long URLConnection.skipForward(InputStream,long) 
      		Object URLConnection.getContent() 
      		String URLConnection.getRequestProperty(String) 
      		Object URLConnection.getContent(Class[])
      	}
      	exported_obj_methods: {
      	}
      	annots: {<>
      	}